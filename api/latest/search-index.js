var N = null;var searchIndex = {};
searchIndex["hc"]={"doc":"","items":[],"paths":[]};
searchIndex["hdk"]={"doc":"Holochain Development Kit (HDK)","items":[[3,"EntryValidationArgs","hdk","",N,N],[12,"entry_type","","",0,N],[12,"entry","","",0,N],[12,"validation_data","","",0,N],[4,"LinkDirection","","",N,N],[13,"To","","",1,N],[13,"From","","",1,N],[3,"LinkValidationPackageArgs","","",N,N],[12,"entry_type","","",2,N],[12,"tag","","",2,N],[12,"direction","","",2,N],[3,"LinkValidationArgs","","",N,N],[12,"entry_type","","",3,N],[12,"link","","",3,N],[12,"direction","","",3,N],[12,"validation_data","","",3,N],[17,"THIS_INSTANCE","","",N,N],[3,"ValidationPackage","","",N,N],[12,"chain_header","","",4,N],[12,"source_chain_entries","","",4,N],[12,"source_chain_headers","","",4,N],[12,"custom","","",4,N],[4,"ValidationPackageDefinition","","",N,N],[13,"Entry","","sending only the entry",5,N],[13,"ChainEntries","","sending all (public?) source chain entries",5,N],[13,"ChainHeaders","","sending all source chain headers",5,N],[13,"ChainFull","","sending the whole chain, entries and headers",5,N],[13,"Custom","","sending something custom",5,N],[3,"ValidationData","","This structs carries information contextual for the process of validating an entry of link and is passed in to the according callbacks.",N,N],[12,"package","","The validation package is data from the entry's/link's source agent that is needed to determine the validity of a given entry. What specific data gets put into the validation package has to be defined throught the validation_package callbacks in the entry! and link! macros.",6,N],[12,"sources","","The list of authors that have signed this entry.",6,N],[12,"lifecycle","","In which lifecycle of the entry creation are we running this validation callback?",6,N],[12,"action","","Does the entry get committed, modified or deleted?",6,N],[4,"EntryLifecycle","","",N,N],[13,"Chain","","",7,N],[13,"Dht","","",7,N],[13,"Meta","","",7,N],[4,"EntryAction","","",N,N],[13,"Create","","",8,N],[13,"Modify","","",8,N],[13,"Delete","","",8,N],[4,"LinkAction","","",N,N],[13,"Create","","",9,N],[13,"Delete","","",9,N],[0,"api","","This file contains many of the structs, enums, and functions relevant for Zome developers! Detailed references and examples can be found here for how to use the HDK exposed functions to access powerful Holochain functions.",N,N],[3,"EntryValidationArgs","hdk::api","",N,N],[12,"entry_type","","",0,N],[12,"entry","","",0,N],[12,"validation_data","","",0,N],[4,"LinkDirection","","",N,N],[13,"To","","",1,N],[13,"From","","",1,N],[3,"LinkValidationPackageArgs","","",N,N],[12,"entry_type","","",2,N],[12,"tag","","",2,N],[12,"direction","","",2,N],[3,"LinkValidationArgs","","",N,N],[12,"entry_type","","",3,N],[12,"link","","",3,N],[12,"direction","","",3,N],[12,"validation_data","","",3,N],[3,"DNA_NAME","","The `name` property as taken from the DNA.",N,N],[3,"DNA_HASH","","The hash of the DNA the Zome is embedded within. This is often useful as a fixed value that is known by all participants running the DNA.",N,N],[3,"AGENT_ID_STR","","The identity string used when the chain was first initialized.",N,N],[3,"AGENT_ADDRESS","","The hash of your public key. This is your node address on the DHT. It can be used for node-to-node messaging with `send` and `receive` functions.",N,N],[3,"AGENT_INITIAL_HASH","","The hash of the first identity entry on your chain (The second entry on your chain). This is your peer's identity on the DHT.",N,N],[3,"GetEntryMask","","",N,N],[4,"BundleOnClose","","Allowed input for close_bundle()",N,N],[13,"Commit","","",10,N],[13,"Discard","","",10,N],[5,"debug","","Prints a string through the stdout of the running service, and also writes that string to the logger in the execution context # Examples ```rust # #[macro_use] # extern crate hdk; # use hdk::error::ZomeApiResult;",N,[[["j"]],["zomeapiresult"]]],[5,"call","","Call an exposed function from another zome or another (bridged) instance running on the same agent in the same container. Arguments for the called function are passed as `JsonString`. Returns the value that's returned by the given function as a json str. # Examples In order to utilize `call`, you must have at least two separate Zomes. Here are two Zome examples, where one performs a `call` into the other.",N,[[["s"],["s"],["s"],["s"],["s"],["jsonstring"]],["zomeapiresult",["jsonstring"]]]],[5,"commit_entry","","Attempts to commit an entry to your local source chain. The entry will have to pass the defined validation rules for that entry type. If the entry type is defined as public, will also publish the entry to the DHT. Returns either an address of the committed entry as a string, or an error. # Examples ```rust # #![feature(try_from)] # extern crate hdk; # extern crate serde_json; # #[macro_use] # extern crate serde_derive; # extern crate holochain_core_types; # #[macro_use] # extern crate holochain_core_types_derive; # use hdk::error::ZomeApiResult; # use holochain_core_types::json::JsonString; # use holochain_core_types::error::HolochainError; # use holochain_core_types::entry::entry_type::AppEntryType; # use holochain_core_types::entry::Entry; # use holochain_core_types::cas::content::Address;",N,[[["entry"]],["zomeapiresult",["address"]]]],[5,"get_entry","","Retrieves latest version of an entry from the local chain or the DHT, by looking it up using the specified address. Returns None if no entry exists at the specified address or if the entry's crud-status is not LIVE. # Examples `rust # extern crate hdk; # extern crate holochain_core_types; # use hdk::error::ZomeApiResult; # use holochain_core_types::entry::Entry; # use holochain_core_types::json::JsonString; # use holochain_core_types::cas::content::Address; # fn main() { pub fn handle_get_post(post_address: Address) -> ZomeApiResult<Option<Entry>> { // get_entry returns a Result<Option<T>, ZomeApiError> // where T is the type that you used to commit the entry, in this case a Blog // It's a ZomeApiError if something went wrong (i.e. wrong type in deserialization) // Otherwise its a Some(T) or a None hdk::get_entry(post_address) } # }`",N,[[["address"]],["zomeapiresult",["option"]]]],[5,"get_entry_initial","","Returns the Entry at the exact address specified, whatever its crud-status. Returns None if no entry exists at the specified address.",N,[[["address"]],["zomeapiresult",["option"]]]],[5,"get_entry_history","","Return an EntryHistory filled with all the versions of the entry from the version at the specified address to the latest. Returns None if no entry exists at the specified address.",N,[[["address"]],["zomeapiresult",["option"]]]],[5,"get_entry_result","","Retrieves an entry and its metadata from the local chain or the DHT, by looking it up using the specified address. The data returned is configurable with the GetEntryOptions argument.",N,[[["address"],["getentryoptions"]],["zomeapiresult",["getentryresult"]]]],[5,"link_entries","","Consumes three values, two of which are the addresses of entries, and one of which is a string that defines a relationship between them, called a `tag`. Later, lists of entries can be looked up by using get_links. Entries can only be looked up in the direction from the `base`, which is the first argument, to the `target`. # Examples ```rust # #![feature(try_from)] # extern crate hdk; # extern crate serde_json; # #[macro_use] # extern crate serde_derive; # extern crate holochain_core_types; # #[macro_use] # extern crate holochain_core_types_derive; # use holochain_core_types::json::JsonString; # use holochain_core_types::error::HolochainError; # use holochain_core_types::entry::entry_type::AppEntryType; # use holochain_core_types::entry::Entry; # use holochain_core_types::cas::content::Address; # use hdk::AGENT_ADDRESS; # use hdk::error::ZomeApiResult; # use hdk::holochain_wasm_utils::api_serialization::get_entry::GetEntryOptions; # use hdk::holochain_wasm_utils::api_serialization::get_entry::StatusRequestKind; # fn main() {",N,[[["address"],["address"],["s"]],["result",["zomeapierror"]]]],[5,"property","","NOT YET AVAILABLE",N,[[["s"]],["zomeapiresult",["string"]]]],[5,"entry_address","","Reconstructs an address of the given entry data. This is the same value that would be returned if `entry_type_name` and `entry_value` were passed to the commit_entry function and by which it would be retrievable from the DHT using get_entry. This is often used to reconstruct an address of a `base` argument when calling get_links. # Examples ```rust # #![feature(try_from)] # extern crate hdk; # extern crate serde_json; # #[macro_use] # extern crate serde_derive; # extern crate holochain_core_types; # #[macro_use] # extern crate holochain_core_types_derive; # use hdk::error::ZomeApiResult; # use holochain_core_types::json::JsonString; # use holochain_core_types::error::HolochainError; # use holochain_core_types::entry::entry_type::AppEntryType; # use holochain_core_types::entry::AppEntryValue; # use holochain_core_types::entry::Entry; # use holochain_core_types::cas::content::Address; # fn main() {",N,[[["entry"]],["zomeapiresult",["address"]]]],[5,"sign","","NOT YET AVAILABLE",N,[[["s"]],["zomeapiresult",["string"]]]],[5,"verify_signature","","NOT YET AVAILABLE",N,[[["s"],["s"],["s"]],["zomeapiresult",["bool"]]]],[5,"update_entry","","Commit an entry to your local source chain that \"updates\" a previous entry, meaning when getting the previous entry, the updated entry will be returned. `update_entry` sets the previous entry's status metadata to `Modified` and adds the updated entry's address in the previous entry's metadata. The updated entry will hold the previous entry's address in its header, which will be used by validation routes.",N,[[["entry"],["address"]],["zomeapiresult",["address"]]]],[5,"update_agent","","NOT YET AVAILABLE",N,[[],["zomeapiresult",["address"]]]],[5,"remove_entry","","Commit a DeletionEntry to your local source chain that marks an entry as 'deleted' by setting its status metadata to `Deleted` and adding the DeleteEntry's address in the deleted entry's metadata, which will be used by validation routes.",N,[[["address"]],["zomeapiresult"]]],[5,"get_links","","Consumes two values, the first of which is the address of an entry, `base`, and the second of which is a string, `tag`, used to describe the relationship between the `base` and other entries you wish to lookup. Returns a list of addresses of other entries which matched as being linked by the given `tag`. Links are created in the first place using the Zome API function link_entries. Once you have the addresses, there is a good likelihood that you will wish to call get_entry for each of them. # Examples ```rust # extern crate hdk; # extern crate holochain_core_types; # extern crate holochain_wasm_utils; # use holochain_core_types::json::JsonString; # use holochain_core_types::cas::content::Address; # use hdk::error::ZomeApiResult; # use holochain_wasm_utils::api_serialization::get_links::GetLinksResult;",N,[[["address"],["s"]],["zomeapiresult",["getlinksresult"]]]],[5,"query","","Returns a list of entries from your local source chain, that match a given type. entry_type_name: Specify type of entry to retrieve limit: Max number of entries to retrieve # Examples ```rust # extern crate hdk; # extern crate holochain_core_types; # use hdk::error::ZomeApiResult; # use holochain_core_types::json::JsonString; # use holochain_core_types::cas::content::Address;",N,[[["str"],["u32"],["u32"]],["zomeapiresult",["queryresult"]]]],[5,"send","","Sends a node-to-node message to the given agent, specified by their address.  Addresses of agents can be accessed using hdk::AGENT_ADDRESS.  This works in conjunction with the `receive` callback that has to be defined in the  define_zome! macro.",N,[[["address"],["string"]],["zomeapiresult",["string"]]]],[5,"start_bundle","","NOT YET AVAILABLE",N,[[["usize"],["value"]],["zomeapiresult"]]],[5,"close_bundle","","NOT YET AVAILABLE",N,[[["bundleonclose"]],["zomeapiresult"]]],[18,"ENTRY","","",11,N],[18,"ENTRY_TYPE","","",11,N],[18,"SOURCES","","",11,N],[11,"empty","","Returns an empty set of flags.",11,[[],["getentrymask"]]],[11,"all","","Returns the set containing all flags.",11,[[],["getentrymask"]]],[11,"bits","","Returns the raw value of the flags currently stored.",11,[[["self"]],["u8"]]],[11,"from_bits","","Convert from underlying bit representation, unless that representation contains bits that do not correspond to a flag.",11,[[["u8"]],["option",["getentrymask"]]]],[11,"from_bits_truncate","","Convert from underlying bit representation, dropping any bits that do not correspond to flags.",11,[[["u8"]],["getentrymask"]]],[11,"is_empty","","Returns `true` if no flags are currently stored.",11,[[["self"]],["bool"]]],[11,"is_all","","Returns `true` if all flags are currently set.",11,[[["self"]],["bool"]]],[11,"intersects","","Returns `true` if there are flags common to both `self` and `other`.",11,[[["self"],["getentrymask"]],["bool"]]],[11,"contains","","Returns `true` all of the flags in `other` are contained within `self`.",11,[[["self"],["getentrymask"]],["bool"]]],[11,"insert","","Inserts the specified flags in-place.",11,[[["self"],["getentrymask"]]]],[11,"remove","","Removes the specified flags in-place.",11,[[["self"],["getentrymask"]]]],[11,"toggle","","Toggles the specified flags in-place.",11,[[["self"],["getentrymask"]]]],[11,"set","","Inserts or removes the specified flags depending on the passed value.",11,[[["self"],["getentrymask"],["bool"]]]],[0,"entry_definition","hdk","This file contains the macros used for creating validating entry type definitions, and validating links definitions within those.",N,N],[3,"ValidatingEntryType","hdk::entry_definition","This struct represents a complete entry type definition. It wraps EntryTypeDef defined in the DNA crate which only represents the static parts that show up in the JSON definition of an entry type. What is missing from there is the validation callbacks that can not be defined as JSON and are added here as Box objects (types PackageCreator, Validator, LinkValidator)",N,N],[12,"name","","Name of the entry type",12,N],[12,"entry_type_definition","","All the static aspects of the entry type as",12,N],[12,"package_creator","","Callback that returns a validation package definition that Holochain reads in order to create the right validation package to pass in to the validator callback on validation.",12,N],[12,"validator","","This is the validation callback that is used to determine if an entry is valid.",12,N],[12,"links","","",12,N],[3,"ValidatingLinkDefinition","","Similar to ValidatingEntryType, this provides the dynamic aspects of link definitions, the validation callbacks, and thus completes the structs in the DNA crate. The entry! macro expects an array of links that are represented by instances of this struct.",N,N],[12,"link_type","","Is this link defined as pointing from this entry type to some other type, or from the other type to this?",13,N],[12,"other_entry_type","","The other entry type the link connects this entry type to",13,N],[12,"tag","","Tag (i.e. name) of this type of links",13,N],[12,"package_creator","","Callback that returns a validation package definition that Holochain reads in order to create the right validation package to pass in to the validator callback on validation.",13,N],[12,"validator","","This is the validation callback that is used to determine if a link is valid.",13,N],[6,"PackageCreator","","",N,N],[6,"Validator","","",N,N],[6,"LinkValidator","","",N,N],[0,"error","hdk","This file contains defitions for Zome errors and also Zome Results.",N,N],[4,"ZomeApiError","hdk::error","Error for DNA developers to use in their Zome code. This does not have to be sent back to Ribosome unless its an InternalError.",N,N],[13,"Internal","","",14,N],[13,"FunctionNotImplemented","","",14,N],[13,"HashNotFound","","",14,N],[13,"ValidationFailed","","",14,N],[13,"Timeout","","",14,N],[6,"ZomeApiResult","","",N,N],[0,"global_fns","hdk","This file contains small helper functions relating to WASM memory management and serialization used throughout the HDK.",N,N],[3,"EntryValidationArgs","hdk::global_fns","",N,N],[12,"entry_type","","",0,N],[12,"entry","","",0,N],[12,"validation_data","","",0,N],[4,"LinkDirection","","",N,N],[13,"To","","",1,N],[13,"From","","",1,N],[3,"LinkValidationPackageArgs","","",N,N],[12,"entry_type","","",2,N],[12,"tag","","",2,N],[12,"direction","","",2,N],[3,"LinkValidationArgs","","",N,N],[12,"entry_type","","",3,N],[12,"link","","",3,N],[12,"direction","","",3,N],[12,"validation_data","","",3,N],[5,"init_global_memory","","Init global memory stack",N,[[["u32"]]]],[5,"store_and_return_output","","Serialize output as json in WASM memory",N,[[["j"]],["u32"]]],[0,"globals","hdk","Holds the internal/private globals used by the zome api library. Also contains the functions declarations of the external functions provided by the Ribosome.",N,N],[7,"G_MEM_STACK","hdk::globals","Internal global for memory usage",N,N],[0,"init_globals","hdk","Holds the internal/private zome API function `init_globals` which initializes the Zome API Globals with the values it receives from the Ribosome. It is automatically called at startup of each Zome function call.",N,N],[0,"macros","","This file contains the define_zome! macro, and smaller helper macros.",N,N],[0,"meta","","This file contains the \"secret\" functions that get added to Zomes, by the HDK. These functions match expectations that Holochain has... every Zome technically needs these functions, but not every developer should have to write them. A notable function defined here is __hdk_get_json_definition which allows Holochain to retrieve JSON defining the Zome.",N,N],[3,"ZomeDefinition","hdk::meta","",N,N],[12,"entry_types","","",15,N],[5,"__hdk_get_validation_package_for_entry_type","","",N,[[["u32"]],["u32"]]],[5,"__hdk_validate_app_entry","","",N,[[["u32"]],["u32"]]],[5,"__hdk_get_validation_package_for_link","","",N,[[["u32"]],["u32"]]],[5,"__hdk_validate_link","","",N,[[["u32"]],["u32"]]],[5,"__hdk_get_json_definition","","",N,[[["u32"]],["u32"]]],[11,"define","","",15,[[["self"],["validatingentrytype"]]]],[14,"entry","hdk","The `entry` macro is a helper for creating `ValidatingEntryType` definitions for use within the define_zome macro. It has 7 component parts: 1. name: `name` is simply the descriptive name of the entry type, such as \"post\", or \"user\".      It is what must be given as the `entry_type_name` argument when calling commit_entry and the other data read/write functions. 2. description: `description` is something that is primarily for human readers of your code, just describe this entry type 3. sharing: `sharing` defines what distribution over the DHT, or not, occurs with entries of this type, possible values      are defined in the Sharing enum 4. native_type: `native_type` references a given Rust struct, which provides a clear schema for entries of this type. 5. validation_package: `validation_package` is a special identifier, which declares which data is required from peers      when attempting to validate entries of this type.      Possible values are found within ValidationPackageDefinition 6. validation: `validation` is a callback function which will be called any time that a      (DHT) node processes or stores this entry, triggered through actions such as commit_entry, update_entry, remove_entry.      It always expects two arguments, the first of which is the entry attempting to be validated,      the second is the validation `context`, which offers a variety of metadata useful for validation.      See ValidationData for more details. 7. links: `links` is a vector of link definitions represented by `ValidatingLinkDefinition`.     Links can be defined with the `link!` macro or, more concise, with either the `to!` or `from!` macro,     to define an association pointing from this entry type to another, or one that points back from     the other entry type to this one.     See link!, to! and from! for more details. # Examples The following is a standalone Rust file that exports a function which can be called to get a `ValidatingEntryType` of a \"post\". ```rust # #![feature(try_from)] # extern crate boolinator; # extern crate serde_json; # #[macro_use] # extern crate hdk; # #[macro_use] # extern crate holochain_core_types_derive; # #[macro_use] # extern crate serde_derive; # use boolinator::*; # use hdk::entry_definition::ValidatingEntryType; # use hdk::holochain_core_types::{ #   cas::content::Address, #   dna::entry_types::Sharing, #   json::JsonString, #   error::HolochainError, # };",N,N],[14,"link","","The `link` macro is a helper for creating `ValidatingEntryType` definitions for use within the entry macro. It has 5 component parts: 1. direction: `direction` defines if this entry type (in which the link is defined) points     to another entry, or if it is referenced from another entry.     The latter is needed in cases where the definition of the entry to link from is not     accessible because it is a system entry type (AGENT_ADDRESS), or the other entry is     defined in library zome.     Must be of type LinkDirection, so either `hdk::LinkDirection::To`     or `hdk::LinkDirection::From`. 2. other_type: `other_type` is the entry type this link connects to. If direction is `to` this     would be the link target, if direction is `from` this defines the link's base type. 3. tag: `tag` is the name of this association and thus the handle by which it can be retrieved     if given to get_links() in conjunction with the base address. 4. validation_package: Similar to entries, links have to be validated.        `validation_package` is a special identifier, which declares which data is required from peers         when attempting to validate entries of this type.         Possible values are found within ValidationPackageDefinition 5. validation: `validation` is a callback function which will be called any time that a         (DHT) node processes or stores a link of this kind, triggered through the link actions link_entries and remove_link.         It always expects three arguments, the first being the base and the second the target of the link.         The third is the validation `context`, which offers a variety of metadata useful for validation.         See ValidationData for more details.",N,N],[14,"to","","The `to` macro is a helper for creating `ValidatingEntryType` definitions for use within the entry macro. It is a convenience wrapper around link! that has all the same properties except for the direction which gets set to `LinkDirection::To`.",N,N],[14,"from","","The `from` macro is a helper for creating `ValidatingEntryType` definitions for use within the entry macro. It is a convenience wrapper around link! that has all the same properties except for the direction which gets set to `LinkDirection::From`.",N,N],[14,"define_zome","","Every Zome must utilize the `define_zome` macro in the main library file in their Zome. The `define_zome` macro has 3 component parts: 1. entries: an array of ValidatingEntryType as returned by using the entry macro 2. genesis: `genesis` is a callback called by Holochain to every Zome implemented within a DNA.     It gets called when a new agent is initializing an instance of the DNA for the first time, and     should return `Ok` or an `Err`, depending on whether the agent can join the network or not. 3. functions: `functions` is divided up into `capabilities`, which specify who can access those functions.     `functions` must be a tree structure where the first children are `capabilities`     and the children of those `capabilities` are actual function definitions. # Examples",N,N],[11,"from","hdk::global_fns","",0,[[["t"]],["t"]]],[11,"into","","",0,[[["self"]],["u"]]],[11,"try_from","","",0,[[["u"]],["result"]]],[11,"borrow","","",0,[[["self"]],["t"]]],[11,"get_type_id","","",0,[[["self"]],["typeid"]]],[11,"try_into","","",0,[[["self"]],["result"]]],[11,"borrow_mut","","",0,[[["self"]],["t"]]],[11,"from","","",1,[[["t"]],["t"]]],[11,"into","","",1,[[["self"]],["u"]]],[11,"to_owned","","",1,[[["self"]],["t"]]],[11,"clone_into","","",1,N],[11,"try_from","","",1,[[["u"]],["result"]]],[11,"borrow","","",1,[[["self"]],["t"]]],[11,"get_type_id","","",1,[[["self"]],["typeid"]]],[11,"try_into","","",1,[[["self"]],["result"]]],[11,"borrow_mut","","",1,[[["self"]],["t"]]],[11,"clone_box","","",1,N],[11,"from","","",2,[[["t"]],["t"]]],[11,"into","","",2,[[["self"]],["u"]]],[11,"to_owned","","",2,[[["self"]],["t"]]],[11,"clone_into","","",2,N],[11,"try_from","","",2,[[["u"]],["result"]]],[11,"borrow","","",2,[[["self"]],["t"]]],[11,"get_type_id","","",2,[[["self"]],["typeid"]]],[11,"try_into","","",2,[[["self"]],["result"]]],[11,"borrow_mut","","",2,[[["self"]],["t"]]],[11,"clone_box","","",2,N],[11,"from","","",3,[[["t"]],["t"]]],[11,"into","","",3,[[["self"]],["u"]]],[11,"to_owned","","",3,[[["self"]],["t"]]],[11,"clone_into","","",3,N],[11,"try_from","","",3,[[["u"]],["result"]]],[11,"borrow","","",3,[[["self"]],["t"]]],[11,"get_type_id","","",3,[[["self"]],["typeid"]]],[11,"try_into","","",3,[[["self"]],["result"]]],[11,"borrow_mut","","",3,[[["self"]],["t"]]],[11,"clone_box","","",3,N],[11,"from","hdk","",4,[[["t"]],["t"]]],[11,"into","","",4,[[["self"]],["u"]]],[11,"to_owned","","",4,[[["self"]],["t"]]],[11,"clone_into","","",4,N],[11,"try_from","","",4,[[["u"]],["result"]]],[11,"borrow","","",4,[[["self"]],["t"]]],[11,"get_type_id","","",4,[[["self"]],["typeid"]]],[11,"try_into","","",4,[[["self"]],["result"]]],[11,"borrow_mut","","",4,[[["self"]],["t"]]],[11,"clone_box","","",4,N],[11,"from","","",5,[[["t"]],["t"]]],[11,"into","","",5,[[["self"]],["u"]]],[11,"to_owned","","",5,[[["self"]],["t"]]],[11,"clone_into","","",5,N],[11,"try_from","","",5,[[["u"]],["result"]]],[11,"borrow","","",5,[[["self"]],["t"]]],[11,"get_type_id","","",5,[[["self"]],["typeid"]]],[11,"try_into","","",5,[[["self"]],["result"]]],[11,"borrow_mut","","",5,[[["self"]],["t"]]],[11,"clone_box","","",5,N],[11,"from","","",6,[[["t"]],["t"]]],[11,"into","","",6,[[["self"]],["u"]]],[11,"to_owned","","",6,[[["self"]],["t"]]],[11,"clone_into","","",6,N],[11,"try_from","","",6,[[["u"]],["result"]]],[11,"borrow","","",6,[[["self"]],["t"]]],[11,"get_type_id","","",6,[[["self"]],["typeid"]]],[11,"try_into","","",6,[[["self"]],["result"]]],[11,"borrow_mut","","",6,[[["self"]],["t"]]],[11,"clone_box","","",6,N],[11,"from","","",7,[[["t"]],["t"]]],[11,"into","","",7,[[["self"]],["u"]]],[11,"to_owned","","",7,[[["self"]],["t"]]],[11,"clone_into","","",7,N],[11,"try_from","","",7,[[["u"]],["result"]]],[11,"borrow","","",7,[[["self"]],["t"]]],[11,"get_type_id","","",7,[[["self"]],["typeid"]]],[11,"try_into","","",7,[[["self"]],["result"]]],[11,"borrow_mut","","",7,[[["self"]],["t"]]],[11,"clone_box","","",7,N],[11,"from","","",8,[[["t"]],["t"]]],[11,"into","","",8,[[["self"]],["u"]]],[11,"to_owned","","",8,[[["self"]],["t"]]],[11,"clone_into","","",8,N],[11,"try_from","","",8,[[["u"]],["result"]]],[11,"borrow","","",8,[[["self"]],["t"]]],[11,"get_type_id","","",8,[[["self"]],["typeid"]]],[11,"try_into","","",8,[[["self"]],["result"]]],[11,"borrow_mut","","",8,[[["self"]],["t"]]],[11,"clone_box","","",8,N],[11,"from","","",9,[[["t"]],["t"]]],[11,"into","","",9,[[["self"]],["u"]]],[11,"to_owned","","",9,[[["self"]],["t"]]],[11,"clone_into","","",9,N],[11,"try_from","","",9,[[["u"]],["result"]]],[11,"borrow","","",9,[[["self"]],["t"]]],[11,"get_type_id","","",9,[[["self"]],["typeid"]]],[11,"try_into","","",9,[[["self"]],["result"]]],[11,"borrow_mut","","",9,[[["self"]],["t"]]],[11,"clone_box","","",9,N],[11,"from","hdk::api","",16,[[["t"]],["t"]]],[11,"into","","",16,[[["self"]],["u"]]],[11,"try_from","","",16,[[["u"]],["result"]]],[11,"borrow","","",16,[[["self"]],["t"]]],[11,"get_type_id","","",16,[[["self"]],["typeid"]]],[11,"try_into","","",16,[[["self"]],["result"]]],[11,"borrow_mut","","",16,[[["self"]],["t"]]],[11,"from","","",17,[[["t"]],["t"]]],[11,"into","","",17,[[["self"]],["u"]]],[11,"try_from","","",17,[[["u"]],["result"]]],[11,"borrow","","",17,[[["self"]],["t"]]],[11,"get_type_id","","",17,[[["self"]],["typeid"]]],[11,"try_into","","",17,[[["self"]],["result"]]],[11,"borrow_mut","","",17,[[["self"]],["t"]]],[11,"from","","",18,[[["t"]],["t"]]],[11,"into","","",18,[[["self"]],["u"]]],[11,"try_from","","",18,[[["u"]],["result"]]],[11,"borrow","","",18,[[["self"]],["t"]]],[11,"get_type_id","","",18,[[["self"]],["typeid"]]],[11,"try_into","","",18,[[["self"]],["result"]]],[11,"borrow_mut","","",18,[[["self"]],["t"]]],[11,"from","","",19,[[["t"]],["t"]]],[11,"into","","",19,[[["self"]],["u"]]],[11,"try_from","","",19,[[["u"]],["result"]]],[11,"borrow","","",19,[[["self"]],["t"]]],[11,"get_type_id","","",19,[[["self"]],["typeid"]]],[11,"try_into","","",19,[[["self"]],["result"]]],[11,"borrow_mut","","",19,[[["self"]],["t"]]],[11,"from","","",20,[[["t"]],["t"]]],[11,"into","","",20,[[["self"]],["u"]]],[11,"try_from","","",20,[[["u"]],["result"]]],[11,"borrow","","",20,[[["self"]],["t"]]],[11,"get_type_id","","",20,[[["self"]],["typeid"]]],[11,"try_into","","",20,[[["self"]],["result"]]],[11,"borrow_mut","","",20,[[["self"]],["t"]]],[11,"from","","",11,[[["t"]],["t"]]],[11,"into","","",11,[[["self"]],["u"]]],[11,"to_owned","","",11,[[["self"]],["t"]]],[11,"clone_into","","",11,N],[11,"try_from","","",11,[[["u"]],["result"]]],[11,"borrow","","",11,[[["self"]],["t"]]],[11,"get_type_id","","",11,[[["self"]],["typeid"]]],[11,"try_into","","",11,[[["self"]],["result"]]],[11,"borrow_mut","","",11,[[["self"]],["t"]]],[11,"equivalent","","",11,[[["self"],["k"]],["bool"]]],[11,"clone_box","","",11,N],[11,"from","","",10,[[["t"]],["t"]]],[11,"into","","",10,[[["self"]],["u"]]],[11,"try_from","","",10,[[["u"]],["result"]]],[11,"borrow","","",10,[[["self"]],["t"]]],[11,"get_type_id","","",10,[[["self"]],["typeid"]]],[11,"try_into","","",10,[[["self"]],["result"]]],[11,"borrow_mut","","",10,[[["self"]],["t"]]],[11,"from","hdk::entry_definition","",12,[[["t"]],["t"]]],[11,"into","","",12,[[["self"]],["u"]]],[11,"try_from","","",12,[[["u"]],["result"]]],[11,"borrow","","",12,[[["self"]],["t"]]],[11,"get_type_id","","",12,[[["self"]],["typeid"]]],[11,"try_into","","",12,[[["self"]],["result"]]],[11,"borrow_mut","","",12,[[["self"]],["t"]]],[11,"from","","",13,[[["t"]],["t"]]],[11,"into","","",13,[[["self"]],["u"]]],[11,"try_from","","",13,[[["u"]],["result"]]],[11,"borrow","","",13,[[["self"]],["t"]]],[11,"get_type_id","","",13,[[["self"]],["typeid"]]],[11,"try_into","","",13,[[["self"]],["result"]]],[11,"borrow_mut","","",13,[[["self"]],["t"]]],[11,"from","hdk::error","",14,[[["t"]],["t"]]],[11,"into","","",14,[[["self"]],["u"]]],[11,"to_string","","",14,[[["self"]],["string"]]],[11,"try_from","","",14,[[["u"]],["result"]]],[11,"borrow","","",14,[[["self"]],["t"]]],[11,"get_type_id","","",14,[[["self"]],["typeid"]]],[11,"try_into","","",14,[[["self"]],["result"]]],[11,"borrow_mut","","",14,[[["self"]],["t"]]],[11,"from","hdk::meta","",15,[[["t"]],["t"]]],[11,"into","","",15,[[["self"]],["u"]]],[11,"try_from","","",15,[[["u"]],["result"]]],[11,"borrow","","",15,[[["self"]],["t"]]],[11,"get_type_id","","",15,[[["self"]],["typeid"]]],[11,"try_into","","",15,[[["self"]],["result"]]],[11,"borrow_mut","","",15,[[["self"]],["t"]]],[11,"clone","hdk","",9,[[["self"]],["linkaction"]]],[11,"clone","","",8,[[["self"]],["entryaction"]]],[11,"clone","","",5,[[["self"]],["validationpackagedefinition"]]],[11,"clone","","",6,[[["self"]],["validationdata"]]],[11,"clone","","",4,[[["self"]],["validationpackage"]]],[11,"clone","","",7,[[["self"]],["entrylifecycle"]]],[11,"default","","",7,[[],["entrylifecycle"]]],[11,"default","","",8,[[],["entryaction"]]],[11,"default","","",4,[[],["validationpackage"]]],[11,"default","","",6,[[],["validationdata"]]],[11,"try_from","","",5,[[["jsonstring"]],["result",["validationpackagedefinition"]]]],[11,"try_from","","",4,[[["jsonstring"]],["result",["validationpackage"]]]],[11,"try_from","","",4,[[["jsonstring"]],["result",["validationpackage"]]]],[11,"try_from","","",5,[[["jsonstring"]],["result",["validationpackagedefinition"]]]],[11,"serialize","","",6,[[["self"],["__s"]],["result"]]],[11,"serialize","","",7,[[["self"],["__s"]],["result"]]],[11,"serialize","","",8,[[["self"],["__s"]],["result"]]],[11,"serialize","","",4,[[["self"],["__s"]],["result"]]],[11,"serialize","","",9,[[["self"],["__s"]],["result"]]],[11,"serialize","","",5,[[["self"],["__s"]],["result"]]],[11,"deserialize","","",8,[[["__d"]],["result",["entryaction"]]]],[11,"deserialize","","",7,[[["__d"]],["result",["entrylifecycle"]]]],[11,"deserialize","","",9,[[["__d"]],["result",["linkaction"]]]],[11,"deserialize","","",6,[[["__d"]],["result",["validationdata"]]]],[11,"deserialize","","",5,[[["__d"]],["result",["validationpackagedefinition"]]]],[11,"deserialize","","",4,[[["__d"]],["result",["validationpackage"]]]],[11,"fmt","","",9,[[["self"],["formatter"]],["result",["error"]]]],[11,"fmt","","",7,[[["self"],["formatter"]],["result",["error"]]]],[11,"fmt","","",5,[[["self"],["formatter"]],["result",["error"]]]],[11,"fmt","","",4,[[["self"],["formatter"]],["result",["error"]]]],[11,"fmt","","",8,[[["self"],["formatter"]],["result",["error"]]]],[11,"fmt","","",6,[[["self"],["formatter"]],["result",["error"]]]],[11,"eq","","",5,[[["self"],["validationpackagedefinition"]],["bool"]]],[11,"ne","","",5,[[["self"],["validationpackagedefinition"]],["bool"]]],[11,"eq","","",4,[[["self"],["validationpackage"]],["bool"]]],[11,"ne","","",4,[[["self"],["validationpackage"]],["bool"]]],[11,"clone","hdk::global_fns","",1,[[["self"]],["linkdirection"]]],[11,"clone","","",2,[[["self"]],["linkvalidationpackageargs"]]],[11,"clone","","",3,[[["self"]],["linkvalidationargs"]]],[11,"serialize","","",2,[[["self"],["__s"]],["result"]]],[11,"serialize","","",1,[[["self"],["__s"]],["result"]]],[11,"serialize","","",0,[[["self"],["__s"]],["result"]]],[11,"serialize","","",3,[[["self"],["__s"]],["result"]]],[11,"deserialize","","",1,[[["__d"]],["result",["linkdirection"]]]],[11,"deserialize","","",3,[[["__d"]],["result",["linkvalidationargs"]]]],[11,"deserialize","","",2,[[["__d"]],["result",["linkvalidationpackageargs"]]]],[11,"deserialize","","",0,[[["__d"]],["result",["entryvalidationargs"]]]],[11,"try_from","","",0,[[["jsonstring"]],["result",["entryvalidationargs"]]]],[11,"try_from","","",3,[[["jsonstring"]],["result",["linkvalidationargs"]]]],[11,"try_from","","",2,[[["jsonstring"]],["result",["linkvalidationpackageargs"]]]],[11,"try_from","","",2,[[["jsonstring"]],["result",["linkvalidationpackageargs"]]]],[11,"try_from","","",3,[[["jsonstring"]],["result",["linkvalidationargs"]]]],[11,"try_from","","",1,[[["jsonstring"]],["result",["linkdirection"]]]],[11,"try_from","","",0,[[["jsonstring"]],["result",["entryvalidationargs"]]]],[11,"try_from","","",1,[[["jsonstring"]],["result",["linkdirection"]]]],[11,"fmt","","",0,[[["self"],["formatter"]],["result",["error"]]]],[11,"fmt","","",1,[[["self"],["formatter"]],["result",["error"]]]],[11,"fmt","","",3,[[["self"],["formatter"]],["result",["error"]]]],[11,"fmt","","",2,[[["self"],["formatter"]],["result",["error"]]]],[11,"eq","","",1,[[["self"],["linkdirection"]],["bool"]]],[11,"cmp","hdk::api","",11,[[["self"],["getentrymask"]],["ordering"]]],[11,"eq","","",11,[[["self"],["getentrymask"]],["bool"]]],[11,"ne","","",11,[[["self"],["getentrymask"]],["bool"]]],[11,"eq","hdk::error","",14,[[["self"],["zomeapierror"]],["bool"]]],[11,"ne","","",14,[[["self"],["zomeapierror"]],["bool"]]],[11,"from","","",14,[[["holochainerror"]],["self"]]],[11,"from","","",14,N],[11,"from","","",14,[[["string"]],["zomeapierror"]]],[11,"from","","",14,[[["ribosomeerrorcode"]],["zomeapierror"]]],[11,"clone","hdk::api","",11,[[["self"]],["getentrymask"]]],[11,"extend","","",11,[[["self"],["t"]]]],[11,"partial_cmp","","",11,[[["self"],["getentrymask"]],["option",["ordering"]]]],[11,"lt","","",11,[[["self"],["getentrymask"]],["bool"]]],[11,"le","","",11,[[["self"],["getentrymask"]],["bool"]]],[11,"gt","","",11,[[["self"],["getentrymask"]],["bool"]]],[11,"ge","","",11,[[["self"],["getentrymask"]],["bool"]]],[11,"default","","",11,[[],["getentrymask"]]],[11,"fmt","","",11,[[["self"],["formatter"]],["result"]]],[11,"fmt","hdk::error","",14,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",14,[[["self"],["formatter"]],["result"]]],[11,"try_from","","",14,[[["jsonstring"]],["result"]]],[11,"try_from","","",14,[[["jsonstring"]],["result"]]],[11,"sub","hdk::api","Returns the set difference of the two sets of flags.",11,[[["self"],["getentrymask"]],["getentrymask"]]],[11,"sub_assign","","Disables all flags enabled in the set.",11,[[["self"],["getentrymask"]]]],[11,"not","","Returns the complement of this set of flags.",11,[[["self"]],["getentrymask"]]],[11,"bitand","","Returns the intersection between the two sets of flags.",11,[[["self"],["getentrymask"]],["getentrymask"]]],[11,"bitor","","Returns the union of the two sets of flags.",11,[[["self"],["getentrymask"]],["getentrymask"]]],[11,"bitxor","","Returns the left flags, but with all the right flags toggled.",11,[[["self"],["getentrymask"]],["getentrymask"]]],[11,"bitand_assign","","Disables all flags disabled in the set.",11,[[["self"],["getentrymask"]]]],[11,"bitor_assign","","Adds the set of flags.",11,[[["self"],["getentrymask"]]]],[11,"bitxor_assign","","Toggles the set of flags.",11,[[["self"],["getentrymask"]]]],[11,"deref","","",16,[[["self"]],["str"]]],[11,"deref","","",17,[[["self"]],["hashstring"]]],[11,"deref","","",18,[[["self"]],["str"]]],[11,"deref","","",19,[[["self"]],["address"]]],[11,"deref","","",20,[[["self"]],["hashstring"]]],[11,"hash","","",11,N],[11,"from_iter","","",11,[[["t"]],["getentrymask"]]],[11,"fmt","","",11,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",11,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",11,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",11,[[["self"],["formatter"]],["result"]]],[11,"description","hdk::error","",14,[[["self"]],["str"]]],[11,"serialize","","",14,[[["self"],["__s"]],["result"]]],[11,"deserialize","","",14,[[["__d"]],["result"]]],[11,"initialize","hdk::api","",16,[[["self"]]]],[11,"initialize","","",17,[[["self"]]]],[11,"initialize","","",18,[[["self"]]]],[11,"initialize","","",19,[[["self"]]]],[11,"initialize","","",20,[[["self"]]]],[11,"only_header","hdk","",4,[[["chainheader"]],["validationpackage"]]]],"paths":[[3,"EntryValidationArgs"],[4,"LinkDirection"],[3,"LinkValidationPackageArgs"],[3,"LinkValidationArgs"],[3,"ValidationPackage"],[4,"ValidationPackageDefinition"],[3,"ValidationData"],[4,"EntryLifecycle"],[4,"EntryAction"],[4,"LinkAction"],[4,"BundleOnClose"],[3,"GetEntryMask"],[3,"ValidatingEntryType"],[3,"ValidatingLinkDefinition"],[4,"ZomeApiError"],[3,"ZomeDefinition"],[3,"DNA_NAME"],[3,"DNA_HASH"],[3,"AGENT_ID_STR"],[3,"AGENT_ADDRESS"],[3,"AGENT_INITIAL_HASH"]]};
searchIndex["holochain_cas_implementations"]={"doc":"CAS Implementations","items":[[0,"cas","holochain_cas_implementations","",N,N],[0,"file","holochain_cas_implementations::cas","",N,N],[3,"FilesystemStorage","holochain_cas_implementations::cas::file","",N,N],[11,"new","","",0,[[["str"]],["result",["filesystemstorage","holochainerror"]]]],[0,"memory","holochain_cas_implementations::cas","",N,N],[3,"MemoryStorage","holochain_cas_implementations::cas::memory","",N,N],[11,"new","","",1,[[],["memorystorage"]]],[0,"eav","holochain_cas_implementations","",N,N],[0,"file","holochain_cas_implementations::eav","",N,N],[3,"EavFileStorage","holochain_cas_implementations::eav::file","",N,N],[5,"add_eav_to_hashset","","",N,[[["direntry"],["hashset"]]]],[11,"new","","",2,[[["string"]],["hcresult",["eavfilestorage"]]]],[0,"memory","holochain_cas_implementations::eav","",N,N],[3,"EavMemoryStorage","holochain_cas_implementations::eav::memory","",N,N],[11,"new","","",3,[[],["eavmemorystorage"]]],[0,"path","holochain_cas_implementations","",N,N],[5,"storage_path","holochain_cas_implementations::path","",N,[[["path"],["str"]],["hcresult",["string"]]]],[5,"create_path_if_not_exists","","",N,[[["str"]],["hcresult"]]],[11,"from","holochain_cas_implementations::cas::file","",0,[[["t"]],["t"]]],[11,"into","","",0,[[["self"]],["u"]]],[11,"to_owned","","",0,[[["self"]],["t"]]],[11,"clone_into","","",0,N],[11,"try_from","","",0,[[["u"]],["result"]]],[11,"borrow","","",0,[[["self"]],["t"]]],[11,"get_type_id","","",0,[[["self"]],["typeid"]]],[11,"try_into","","",0,[[["self"]],["result"]]],[11,"borrow_mut","","",0,[[["self"]],["t"]]],[11,"clone_box","","",0,N],[11,"from","holochain_cas_implementations::cas::memory","",1,[[["t"]],["t"]]],[11,"into","","",1,[[["self"]],["u"]]],[11,"to_owned","","",1,[[["self"]],["t"]]],[11,"clone_into","","",1,N],[11,"try_from","","",1,[[["u"]],["result"]]],[11,"borrow","","",1,[[["self"]],["t"]]],[11,"get_type_id","","",1,[[["self"]],["typeid"]]],[11,"try_into","","",1,[[["self"]],["result"]]],[11,"borrow_mut","","",1,[[["self"]],["t"]]],[11,"clone_box","","",1,N],[11,"from","holochain_cas_implementations::eav::file","",2,[[["t"]],["t"]]],[11,"into","","",2,[[["self"]],["u"]]],[11,"to_owned","","",2,[[["self"]],["t"]]],[11,"clone_into","","",2,N],[11,"try_from","","",2,[[["u"]],["result"]]],[11,"borrow","","",2,[[["self"]],["t"]]],[11,"get_type_id","","",2,[[["self"]],["typeid"]]],[11,"try_into","","",2,[[["self"]],["result"]]],[11,"borrow_mut","","",2,[[["self"]],["t"]]],[11,"clone_box","","",2,N],[11,"from","holochain_cas_implementations::eav::memory","",3,[[["t"]],["t"]]],[11,"into","","",3,[[["self"]],["u"]]],[11,"to_owned","","",3,[[["self"]],["t"]]],[11,"clone_into","","",3,N],[11,"try_from","","",3,[[["u"]],["result"]]],[11,"borrow","","",3,[[["self"]],["t"]]],[11,"get_type_id","","",3,[[["self"]],["typeid"]]],[11,"try_into","","",3,[[["self"]],["result"]]],[11,"borrow_mut","","",3,[[["self"]],["t"]]],[11,"clone_box","","",3,N],[11,"eq","holochain_cas_implementations::cas::file","",0,[[["self"],["filesystemstorage"]],["bool"]]],[11,"eq","holochain_cas_implementations::cas::memory","",1,[[["self"],["memorystorage"]],["bool"]]],[11,"eq","holochain_cas_implementations::eav::file","",2,[[["self"],["eavfilestorage"]],["bool"]]],[11,"eq","holochain_cas_implementations::eav::memory","",3,[[["self"],["eavmemorystorage"]],["bool"]]],[11,"clone","holochain_cas_implementations::cas::file","",0,[[["self"]],["filesystemstorage"]]],[11,"clone","holochain_cas_implementations::cas::memory","",1,[[["self"]],["memorystorage"]]],[11,"clone","holochain_cas_implementations::eav::file","",2,[[["self"]],["eavfilestorage"]]],[11,"clone","holochain_cas_implementations::eav::memory","",3,[[["self"]],["eavmemorystorage"]]],[11,"fmt","holochain_cas_implementations::cas::file","",0,[[["self"],["formatter"]],["result"]]],[11,"fmt","holochain_cas_implementations::cas::memory","",1,[[["self"],["formatter"]],["result"]]],[11,"fmt","holochain_cas_implementations::eav::file","",2,[[["self"],["formatter"]],["result"]]],[11,"fmt","holochain_cas_implementations::eav::memory","",3,[[["self"],["formatter"]],["result"]]],[11,"add","holochain_cas_implementations::cas::file","",0,[[["self"],["addressablecontent"]],["result",["holochainerror"]]]],[11,"contains","","",0,[[["self"],["address"]],["result",["bool","holochainerror"]]]],[11,"fetch","","",0,[[["self"],["address"]],["result",["option","holochainerror"]]]],[11,"get_id","","",0,[[["self"]],["uuid"]]],[11,"add","holochain_cas_implementations::cas::memory","",1,[[["self"],["addressablecontent"]],["result",["holochainerror"]]]],[11,"contains","","",1,[[["self"],["address"]],["result",["bool","holochainerror"]]]],[11,"fetch","","",1,[[["self"],["address"]],["result",["option","holochainerror"]]]],[11,"get_id","","",1,[[["self"]],["uuid"]]],[11,"add_eav","holochain_cas_implementations::eav::file","",2,[[["self"],["entityattributevalue"]],["result",["holochainerror"]]]],[11,"fetch_eav","","",2,[[["self"],["option",["entity"]],["option",["attribute"]],["option",["value"]]],["result",["hashset","holochainerror"]]]],[11,"add_eav","holochain_cas_implementations::eav::memory","",3,[[["self"],["entityattributevalue"]],["result",["holochainerror"]]]],[11,"fetch_eav","","",3,[[["self"],["option",["entity"]],["option",["attribute"]],["option",["value"]]],["result",["hashset","holochainerror"]]]]],"paths":[[3,"FilesystemStorage"],[3,"MemoryStorage"],[3,"EavFileStorage"],[3,"EavMemoryStorage"]]};
searchIndex["holochain_container"]={"doc":"","items":[],"paths":[]};
searchIndex["holochain_container_api"]={"doc":"let file_system = Arc::new(RwLock::new(FilesystemStorage::new(tempdir().unwrap().path().to_str().unwrap()).unwrap())); Arc::new(Mutex::new(SimplePersister::new(file_system.clone()))), file_system.clone(),","items":[[0,"config","holochain_container_api","",N,N],[3,"Configuration","holochain_container_api::config","Main container configuration struct This is the root of the configuration tree / aggregates all other configuration aspects.",N,N],[12,"agents","","List of Agents, this mainly means identities and their keys. Required.",0,N],[12,"dnas","","List of DNAs, for each a path to the DNA file. Required.",0,N],[12,"instances","","List of instances, includes references to an agent and a DNA. Required.",0,N],[12,"interfaces","","List of interfaces any UI can use to access zome functions. Optional.",0,N],[12,"bridges","","List of bridges between instances. Optional.",0,N],[3,"AgentConfiguration","","An agent has a name/ID and is defined by a private key that resides in a file",N,N],[12,"id","","",1,N],[12,"name","","",1,N],[12,"public_address","","",1,N],[12,"key_file","","",1,N],[3,"DNAConfiguration","","A DNA is represented by a DNA file. A hash has to be provided for sanity check.",N,N],[12,"id","","",2,N],[12,"file","","",2,N],[12,"hash","","",2,N],[3,"InstanceConfiguration","","An instance combines a DNA with an agent. Each instance has its own network, storage and logger configuration.",N,N],[12,"id","","",3,N],[12,"dna","","",3,N],[12,"agent","","",3,N],[12,"logger","","",3,N],[12,"storage","","",3,N],[12,"network","","",3,N],[3,"LoggerConfiguration","","There might be different kinds of loggers in the future. Currently there is no logger at all. TODO: make this an enum when it's actually in use",N,N],[12,"logger_type","","",4,N],[12,"file","","",4,N],[3,"InterfaceConfiguration","","Here, interfaces are user facing and make available zome functions to GUIs, browser based web UIs, local native UIs, other local applications and scripts. None is implemented yet, but we will have: * websockets * HTTP REST * Unix domain sockets very soon.",N,N],[12,"id","","",5,N],[12,"driver","","",5,N],[12,"admin","","",5,N],[12,"instances","","",5,N],[3,"InstanceReferenceConfiguration","","",N,N],[12,"id","","",6,N],[3,"Bridge","","A bridge enables an instance to call zome functions of another instance. It is basically an internal interface.",N,N],[12,"caller_id","","ID of the instance that calls the other one. This instance depends on the callee.",7,N],[12,"callee_id","","ID of the instance that exposes capabilities through this bridge. This instance is used by the caller.",7,N],[12,"handle","","The caller's local handle of this bridge and the callee. A caller can have many bridges to other DNAs and those DNAs could by bound dynamically. Callers reference callees by this arbitrary but unique local name.",7,N],[4,"StorageConfiguration","","This configures the Content Addressable Storage (CAS) that the instance uses to store source chain and DHT shard in. There are two storage implementations in cas_implementations so far: * memory * file",N,N],[13,"Memory","","",8,N],[13,"File","","",8,N],[12,"path","holochain_container_api::config::StorageConfiguration","",8,N],[4,"InterfaceDriver","holochain_container_api::config","",N,N],[13,"Websocket","","",9,N],[12,"port","holochain_container_api::config::InterfaceDriver","",9,N],[13,"Http","holochain_container_api::config","",9,N],[12,"port","holochain_container_api::config::InterfaceDriver","",9,N],[13,"DomainSocket","holochain_container_api::config","",9,N],[12,"file","holochain_container_api::config::InterfaceDriver","",9,N],[13,"Custom","holochain_container_api::config","",9,N],[5,"load_configuration","","Use this function to load a `Configuration` from a string.",N,[[["str"]],["hcresult"]]],[11,"check_consistency","","This function basically checks if self is a semantically valid configuration. This mainly means checking for consistency between config structs that reference others.",0,[[["self"]],["result",["string"]]]],[11,"agent_by_id","","Returns the agent configuration with the given ID if present",0,[[["self"],["str"]],["option",["agentconfiguration"]]]],[11,"dna_by_id","","Returns the DNA configuration with the given ID if present",0,[[["self"],["str"]],["option",["dnaconfiguration"]]]],[11,"instance_by_id","","Returns the instance configuration with the given ID if present",0,[[["self"],["str"]],["option",["instanceconfiguration"]]]],[11,"interface_by_id","","Returns the interface configuration with the given ID if present",0,[[["self"],["str"]],["option",["interfaceconfiguration"]]]],[11,"instance_ids","","Returns all defined instance IDs",0,[[["self"]],["vec",["string"]]]],[11,"instance_ids_sorted_by_bridge_dependencies","","This function uses the petgraph crate to model the bridge connections in this config as a graph and then create a topological sorting of the nodes, which are instances. The sorting gets reversed to get those instances first that do NOT depend on others such that this ordering of instances can be used to spawn them and simultaneously create initialize the bridges and be able to assert that any callee already exists (which makes this task much easier).",0,[[["self"]],["result",["vec","holochainerror"]]]],[11,"bridge_dependencies","","",0,[[["self"],["string"]],["vec",["bridge"]]]],[0,"container","holochain_container_api","",N,N],[3,"Container","holochain_container_api::container","Main representation of the container. Holds a `HashMap` of Holochain instances referenced by ID. A primary point in this struct is `load_config(&mut self, config: &Configuration) -> Result<(), String>` which takes a `config::Configuration` struct and tries to instantiate all configured instances. While doing so it has to load DNA files referenced in the configuration. In order to not bind this code to the assumption that there is a filesystem and also enable easier testing, a DnaLoader ()which is a closure that returns a Dna object for a given path string) has to be injected on creation.",N,N],[12,"instances","","",10,N],[7,"DEFAULT_NETWORK_CONFIG","","",N,N],[11,"from_config","","Creates a new instance with the default DnaLoader that actually loads files.",10,[[["configuration"]],["self"]]],[11,"with_signal_channel","","",10,[[["self"],["syncsender",["signal"]]],["self"]]],[11,"config","","",10,[[["self"]],["configuration"]]],[11,"start_all_interfaces","","",10,[[["self"]]]],[11,"start_interface_by_id","","",10,[[["self"],["string"]],["result",["string"]]]],[11,"start_all_instances","","Starts all instances",10,[[["self"]],["result",["holochaininstanceerror"]]]],[11,"stop_all_instances","","Stops all instances",10,[[["self"]],["result",["holochaininstanceerror"]]]],[11,"shutdown","","Stop and clear all instances",10,[[["self"]],["result",["holochaininstanceerror"]]]],[11,"load_config","","Tries to create all instances configured in the given Configuration object. Calls `Configuration::check_consistency()` first and clears `self.instances`. @TODO: clean up the container creation process to prevent loading config before proper setup,        especially regarding the signal handler.        (see https://github.com/holochain/holochain-rust/issues/739)",10,[[["self"]],["result",["string"]]]],[11,"instantiate_from_config","","Creates one specific Holochain instance from a given Configuration, id string and DnaLoader.",10,[[["self"],["string"],["configuration"]],["result",["holochain","string"]]]],[0,"context_builder","holochain_container_api","",N,N],[3,"ContextBuilder","holochain_container_api::context_builder","This type helps building context objects that need to be passed in to Holochain intances.",N,N],[11,"new","","",11,[[],["self"]]],[11,"with_agent","","Sets the agent of the context that gets built.",11,[[["self"],["agentid"]],["self"]]],[11,"with_memory_storage","","Sets all three storages, chain, DHT and EAV storage, to transient memory implementations. Chain and DHT storages get set to the same memory CAS.",11,[[["self"]],["self"]]],[11,"with_file_storage","","Sets all three storages, chain, DHT and EAV storage, to persistent file based implementations. Chain and DHT storages get set to the same file CAS. Returns an error if no file storage could be spawned on the given path.",11,[[["self"],["t"]],["result",["holochainerror"]]]],[11,"with_network_config","","Sets the network config.",11,[[["self"],["jsonstring"]],["self"]]],[11,"with_container_api","","",11,[[["self"],["iohandler"]],["self"]]],[11,"with_logger","","",11,[[["self"],["arc",["mutex"]]],["self"]]],[11,"with_signals","","",11,[[["self"],["signalsender"]],["self"]]],[11,"spawn","","Actually creates the context. Defaults to memory storages, a mock network config and a fake agent called \"alice\". The logger gets set to SimpleLogger. The persister gets set to SimplePersister based on the chain storage.",11,[[["self"]],["context"]]],[0,"error","holochain_container_api","",N,N],[4,"HolochainInstanceError","holochain_container_api::error","",N,N],[13,"InternalFailure","","",12,N],[13,"InstanceNotActiveYet","","",12,N],[13,"InstanceAlreadyActive","","",12,N],[6,"HolochainResult","","",N,N],[0,"holochain","holochain_container_api","`holochain_container_api` is a library for instantiating and using holochain instances that  each run a holochain DNA, DHT and source chain.",N,N],[3,"Holochain","holochain_container_api::holochain","contains a Holochain application instance",N,N],[11,"new","","create a new Holochain instance",13,[[["dna"],["arc",["context"]]],["holochainresult"]]],[11,"load","","",13,[[["string"],["arc",["context"]]],["result",["holochainerror"]]]],[11,"start","","activate the Holochain instance",13,[[["self"]],["result",["holochaininstanceerror"]]]],[11,"stop","","deactivate the Holochain instance",13,[[["self"]],["result",["holochaininstanceerror"]]]],[11,"call","","call a function in a zome",13,[[["self"],["str"],["option",["capabilitycall"]],["str"],["str"]],["holochainresult",["jsonstring"]]]],[11,"active","","checks to see if an instance is active",13,[[["self"]],["bool"]]],[11,"state","","return",13,[[["self"]],["result",["state","holochaininstanceerror"]]]],[0,"interface","holochain_container_api","",N,N],[3,"ContainerApiBuilder","holochain_container_api::interface","ContainerApiBuilder creates IoHandlers that implement RPCs for exposure through interfaces or bridges. This includes zome function calls as well as admin functionality.",N,N],[6,"InterfaceError","","",N,N],[6,"InstanceMap","","",N,N],[8,"DispatchRpc","","",N,N],[10,"handler","","",14,[[["self"]],["iohandler"]]],[8,"Interface","","",N,N],[10,"run","","",15,[[["self"],["iohandler"]],["result",["string"]]]],[11,"new","","",16,[[],["self"]]],[11,"spawn","","Finish the building and retrieve the populated handler",16,[[["self"]],["iohandler"]]],[11,"with_named_instance_config","","Add a InstanceConfig for a custom named instance",16,[[["self"],["string"],["instanceconfiguration"]],["self"]]],[11,"with_instance_configs","","Add a vector of InstanceConfig and regard their ID from the config as name.",16,[[["self"],["vec",["instanceconfiguration"]]],["self"]]],[11,"with_instances","","Add several instances with the names given in the InstanceMap",16,[[["self"],["instancemap"]],["self"]]],[11,"with_named_instance","","Add a single instance and register it under the given name",16,[[["self"],["string"],["arc",["rwlock"]]],["self"]]],[0,"interface_impls","holochain_container_api","",N,N],[0,"websocket","holochain_container_api::interface_impls","",N,N],[3,"WebsocketInterface","holochain_container_api::interface_impls::websocket","",N,N],[11,"new","","",17,[[["u16"]],["self"]]],[11,"from","holochain_container_api::config","",0,[[["t"]],["t"]]],[11,"into","","",0,[[["self"]],["u"]]],[11,"to_owned","","",0,[[["self"]],["t"]]],[11,"clone_into","","",0,N],[11,"try_from","","",0,[[["u"]],["result"]]],[11,"borrow","","",0,[[["self"]],["t"]]],[11,"get_type_id","","",0,[[["self"]],["typeid"]]],[11,"try_into","","",0,[[["self"]],["result"]]],[11,"borrow_mut","","",0,[[["self"]],["t"]]],[11,"clone_box","","",0,N],[11,"from","","",1,[[["t"]],["t"]]],[11,"into","","",1,[[["self"]],["u"]]],[11,"to_owned","","",1,[[["self"]],["t"]]],[11,"clone_into","","",1,N],[11,"try_from","","",1,[[["u"]],["result"]]],[11,"borrow","","",1,[[["self"]],["t"]]],[11,"get_type_id","","",1,[[["self"]],["typeid"]]],[11,"try_into","","",1,[[["self"]],["result"]]],[11,"borrow_mut","","",1,[[["self"]],["t"]]],[11,"clone_box","","",1,N],[11,"from","","",2,[[["t"]],["t"]]],[11,"into","","",2,[[["self"]],["u"]]],[11,"to_owned","","",2,[[["self"]],["t"]]],[11,"clone_into","","",2,N],[11,"try_from","","",2,[[["u"]],["result"]]],[11,"borrow","","",2,[[["self"]],["t"]]],[11,"get_type_id","","",2,[[["self"]],["typeid"]]],[11,"try_into","","",2,[[["self"]],["result"]]],[11,"borrow_mut","","",2,[[["self"]],["t"]]],[11,"clone_box","","",2,N],[11,"from","","",3,[[["t"]],["t"]]],[11,"into","","",3,[[["self"]],["u"]]],[11,"to_owned","","",3,[[["self"]],["t"]]],[11,"clone_into","","",3,N],[11,"try_from","","",3,[[["u"]],["result"]]],[11,"borrow","","",3,[[["self"]],["t"]]],[11,"get_type_id","","",3,[[["self"]],["typeid"]]],[11,"try_into","","",3,[[["self"]],["result"]]],[11,"borrow_mut","","",3,[[["self"]],["t"]]],[11,"clone_box","","",3,N],[11,"from","","",4,[[["t"]],["t"]]],[11,"into","","",4,[[["self"]],["u"]]],[11,"to_owned","","",4,[[["self"]],["t"]]],[11,"clone_into","","",4,N],[11,"try_from","","",4,[[["u"]],["result"]]],[11,"borrow","","",4,[[["self"]],["t"]]],[11,"get_type_id","","",4,[[["self"]],["typeid"]]],[11,"try_into","","",4,[[["self"]],["result"]]],[11,"borrow_mut","","",4,[[["self"]],["t"]]],[11,"clone_box","","",4,N],[11,"from","","",5,[[["t"]],["t"]]],[11,"into","","",5,[[["self"]],["u"]]],[11,"to_owned","","",5,[[["self"]],["t"]]],[11,"clone_into","","",5,N],[11,"try_from","","",5,[[["u"]],["result"]]],[11,"borrow","","",5,[[["self"]],["t"]]],[11,"get_type_id","","",5,[[["self"]],["typeid"]]],[11,"try_into","","",5,[[["self"]],["result"]]],[11,"borrow_mut","","",5,[[["self"]],["t"]]],[11,"clone_box","","",5,N],[11,"from","","",6,[[["t"]],["t"]]],[11,"into","","",6,[[["self"]],["u"]]],[11,"to_owned","","",6,[[["self"]],["t"]]],[11,"clone_into","","",6,N],[11,"try_from","","",6,[[["u"]],["result"]]],[11,"borrow","","",6,[[["self"]],["t"]]],[11,"get_type_id","","",6,[[["self"]],["typeid"]]],[11,"try_into","","",6,[[["self"]],["result"]]],[11,"borrow_mut","","",6,[[["self"]],["t"]]],[11,"clone_box","","",6,N],[11,"from","","",7,[[["t"]],["t"]]],[11,"into","","",7,[[["self"]],["u"]]],[11,"to_owned","","",7,[[["self"]],["t"]]],[11,"clone_into","","",7,N],[11,"try_from","","",7,[[["u"]],["result"]]],[11,"borrow","","",7,[[["self"]],["t"]]],[11,"get_type_id","","",7,[[["self"]],["typeid"]]],[11,"try_into","","",7,[[["self"]],["result"]]],[11,"borrow_mut","","",7,[[["self"]],["t"]]],[11,"clone_box","","",7,N],[11,"from","","",8,[[["t"]],["t"]]],[11,"into","","",8,[[["self"]],["u"]]],[11,"to_owned","","",8,[[["self"]],["t"]]],[11,"clone_into","","",8,N],[11,"try_from","","",8,[[["u"]],["result"]]],[11,"borrow","","",8,[[["self"]],["t"]]],[11,"get_type_id","","",8,[[["self"]],["typeid"]]],[11,"try_into","","",8,[[["self"]],["result"]]],[11,"borrow_mut","","",8,[[["self"]],["t"]]],[11,"clone_box","","",8,N],[11,"from","","",9,[[["t"]],["t"]]],[11,"into","","",9,[[["self"]],["u"]]],[11,"to_owned","","",9,[[["self"]],["t"]]],[11,"clone_into","","",9,N],[11,"try_from","","",9,[[["u"]],["result"]]],[11,"borrow","","",9,[[["self"]],["t"]]],[11,"get_type_id","","",9,[[["self"]],["typeid"]]],[11,"try_into","","",9,[[["self"]],["result"]]],[11,"borrow_mut","","",9,[[["self"]],["t"]]],[11,"clone_box","","",9,N],[11,"from","holochain_container_api::container","",10,[[["t"]],["t"]]],[11,"into","","",10,[[["self"]],["u"]]],[11,"try_from","","",10,[[["u"]],["result"]]],[11,"borrow","","",10,[[["self"]],["t"]]],[11,"get_type_id","","",10,[[["self"]],["typeid"]]],[11,"try_into","","",10,[[["self"]],["result"]]],[11,"borrow_mut","","",10,[[["self"]],["t"]]],[11,"from","holochain_container_api::context_builder","",11,[[["t"]],["t"]]],[11,"into","","",11,[[["self"]],["u"]]],[11,"try_from","","",11,[[["u"]],["result"]]],[11,"borrow","","",11,[[["self"]],["t"]]],[11,"get_type_id","","",11,[[["self"]],["typeid"]]],[11,"try_into","","",11,[[["self"]],["result"]]],[11,"borrow_mut","","",11,[[["self"]],["t"]]],[11,"from","holochain_container_api::error","",12,[[["t"]],["t"]]],[11,"into","","",12,[[["self"]],["u"]]],[11,"to_owned","","",12,[[["self"]],["t"]]],[11,"clone_into","","",12,N],[11,"to_string","","",12,[[["self"]],["string"]]],[11,"try_from","","",12,[[["u"]],["result"]]],[11,"borrow","","",12,[[["self"]],["t"]]],[11,"get_type_id","","",12,[[["self"]],["typeid"]]],[11,"try_into","","",12,[[["self"]],["result"]]],[11,"borrow_mut","","",12,[[["self"]],["t"]]],[11,"clone_box","","",12,N],[11,"as_fail","","",12,[[["self"]],["fail"]]],[11,"from","holochain_container_api::holochain","",13,[[["t"]],["t"]]],[11,"into","","",13,[[["self"]],["u"]]],[11,"try_from","","",13,[[["u"]],["result"]]],[11,"borrow","","",13,[[["self"]],["t"]]],[11,"get_type_id","","",13,[[["self"]],["typeid"]]],[11,"try_into","","",13,[[["self"]],["result"]]],[11,"borrow_mut","","",13,[[["self"]],["t"]]],[11,"from","holochain_container_api::interface","",16,[[["t"]],["t"]]],[11,"into","","",16,[[["self"]],["u"]]],[11,"try_from","","",16,[[["u"]],["result"]]],[11,"borrow","","",16,[[["self"]],["t"]]],[11,"get_type_id","","",16,[[["self"]],["typeid"]]],[11,"try_into","","",16,[[["self"]],["result"]]],[11,"borrow_mut","","",16,[[["self"]],["t"]]],[11,"from","holochain_container_api::interface_impls::websocket","",17,[[["t"]],["t"]]],[11,"into","","",17,[[["self"]],["u"]]],[11,"try_from","","",17,[[["u"]],["result"]]],[11,"borrow","","",17,[[["self"]],["t"]]],[11,"get_type_id","","",17,[[["self"]],["typeid"]]],[11,"try_into","","",17,[[["self"]],["result"]]],[11,"borrow_mut","","",17,[[["self"]],["t"]]],[11,"run","","",17,[[["self"],["iohandler"]],["result",["string"]]]],[11,"eq","holochain_container_api::config","",7,[[["self"],["bridge"]],["bool"]]],[11,"ne","","",7,[[["self"],["bridge"]],["bool"]]],[11,"eq","holochain_container_api::error","",12,[[["self"],["holochaininstanceerror"]],["bool"]]],[11,"ne","","",12,[[["self"],["holochaininstanceerror"]],["bool"]]],[11,"from","","",12,[[["holochainerror"]],["self"]]],[11,"clone","holochain_container_api::config","",0,[[["self"]],["configuration"]]],[11,"clone","","",1,[[["self"]],["agentconfiguration"]]],[11,"clone","","",2,[[["self"]],["dnaconfiguration"]]],[11,"clone","","",3,[[["self"]],["instanceconfiguration"]]],[11,"clone","","",4,[[["self"]],["loggerconfiguration"]]],[11,"clone","","",8,[[["self"]],["storageconfiguration"]]],[11,"clone","","",5,[[["self"]],["interfaceconfiguration"]]],[11,"clone","","",9,[[["self"]],["interfacedriver"]]],[11,"clone","","",6,[[["self"]],["instancereferenceconfiguration"]]],[11,"clone","","",7,[[["self"]],["bridge"]]],[11,"clone","holochain_container_api::error","",12,[[["self"]],["holochaininstanceerror"]]],[11,"default","holochain_container_api::config","",0,[[],["configuration"]]],[11,"default","","",4,[[],["loggerconfiguration"]]],[11,"fmt","","",7,[[["self"],["formatter"]],["result"]]],[11,"fmt","holochain_container_api::error","",12,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",12,[[["self"],["formatter"]],["result"]]],[11,"try_from","holochain_container_api::container","",10,[[["configuration"]],["result"]]],[11,"description","holochain_container_api::error","",12,[[["self"]],["str"]]],[11,"cause","","",12,[[["self"]],["option",["error"]]]],[11,"serialize","holochain_container_api::config","",0,[[["self"],["__s"]],["result"]]],[11,"serialize","","",1,[[["self"],["__s"]],["result"]]],[11,"serialize","","",2,[[["self"],["__s"]],["result"]]],[11,"serialize","","",3,[[["self"],["__s"]],["result"]]],[11,"serialize","","",4,[[["self"],["__s"]],["result"]]],[11,"serialize","","",8,[[["self"],["__s"]],["result"]]],[11,"serialize","","",5,[[["self"],["__s"]],["result"]]],[11,"serialize","","",9,[[["self"],["__s"]],["result"]]],[11,"serialize","","",6,[[["self"],["__s"]],["result"]]],[11,"serialize","","",7,[[["self"],["__s"]],["result"]]],[11,"deserialize","","",0,[[["__d"]],["result"]]],[11,"deserialize","","",1,[[["__d"]],["result"]]],[11,"deserialize","","",2,[[["__d"]],["result"]]],[11,"deserialize","","",3,[[["__d"]],["result"]]],[11,"deserialize","","",4,[[["__d"]],["result"]]],[11,"deserialize","","",8,[[["__d"]],["result"]]],[11,"deserialize","","",5,[[["__d"]],["result"]]],[11,"deserialize","","",9,[[["__d"]],["result"]]],[11,"deserialize","","",6,[[["__d"]],["result"]]],[11,"deserialize","","",7,[[["__d"]],["result"]]]],"paths":[[3,"Configuration"],[3,"AgentConfiguration"],[3,"DNAConfiguration"],[3,"InstanceConfiguration"],[3,"LoggerConfiguration"],[3,"InterfaceConfiguration"],[3,"InstanceReferenceConfiguration"],[3,"Bridge"],[4,"StorageConfiguration"],[4,"InterfaceDriver"],[3,"Container"],[3,"ContextBuilder"],[4,"HolochainInstanceError"],[3,"Holochain"],[8,"DispatchRpc"],[8,"Interface"],[3,"ContainerApiBuilder"],[3,"WebsocketInterface"]]};
searchIndex["holochain_core"]={"doc":"The library implementing the holochain pattern of validation rules + local source chain + DHT","items":[[0,"action","holochain_core","",N,N],[3,"ActionWrapper","holochain_core::action","Wrapper for actions that provides a unique ID The unique ID is needed for state tracking to ensure that we can differentiate between two Action dispatches containing the same value when doing \"time travel debug\". The standard approach is to drop the ActionWrapper into the key of a state history HashMap and use the convenience unwrap_to! macro to extract the action data in a reducer. All reducer functions must accept an ActionWrapper so all dispatchers take an ActionWrapper.",N,N],[3,"DirectMessageData","","Everything the network module needs to know in order to send a direct message.",N,N],[12,"address","","The address of the node to send a message to",0,N],[12,"message","","The message itself",0,N],[12,"msg_id","","A unique message ID that is used to identify the response and attribute it to the right context",0,N],[12,"is_response","","Should be true if we are responding to a previous message with this message. msg_id should then be the same as the in the message that we received.",0,N],[3,"NetworkSettings","","Everything the network needs to initialize",N,N],[12,"config","","JSON config that gets passed to P2pNetwork determines how to connect to the network module.",1,N],[12,"dna_hash","","DNA hash is needed so the network module knows which network to connect us to.",1,N],[12,"agent_id","","The network module needs to know who we are. This is this agent's address.",1,N],[4,"Action","","All Actions for the Holochain Instance Store, according to Redux pattern.",N,N],[13,"Commit","","Writes an entry to the source chain. Does not validate, assumes entry is valid.",2,N],[13,"Hold","","Adds an entry to the local DHT shard. Does not validate, assumes entry is valid.",2,N],[13,"AddLink","","Adds a link to the local DHT shard's meta/EAV storage Does not validate, assumes link is valid.",2,N],[13,"InitNetwork","","Create a network proxy instance from the given NetworkSettings",2,N],[13,"Publish","","Makes the network PUT the given entry to the DHT. Distinguishes between different entry types and does the right thing respectively. (only publish for AppEntryType, publish and publish_meta for links etc)",2,N],[13,"GetEntry","","GetEntry by address",2,N],[13,"UpdateEntry","","",2,N],[13,"RemoveEntry","","",2,N],[13,"GetEntryTimeout","","",2,N],[13,"RespondGet","","Lets the network module respond to a GET request. Triggered from the corresponding workflow after retrieving the requested entry from our local DHT shard.",2,N],[13,"HandleGetResult","","get links from entry address and attribute-name We got a response for our GET request which needs to be added to the state. Triggered from the network handler.",2,N],[13,"SendDirectMessage","","Makes the network module send a direct (node-to-node) message to the address given in DirectMessageData",2,N],[13,"SendDirectMessageTimeout","","Makes the direct message connection with the given ID timeout by adding an Err(HolochainError::Timeout) to NetworkState::custom_direct_message_replys.",2,N],[13,"ResolveDirectConnection","","Makes the network module forget about the direct message connection with the given ID. Triggered when we got an answer to our initial DM.",2,N],[13,"GetValidationPackage","","Makes the network module DM the source of the given entry and prepare for receiveing an answer",2,N],[13,"HandleGetValidationPackage","","Updates the state to hold the response that we got for our previous request for a validation package. Triggered from the network handler when we get the response.",2,N],[13,"HandleCustomSendResponse","","Updates the state to hold the response that we got for our previous custom direct message. /// Triggered from the network handler when we get the response.",2,N],[13,"InitApplication","","initialize an application from a Dna not the same as genesis may call genesis internally",2,N],[13,"ReturnInitializationResult","","return the result of an InitApplication action the result is Some arbitrary string",2,N],[13,"ExecuteZomeFunction","","execute a function in a zome WASM",2,N],[13,"ReturnZomeFunctionResult","","return the result of a zome WASM function call",2,N],[13,"Call","","Execute a zome function call called by another zome function",2,N],[13,"ReturnValidationResult","","A validation result is returned from a local callback execution Key is an unique id of the calling context and the hash of the entry that was validated",2,N],[13,"ReturnValidationPackage","","A validation package was created locally and is reported back to be added to the state",2,N],[6,"AgentReduceFn","","function signature for action handler functions",N,N],[6,"NetworkReduceFn","","",N,N],[6,"NucleusReduceFn","","",N,N],[6,"ReduceFn","","",N,N],[11,"new","","constructor from &Action internal snowflake ID is automatically set",3,[[["action"]],["self"]]],[11,"action","","read only access to action",3,[[["self"]],["action"]]],[11,"id","","read only access to id",3,[[["self"]],["processuniqueid"]]],[0,"agent","holochain_core","",N,N],[5,"find_chain_header","holochain_core::agent","",N,[[["entry"],["arc"]],["option",["chainheader"]]]],[0,"actions","","Agent is the module that handles the users identity and source chain for every Phenotype.",N,N],[0,"commit","holochain_core::agent::actions","",N,N],[3,"CommitFuture","holochain_core::agent::actions::commit","CommitFuture resolves to ActionResponse Tracks the state for a response to its ActionWrapper",N,N],[5,"commit_entry","","Commit Action Creator This is the high-level commit function that wraps the whole commit process and is what should be called from zome api functions and other contexts that don't care about implementation details.",N,N],[0,"update_entry","holochain_core::agent::actions","",N,N],[3,"UpdateEntryFuture","holochain_core::agent::actions::update_entry","RemoveEntryFuture resolves to ActionResponse Tracks the state for a response to its ActionWrapper",N,N],[5,"update_entry","","Update Entry Action Creator",N,[[["arc"],["syncsender"],["address"],["address"]],["updateentryfuture"]]],[0,"chain_store","holochain_core::agent","",N,N],[3,"ChainStore","holochain_core::agent::chain_store","",N,N],[3,"ChainStoreIterator","","",N,N],[3,"ChainStoreTypeIterator","","",N,N],[11,"new","","",4,[[["arc",["rwlock"]]],["self"]]],[11,"content_storage","","",4,[[["self"]],["arc",["rwlock"]]]],[11,"iter","","",4,[[["self"],["option"]],["chainstoreiterator"]]],[11,"iter_type","","",4,[[["self"],["option"],["entrytype"]],["chainstoretypeiterator"]]],[11,"query","","",4,[[["self"],["option"],["entrytype"],["u32"],["u32"]],["vec",["address"]]]],[11,"new","","",5,[[["arc",["rwlock"]],["option",["chainheader"]]],["chainstoreiterator"]]],[11,"new","","",6,[[["arc",["rwlock"]],["option",["chainheader"]]],["chainstoretypeiterator"]]],[0,"state","holochain_core::agent","",N,N],[3,"AgentState","holochain_core::agent::state","The state-slice for the Agent. Holds the agent's source chain and keys.",N,N],[3,"AgentStateSnapshot","","",N,N],[4,"ActionResponse","","the agent's response to an action stored alongside the action in AgentState::actions to provide a state history that observers poll and retrieve",N,N],[13,"Commit","","",7,N],[13,"GetEntry","","",7,N],[13,"GetLinks","","",7,N],[13,"LinkEntries","","",7,N],[5,"create_new_chain_header","","",N,[[["entry"],["arc",["context"]],["option"]],["chainheader"]]],[5,"reduce","","Reduce Agent's state according to provided Action",N,[[["arc",["context"]],["arc",["agentstate"]],["actionwrapper"]],["arc",["agentstate"]]]],[7,"AGENT_SNAPSHOT_ADDRESS","","",N,N],[11,"new","","builds a new, empty AgentState",8,[[["chainstore"]],["agentstate"]]],[11,"new_with_top_chain_header","","",8,[[["chainstore"],["chainheader"]],["agentstate"]]],[11,"actions","","getter for a copy of self.actions uniquely maps action executions to the result of the action",8,[[["self"]],["hashmap",["actionwrapper","actionresponse"]]]],[11,"chain","","",8,[[["self"]],["chainstore"]]],[11,"top_chain_header","","",8,[[["self"]],["option",["chainheader"]]]],[11,"get_agent_address","","",8,[[["self"]],["hcresult",["address"]]]],[11,"get_agent","","",8,N],[11,"get_header_for_entry","","",8,[[["self"],["entry"]],["option",["chainheader"]]]],[11,"new","","",9,[[["chainheader"]],["agentstatesnapshot"]]],[11,"from_json_str","","",9,[[["str"]],["result"]]],[11,"top_chain_header","","",9,[[["self"]],["chainheader"]]],[0,"context","holochain_core","",N,N],[3,"Context","holochain_core::context","Context holds the components that parts of a Holochain instance need in order to operate. This includes components that are injected from the outside like logger and persister but also the store of the instance that gets injected before passing on the context to inner components/reducers.",N,N],[12,"agent_id","","",10,N],[12,"logger","","",10,N],[12,"persister","","",10,N],[12,"action_channel","","",10,N],[12,"observer_channel","","",10,N],[12,"chain_storage","","",10,N],[12,"dht_storage","","",10,N],[12,"eav_storage","","",10,N],[12,"network_config","","",10,N],[12,"container_api","","",10,N],[12,"signal_tx","","",10,N],[5,"get_dna_and_agent","","",N,N],[5,"mock_network_config","","create a test network",N,[[],["jsonstring"]]],[11,"default_channel_buffer_size","","",10,[[],["usize"]]],[11,"new","","",10,[[["agentid"],["arc",["mutex"]],["arc",["mutex"]],["arc",["rwlock"]],["arc",["rwlock"]],["arc",["rwlock"]],["jsonstring"],["option",["arc"]],["option",["signalsender"]]],["self"]]],[11,"new_with_channels","","",10,[[["agentid"],["arc",["mutex"]],["arc",["mutex"]],["option",["syncsender"]],["option",["syncsender"]],["option",["syncsender"]],["arc",["rwlock"]],["arc",["rwlock"]],["jsonstring"]],["result",["context","holochainerror"]]]],[11,"log","","",10,[[["self"],["t"]]]],[11,"set_state","","",10,[[["self"],["arc",["rwlock"]]]]],[11,"state","","",10,[[["self"]],["option",["rwlockreadguard"]]]],[11,"get_dna","","",10,[[["self"]],["option",["dna"]]]],[11,"get_wasm","","",10,[[["self"],["str"]],["option",["dnawasm"]]]],[11,"action_channel","","",10,[[["self"]],["syncsender"]]],[11,"signal_tx","","",10,[[["self"]],["syncsender"]]],[11,"observer_channel","","",10,[[["self"]],["syncsender"]]],[0,"dht","holochain_core","DHT is the module that handles the agent's local shard of data and p2p communications",N,N],[0,"actions","holochain_core::dht","",N,N],[0,"add_link","holochain_core::dht::actions","",N,N],[3,"AddLinkFuture","holochain_core::dht::actions::add_link","",N,N],[5,"add_link","","AddLink Action Creator This action creator dispatches an AddLink action which is consumed by the DHT reducer. Note that this function does not include any validation checks for the link. The DHT reducer does make sure that it only adds links to a base that it has in its local storage and will return an error that the AddLinkFuture resolves to if that is not the case.",N,[[["link"],["arc"]],["addlinkfuture"]]],[0,"hold","holochain_core::dht::actions","",N,N],[3,"HoldEntryFuture","holochain_core::dht::actions::hold","",N,N],[5,"hold_entry","","",N,N],[0,"remove_entry","holochain_core::dht::actions","",N,N],[3,"RemoveEntryFuture","holochain_core::dht::actions::remove_entry","RemoveEntryFuture resolves to ActionResponse Tracks the state for a response to its ActionWrapper",N,N],[5,"remove_entry","","Remove Entry Action Creator",N,[[["arc"],["syncsender"],["address"],["address"]],["removeentryfuture"]]],[0,"dht_reducers","holochain_core::dht","all DHT reducers",N,N],[5,"reduce","holochain_core::dht::dht_reducers","DHT state-slice Reduce entry point. Note: Can't block when dispatching action here because we are inside the reduce's mutex",N,[[["arc",["context"]],["arc",["dhtstore"]],["actionwrapper"]],["arc",["dhtstore"]]]],[0,"dht_store","holochain_core::dht","",N,N],[3,"DhtStore","holochain_core::dht::dht_store","The state-slice for the DHT. Holds the agent's local shard and interacts with the network module",N,N],[11,"new","","",11,[[["arc",["rwlock"]],["arc",["rwlock"]]],["self"]]],[11,"get_links","","",11,[[["self"],["address"],["string"]],["result",["hashset","holochainerror"]]]],[11,"actions","","",11,[[["self"]],["hashmap"]]],[0,"instance","holochain_core","",N,N],[3,"Instance","holochain_core::instance","Object representing a Holochain instance, i.e. a running holochain (DNA + DHT + source-chain) Holds the Event loop and processes it with the redux pattern.",N,N],[3,"Observer","","State Observer that executes a closure everytime the State changes.",N,N],[12,"sensor","","",12,N],[5,"dispatch_action_and_wait","","Send Action to Instance's Event Queue and block until it has been processed.",N,[[["syncsender"],["syncsender"],["actionwrapper"]]]],[5,"dispatch_action_with_observer","","Send Action to the Event Queue and create an Observer for it with the specified closure",N,[[["syncsender"],["syncsender"],["actionwrapper"],["f"]]]],[5,"dispatch_action","","Send Action to the Event Queue",N,[[["syncsender"],["actionwrapper"]]]],[7,"DISPATCH_WITHOUT_CHANNELS","","",N,N],[17,"RECV_DEFAULT_TIMEOUT_MS","","",N,N],[11,"default_channel_buffer_size","","",13,[[],["usize"]]],[11,"action_channel","","",13,[[["self"]],["syncsender"]]],[11,"observer_channel","","",13,[[["self"]],["syncsender"]]],[11,"dispatch","","Stack an Action in the Event Queue",13,[[["self"],["actionwrapper"]]]],[11,"dispatch_and_wait","","Stack an Action in the Event Queue and block until is has been processed.",13,[[["self"],["actionwrapper"]]]],[11,"dispatch_with_observer","","Stack an action in the Event Queue and create an Observer on it with the specified closure",13,[[["self"],["actionwrapper"],["f"]]]],[11,"initialize_context","","",13,[[["self"],["arc",["context"]]],["arc",["context"]]]],[11,"start_action_loop","","Start the Event Loop on a separate thread",13,[[["self"],["arc",["context"]]]]],[11,"new","","Creates a new Instance with no channels set up.",13,[[["arc",["context"]]],["self"]]],[11,"from_state","","",13,[[["state"]],["self"]]],[11,"state","","",13,[[["self"]],["rwlockreadguard",["state"]]]],[0,"logger","holochain_core","This logger is the logger that's attached to each Holochain application which is separate from standard logging via the log crate warn! info! debug! logging that gets emitted globaly from the container.",N,N],[3,"SimpleLogger","holochain_core::logger","",N,N],[8,"Logger","","trait that defines the logging functionality that holochain_core requires",N,N],[10,"log","","",14,[[["self"],["string"]]]],[11,"dump","","",14,[[["self"]],["string"]]],[0,"network","holochain_core","",N,N],[0,"actions","holochain_core::network","",N,N],[4,"ActionResponse","holochain_core::network::actions","",N,N],[13,"Publish","","",15,N],[13,"RespondGet","","",15,N],[0,"custom_send","","",N,N],[3,"SendResponseFuture","holochain_core::network::actions::custom_send","SendResponseFuture waits for a result to show up in NetworkState::custom_direct_message_replys",N,N],[5,"custom_send","","SendDirectMessage Action Creator for custom (=app) messages This triggers the network module to open a synchronous node-to-node connection by sending the given CustomDirectMessage and preparing to receive a response.",N,N],[0,"get_entry","holochain_core::network::actions","",N,N],[3,"GetEntryFuture","holochain_core::network::actions::get_entry","GetEntryFuture resolves to a HcResult. Tracks the state of the network module",N,N],[5,"get_entry","","GetEntry Action Creator This is the network version of get_entry that makes the network module start a look-up process.",N,N],[0,"get_validation_package","holochain_core::network::actions","",N,N],[3,"GetValidationPackageFuture","holochain_core::network::actions::get_validation_package","GetValidationPackageFuture resolves to an Option which would be None if the source responded with None, indicating that it is not the source.",N,N],[5,"get_validation_package","","GetValidationPackage Action Creator This triggers the network module to retrieve the validation package for the entry given by the header.",N,N],[0,"initialize_network","holochain_core::network::actions","",N,N],[3,"InitNetworkFuture","holochain_core::network::actions::initialize_network","",N,N],[5,"initialize_network","","Creates a network proxy object and stores DNA and agent hash in the network state.",N,N],[0,"publish","holochain_core::network::actions","",N,N],[3,"PublishFuture","holochain_core::network::actions::publish","PublishFuture resolves to ActionResponse Tracks the state for a response to its ActionWrapper",N,N],[5,"publish","","Publish Action Creator This is the high-level publish function that wraps the whole publish process and is what should be called from zome api functions and other contexts that don't care about implementation details.",N,N],[0,"direct_message","holochain_core::network","",N,N],[3,"CustomDirectMessage","holochain_core::network::direct_message","This is direct message that got created by the zome code through hdk::send().",N,N],[12,"zome","","We have to track which zome sent the message so we can call the receive callback of the same zome on the receiving side.",16,N],[12,"payload","","The payload that the zome sends. This is a result to enable the receive handler to return an error",16,N],[4,"DirectMessage","","These are the different kinds of (low-level, i.e. non-app) node-to-node messages that can be send between Holochain nodes.",N,N],[13,"Custom","","A custom direct message is something that gets triggered from zome code, i.e. from the app. Receiving such a messages triggers a WASM callback",17,N],[13,"RequestValidationPackage","","This message is used to ask another node (which needs to be the author) for the validation package of a given entry.",17,N],[13,"ValidationPackage","","With this message an author is responding to a RequestValidationPackage message. Option<> since there has to be a way to respond saying \"I can't\"",17,N],[0,"entry_with_header","holochain_core::network","",N,N],[3,"EntryWithHeader","holochain_core::network::entry_with_header","",N,N],[12,"entry","","",18,N],[12,"header","","",18,N],[5,"fetch_entry_with_header","","",N,[[["address"],["arc"]],["result",["entrywithheader","holochainerror"]]]],[11,"new","","",18,[[["entry"],["chainheader"]],["entrywithheader"]]],[0,"handler","holochain_core::network","",N,N],[5,"create_handler","holochain_core::network::handler","Creates the network handler. The returned closure is called by the network thread for every network event that core has to handle.",N,[[["arc"]],["nethandler"]]],[0,"get","","",N,N],[5,"handle_get_dht","holochain_core::network::handler::get","The network has requested a DHT entry from us. Lets try to get it and trigger a response.",N,[[["getdhtdata"],["arc",["context"]]]]],[5,"handle_get_dht_result","","The network comes back with a result to our previous GET request.",N,[[["dhtdata"],["arc",["context"]]]]],[0,"send","holochain_core::network::handler","",N,N],[5,"handle_send","holochain_core::network::handler::send","We got a ProtocolWrapper::SendMessage, this means somebody initiates message roundtrip -> we are being called",N,[[["messagedata"],["arc",["context"]]]]],[5,"handle_send_result","","We got a ProtocolWrapper::HandleSendResult, this means somebody has responded to our message -> we called and this is the answer",N,[[["messagedata"],["arc",["context"]]]]],[0,"store","holochain_core::network::handler","",N,N],[5,"handle_store_dht","holochain_core::network::handler::store","The network requests us to store (i.e. hold) the given entry.",N,[[["dhtdata"],["arc",["context"]]]]],[5,"handle_store_dht_meta","","The network requests us to store meta information (links/CRUD/etc) for an entry that we hold.",N,[[["dhtmetadata"],["arc",["context"]]]]],[0,"reducers","holochain_core::network","",N,N],[5,"reduce","holochain_core::network::reducers","",N,[[["arc",["context"]],["arc",["networkstate"]],["actionwrapper"]],["arc",["networkstate"]]]],[5,"send","","Sends the given ProtocolWrapper over the network using the network proxy instance that lives in the NetworkState.",N,[[["networkstate"],["protocolwrapper"]],["result",["holochainerror"]]]],[5,"send_message","","Sends the given DirectMessage to the node given by to_agent_id. This creates a transient connection as every node-to-node communication follows a request-response pattern. This function therefore logs the open connection (expecting a response) in network_state.direct_message_connections.",N,[[["networkstate"],["address"],["directmessage"]],["result",["holochainerror"]]]],[0,"get_entry","","",N,N],[5,"reduce_get_entry","holochain_core::network::reducers::get_entry","",N,[[["arc",["context"]],["networkstate"],["actionwrapper"]]]],[5,"reduce_get_entry_timeout","","",N,[[["arc",["context"]],["networkstate"],["actionwrapper"]]]],[0,"get_validation_package","holochain_core::network::reducers","",N,N],[5,"reduce_get_validation_package","holochain_core::network::reducers::get_validation_package","",N,[[["arc",["context"]],["networkstate"],["actionwrapper"]]]],[0,"handle_custom_send_response","holochain_core::network::reducers","",N,N],[5,"reduce_handle_custom_send_response","holochain_core::network::reducers::handle_custom_send_response","",N,[[["arc",["context"]],["networkstate"],["actionwrapper"]]]],[0,"handle_get_result","holochain_core::network::reducers","",N,N],[5,"reduce_handle_get_result","holochain_core::network::reducers::handle_get_result","",N,[[["arc",["context"]],["networkstate"],["actionwrapper"]]]],[0,"handle_get_validation_package","holochain_core::network::reducers","",N,N],[5,"reduce_handle_get_validation_package","holochain_core::network::reducers::handle_get_validation_package","",N,[[["arc",["context"]],["networkstate"],["actionwrapper"]]]],[0,"init","holochain_core::network::reducers","",N,N],[5,"reduce_init","holochain_core::network::reducers::init","",N,[[["arc",["context"]],["networkstate"],["actionwrapper"]]]],[0,"publish","holochain_core::network::reducers","",N,N],[5,"reduce_publish","holochain_core::network::reducers::publish","",N,[[["arc",["context"]],["networkstate"],["actionwrapper"]]]],[0,"resolve_direct_connection","holochain_core::network::reducers","",N,N],[5,"reduce_resolve_direct_connection","holochain_core::network::reducers::resolve_direct_connection","",N,[[["arc",["context"]],["networkstate"],["actionwrapper"]]]],[0,"respond_get","holochain_core::network::reducers","",N,N],[5,"reduce_respond_get","holochain_core::network::reducers::respond_get","",N,[[["arc",["context"]],["networkstate"],["actionwrapper"]]]],[0,"send_direct_message","holochain_core::network::reducers","",N,N],[5,"reduce_send_direct_message","holochain_core::network::reducers::send_direct_message","",N,[[["arc",["context"]],["networkstate"],["actionwrapper"]]]],[5,"reduce_send_direct_message_timeout","","",N,[[["arc",["context"]],["networkstate"],["actionwrapper"]]]],[0,"state","holochain_core::network","",N,N],[3,"NetworkState","holochain_core::network::state","",N,N],[12,"actions","","every action and the result of that action",19,N],[12,"network","","",19,N],[12,"dna_hash","","",19,N],[12,"agent_id","","",19,N],[12,"get_entry_with_meta_results","","Here we store the results of GET entry processes. None means that we are still waiting for a result from the network.",19,N],[12,"get_validation_package_results","","Here we store the results of get validation package processes. None means that we are still waiting for a result from the network.",19,N],[12,"direct_message_connections","","This stores every open (= waiting for response) node-to-node messages. Entries get removed when we receive an answer through Action::ResolveDirectConnection.",19,N],[12,"custom_direct_message_replys","","",19,N],[11,"new","","",19,[[],["self"]]],[11,"actions","","",19,[[["self"]],["hashmap",["actionwrapper","actionresponse"]]]],[11,"initialized","","",19,[[["self"]],["result",["holochainerror"]]]],[0,"nucleus","holochain_core","",N,N],[3,"ZomeFnCall","holochain_core::nucleus","Struct holding data for requesting the execution of a Zome function (ExecutionZomeFunction Action)",N,N],[12,"zome_name","","",20,N],[12,"cap","","",20,N],[12,"fn_name","","",20,N],[12,"parameters","","",20,N],[3,"EntrySubmission","","WIP - Struct for holding data when requesting an Entry Validation (ValidateEntry Action)",N,N],[12,"zome_name","","",21,N],[12,"type_name","","",21,N],[12,"entry_content","","",21,N],[3,"ExecuteZomeFnResponse","","",N,N],[5,"call_zome_and_wait_for_result","","Dispatch ExecuteZoneFunction to and block until call has finished.",N,[[["zomefncall"],["syncsender"],["syncsender"]],["result",["jsonstring","holochainerror"]]]],[5,"call_and_wait_for_result","","Dispatch ExecuteZoneFunction to Instance and block until call has finished. for test only?? <-- (apparently not, since it's used in Holochain::call)",N,[[["zomefncall"],["instance"]],["result",["jsonstring","holochainerror"]]]],[5,"reduce","","Reduce state of Nucleus according to action. Note: Can't block when dispatching action here because we are inside the reduce's mutex",N,[[["arc",["context"]],["arc",["nucleusstate"]],["actionwrapper"]],["arc",["nucleusstate"]]]],[0,"actions","","Nucleus is the module that handles DNA, including the Ribosome.",N,N],[0,"build_validation_package","holochain_core::nucleus::actions","",N,N],[3,"ValidationPackageFuture","holochain_core::nucleus::actions::build_validation_package","ValidationPackageFuture resolves to the ValidationPackage or a HolochainError.",N,N],[5,"build_validation_package","","",N,[[["entry"],["arc"]],["validationpackagefuture"]]],[0,"get_entry","holochain_core::nucleus::actions","",N,N],[5,"get_entry_with_meta","holochain_core::nucleus::actions::get_entry","GetEntry Action Creator",N,[[["arc"],["address"]],["result",["option","holochainerror"]]]],[0,"initialize","holochain_core::nucleus::actions","",N,N],[3,"InitializationFuture","holochain_core::nucleus::actions::initialize","InitializationFuture resolves to an Ok(NucleusStatus) or an Err(String). Tracks the nucleus status.",N,N],[5,"initialize_application","","Initialize Application, Action Creator This is the high-level initialization function that wraps the whole process of initializing an instance. It creates both InitApplication and ReturnInitializationResult actions asynchronously.",N,N],[0,"validate","holochain_core::nucleus::actions","",N,N],[3,"ValidationFuture","holochain_core::nucleus::actions::validate","ValidationFuture resolves to an Ok(ActionWrapper) or an Err(error_message:String). Tracks the state for ValidationResults.",N,N],[5,"validate_entry","","ValidateEntry Action Creator This is the high-level validate function that wraps the whole validation process and is what should be called from zome api functions and other contexts that don't care about implementation details.",N,[[["entry"],["validationdata"],["arc"]],["futureobj",["result"]]]],[0,"ribosome","holochain_core::nucleus","The virtual machine that runs DNA written in WASM",N,N],[3,"Runtime","holochain_core::nucleus::ribosome","Object holding data to pass around to invoked Zome API functions",N,N],[12,"memory_manager","","Memory state tracker between ribosome and wasm.",22,N],[12,"context","","Context of Holochain. Required for operating.",22,N],[12,"dna_name","","Name of the DNA that is being hosted.",22,N],[12,"zome_call","","The zome function call that initiated the Ribosome.",22,N],[5,"run_dna","","Executes an exposed zome function in a wasm binary. Multithreaded function panics if wasm binary isn't valid.",N,[[["str"],["arc",["context"]],["vec",["u8"]],["zomefncall"],["option",["vec"]]],["zomefnresult"]]],[0,"api","","Module for ZomeApiFunctions ZomeApiFunctions are the functions provided by the ribosome that are callable by Zomes.",N,N],[4,"ZomeApiFunction","holochain_core::nucleus::ribosome::api","Enumeration of all the Zome Functions known and usable in Zomes. Enumeration can convert to str.",N,N],[13,"MissingNo","","Error index for unimplemented functions",23,N],[13,"Abort","","Abort is a way to receive useful debug info from assemblyscript memory allocators message: mem address in the wasm memory for an error message filename: mem address in the wasm memory for a filename line: line number column: column number",23,N],[13,"Debug","","Zome API send debug information to the log debug(s: String)",23,N],[13,"CommitAppEntry","","Commit an app entry to source chain commit_entry(entry_type: String, entry_value: String) -> Address",23,N],[13,"GetAppEntry","","Get an app entry from source chain by key (header hash) get_entry(address: Address) -> Entry",23,N],[13,"UpdateEntry","","",23,N],[13,"RemoveEntry","","",23,N],[13,"InitGlobals","","Init Zome API Globals hc_init_globals() -> InitGlobalsOutput",23,N],[13,"Call","","Call a zome function in a different capability or zome hc_call(zome_name: String, cap_token: Address, fn_name: String, args: String);",23,N],[13,"LinkEntries","","",23,N],[13,"GetLinks","","",23,N],[13,"Query","","",23,N],[13,"EntryAddress","","Pass an entry to retrieve its address the address algorithm is specific to the entry, typically sha256 but can differ entry_address(entry: Entry) -> Address",23,N],[13,"Send","","",23,N],[0,"call","","",N,N],[5,"invoke_call","holochain_core::nucleus::ribosome::api::call","HcApiFuncIndex::CALL function code args: [0] encoded MemoryAllocation as u32 expected complex argument: {zome_name: String, cap_token: Address, fn_name: String, args: String} args from API call are converted into a ZomeFnCall Launch an Action::Call with newly formed ZomeFnCall Waits for a ZomeFnResult Returns an HcApiReturnCode as I32",N,[[["runtime"],["runtimeargs"]],["zomeapiresult"]]],[5,"validate_call","","",N,[[["arc",["context"]],["nucleusstate"],["zomefncall"]],["result",["dna","holochainerror"]]]],[0,"commit","holochain_core::nucleus::ribosome::api","",N,N],[5,"invoke_commit_app_entry","holochain_core::nucleus::ribosome::api::commit","ZomeApiFunction::CommitAppEntry function code args: [0] encoded MemoryAllocation as u32 Expected complex argument: CommitArgs Returns an HcApiReturnCode as I32",N,[[["runtime"],["runtimeargs"]],["zomeapiresult"]]],[0,"debug","holochain_core::nucleus::ribosome::api","",N,N],[5,"invoke_debug","holochain_core::nucleus::ribosome::api::debug","ZomeApiFunction::Debug function code args: [0] encoded MemoryAllocation as u32 Expecting a string as complex input argument Returns an HcApiReturnCode as I32",N,[[["runtime"],["runtimeargs"]],["zomeapiresult"]]],[0,"entry_address","holochain_core::nucleus::ribosome::api","",N,N],[5,"get_entry_type","holochain_core::nucleus::ribosome::api::entry_address","",N,[[["dna"],["str"]],["result",["entrytype","option"]]]],[5,"invoke_entry_address","","ZomeApiFunction::entry_address function code args: [0] encoded MemoryAllocation as u32 Expected complex argument: entry_type_name and entry_value as JsonString Returns an HcApiReturnCode as I32",N,[[["runtime"],["runtimeargs"]],["zomeapiresult"]]],[0,"get_entry","holochain_core::nucleus::ribosome::api","",N,N],[5,"invoke_get_entry","holochain_core::nucleus::ribosome::api::get_entry","ZomeApiFunction::GetAppEntry function code args: [0] encoded MemoryAllocation as u32 Expected complex argument: GetEntryArgs Returns an HcApiReturnCode as I32",N,[[["runtime"],["runtimeargs"]],["zomeapiresult"]]],[0,"get_links","holochain_core::nucleus::ribosome::api","",N,N],[5,"invoke_get_links","holochain_core::nucleus::ribosome::api::get_links","ZomeApiFunction::GetLinks function code args: [0] encoded MemoryAllocation as u32 Expected complex argument: GetLinksArgs Returns an HcApiReturnCode as I32",N,[[["runtime"],["runtimeargs"]],["zomeapiresult"]]],[0,"init_globals","holochain_core::nucleus::ribosome::api","",N,N],[5,"invoke_init_globals","holochain_core::nucleus::ribosome::api::init_globals","ZomeApiFunction::InitGlobals secret function code args: [0] encoded MemoryAllocation as u32 Not expecting any complex input Returns an HcApiReturnCode as I32",N,[[["runtime"],["runtimeargs"]],["zomeapiresult"]]],[0,"link_entries","holochain_core::nucleus::ribosome::api","",N,N],[5,"invoke_link_entries","holochain_core::nucleus::ribosome::api::link_entries","ZomeApiFunction::LinkEntries function code args: [0] encoded MemoryAllocation as u32 Expected complex argument: LinkEntriesArgs",N,[[["runtime"],["runtimeargs"]],["zomeapiresult"]]],[0,"query","holochain_core::nucleus::ribosome::api","",N,N],[5,"invoke_query","holochain_core::nucleus::ribosome::api::query","ZomeApiFunction::query function code args: [0] encoded MemoryAllocation as u32 Expected complex argument: ? Returns an HcApiReturnCode as I32",N,[[["runtime"],["runtimeargs"]],["zomeapiresult"]]],[0,"remove_entry","holochain_core::nucleus::ribosome::api","",N,N],[5,"invoke_remove_entry","holochain_core::nucleus::ribosome::api::remove_entry","ZomeApiFunction::RemoveEntry function code args: [0] encoded MemoryAllocation as u32 Expected Address argument Returns only a RibosomeReturnCode as I32",N,[[["runtime"],["runtimeargs"]],["zomeapiresult"]]],[0,"send","holochain_core::nucleus::ribosome::api","",N,N],[5,"invoke_send","holochain_core::nucleus::ribosome::api::send","ZomeApiFunction::Send function code args: [0] encoded MemoryAllocation as u32 Expected complex argument: SendArgs Returns an HcApiReturnCode as I32",N,[[["runtime"],["runtimeargs"]],["zomeapiresult"]]],[0,"update_entry","holochain_core::nucleus::ribosome::api","",N,N],[5,"invoke_update_entry","holochain_core::nucleus::ribosome::api::update_entry","ZomeApiFunction::UpdateEntry function code args: [0] encoded MemoryAllocation as u32 Expected complex argument: UpdateEntryArgs Returns an HcApiReturnCode as I32",N,[[["runtime"],["runtimeargs"]],["zomeapiresult"]]],[6,"ZomeApiResult","holochain_core::nucleus::ribosome::api","",N,N],[11,"as_fn","","",23,N],[0,"callback","holochain_core::nucleus::ribosome","Module for ZomeCallbacks ZomeCallbacks are functions in a Zome that are callable by the ribosome.",N,N],[4,"Callback","holochain_core::nucleus::ribosome::callback","Enumeration of all Zome Callbacks known and used by Holochain Enumeration can convert to str",N,N],[13,"MissingNo","","Error index for unimplemented functions",24,N],[13,"Genesis","","MissingNo Capability LifeCycle Capability genesis() -> bool",24,N],[13,"Receive","","Communication Capability receive(from: String, message: String) -> String",24,N],[4,"CallbackParams","","",N,N],[13,"Genesis","","",25,N],[13,"ValidateCommit","","",25,N],[13,"Receive","","",25,N],[4,"CallbackResult","","",N,N],[13,"Pass","","",26,N],[13,"Fail","","",26,N],[13,"NotImplemented","","",26,N],[13,"ValidationPackageDefinition","","",26,N],[13,"ReceiveResult","","",26,N],[5,"call","","",N,[[["arc",["context"]],["str"],["callback"],["callbackparams"]],["callbackresult"]]],[0,"genesis","","",N,N],[5,"genesis","holochain_core::nucleus::ribosome::callback::genesis","",N,[[["arc",["context"]],["str"],["callbackparams"]],["callbackresult"]]],[0,"links_utils","holochain_core::nucleus::ribosome::callback","",N,N],[3,"LinkDefinitionPath","holochain_core::nucleus::ribosome::callback::links_utils","This is a \"path\" in the DNA tree. That uniquely identifies a link definition.",N,N],[12,"zome_name","","",27,N],[12,"entry_type_name","","",27,N],[12,"direction","","",27,N],[12,"tag","","",27,N],[5,"get_link_entries","","Retrieves the base and target entries of the link and returns both.",N,[[["link"],["arc"]],["result",["holochainerror"]]]],[5,"find_link_definition_in_dna","","This function tries to find the link definition for a link given by base type, tag and target type.",N,[[["entrytype"],["string"],["entrytype"],["arc"]],["result",["linkdefinitionpath","holochainerror"]]]],[0,"receive","holochain_core::nucleus::ribosome::callback","",N,N],[5,"receive","holochain_core::nucleus::ribosome::callback::receive","",N,[[["arc",["context"]],["str"],["callbackparams"]],["callbackresult"]]],[0,"validate_entry","holochain_core::nucleus::ribosome::callback","",N,N],[5,"validate_entry","holochain_core::nucleus::ribosome::callback::validate_entry","This function determines and runs the appropriate validation callback for the given entry with the given validation data (which includes the validation package). It returns a CallbackResult which would be * CallbackResult::Pass when the entry is valid * CallbackResult::Fail(message) when the entry is invalid, giving the fail string from the         validation callback * CallbackResult::NotImplemented if a validation callback is not implemented for the given         entry's type.",N,[[["entry"],["validationdata"],["arc",["context"]]],["result",["callbackresult","holochainerror"]]]],[0,"validation_package","holochain_core::nucleus::ribosome::callback","",N,N],[5,"get_validation_package_definition","holochain_core::nucleus::ribosome::callback::validation_package","",N,[[["entry"],["arc",["context"]]],["result",["callbackresult","holochainerror"]]]],[11,"as_fn","holochain_core::nucleus::ribosome::callback","",24,N],[0,"memory","holochain_core::nucleus::ribosome","",N,N],[3,"SinglePageManager","holochain_core::nucleus::ribosome::memory","Struct for managing a WASM Memory Instance as a single page memory stack",N,N],[11,"new","","",28,[[["moduleref"]],["self"]]],[11,"allocate","","Allocate on stack without writing in it",28,[[["self"],["u16"]],["result",["singlepageallocation","ribosomeerrorcode"]]]],[11,"write","","Write data on top of stack",28,N],[11,"read","","Read data somewhere in stack",28,[[["self"],["singlepageallocation"]],["vec",["u8"]]]],[11,"load_json_string_from_args","holochain_core::nucleus::ribosome","Load a JsonString stored in wasm memory. Input RuntimeArgs should only have one input which is the encoded allocation holding the complex data as an utf8 string. Returns the utf8 string.",22,[[["self"],["runtimeargs"]],["jsonstring"]]],[11,"store_as_json_string","","Store anything that implements Into in wasm memory. Note that From for JsonString automatically implements Into Input should be a a json string. Returns a Result suitable to return directly from a zome API function, i.e. an encoded allocation",22,[[["self"],["j"]],["zomeapiresult"]]],[11,"store_result","","",22,[[["self"],["result",["holochainerror"]]],["zomeapiresult"]]],[8,"Defn","","",N,N],[10,"as_str","","return the canonical name of this function definition",29,[[["self"]],["str"]]],[10,"str_to_index","","convert the canonical name of this function to an index",29,[[["str"]],["usize"]]],[10,"from_index","","convert an index to the function definition",29,[[["usize"]],["self"]]],[10,"capability","","",29,[[["self"]],["reservedcapabilitynames"]]],[0,"state","holochain_core::nucleus","",N,N],[3,"NucleusState","holochain_core::nucleus::state","The state-slice for the Nucleus. Holds the dynamic parts of the DNA, i.e. zome calls and validation requests.",N,N],[12,"dna","","",30,N],[12,"status","","",30,N],[12,"zome_calls","","",30,N],[12,"validation_results","","",30,N],[12,"validation_packages","","",30,N],[4,"NucleusStatus","","",N,N],[13,"New","","",31,N],[13,"Initializing","","",31,N],[13,"Initialized","","",31,N],[13,"InitializationFailed","","",31,N],[6,"ValidationResult","","",N,N],[11,"new","","",30,[[],["self"]]],[11,"zome_call_result","","",30,[[["self"],["zomefncall"]],["option",["result"]]]],[11,"has_initialized","","",30,[[["self"]],["bool"]]],[11,"has_initialization_failed","","",30,[[["self"]],["bool"]]],[11,"dna","","",30,[[["self"]],["option",["dna"]]]],[11,"status","","",30,[[["self"]],["nucleusstatus"]]],[6,"ZomeFnResult","holochain_core::nucleus","",N,N],[11,"new","","",20,[[["str"],["option",["capabilitycall"]],["str"],["j"]],["self"]]],[11,"same_fn_as","","",20,[[["self"],["zomefncall"]],["bool"]]],[11,"cap_name","","",20,[[["self"]],["string"]]],[11,"cap_token","","",20,[[["self"]],["address"]]],[11,"new","","",21,[[["s"],["s"],["s"]],["self"]]],[11,"call","","read only access to call",32,[[["self"]],["zomefncall"]]],[11,"result","","read only access to result",32,[[["self"]],["result",["jsonstring","holochainerror"]]]],[0,"persister","holochain_core","",N,N],[3,"SimplePersister","holochain_core::persister","",N,N],[8,"Persister","","trait that defines the persistence functionality that holochain_core requires",N,N],[10,"save","","",33,[[["self"],["state"]],["result",["holochainerror"]]]],[10,"load","","",33,[[["self"],["arc",["context"]]],["result",["option","holochainerror"]]]],[11,"new","","",34,[[["arc",["rwlock"]]],["self"]]],[0,"signal","holochain_core","",N,N],[4,"Signal","holochain_core::signal","",N,N],[13,"Internal","","",35,N],[13,"User","","",35,N],[5,"signal_channel","","",N,N],[5,"_combine_receivers","","Pass on messages from multiple receivers into a single receiver A potentially useful utility, but currently unused.",N,[[["vec",["receiver"]]],["receiver"]]],[6,"SignalSender","","",N,N],[6,"SignalReceiver","","",N,N],[0,"state","holochain_core","",N,N],[3,"State","holochain_core::state","The Store of the Holochain instance Object, according to Redux pattern. It's composed of all sub-module's state slices. To plug in a new module, its state slice needs to be added here.",N,N],[12,"history","","",36,N],[5,"test_store","","",N,[[["arc",["context"]]],["state"]]],[11,"new","","",36,[[["arc",["context"]]],["self"]]],[11,"new_with_agent","","",36,[[["arc",["context"]],["arc",["agentstate"]]],["self"]]],[11,"reduce","","",36,[[["self"],["arc",["context"]],["actionwrapper"]],["self"]]],[11,"nucleus","","",36,[[["self"]],["arc",["nucleusstate"]]]],[11,"agent","","",36,[[["self"]],["arc",["agentstate"]]]],[11,"dht","","",36,[[["self"]],["arc",["dhtstore"]]]],[11,"network","","",36,[[["self"]],["arc",["networkstate"]]]],[11,"try_from_agent_snapshot","","",36,[[["arc",["context"]],["agentstatesnapshot"]],["hcresult",["state"]]]],[0,"workflows","holochain_core","",N,N],[0,"application","holochain_core::workflows","",N,N],[5,"initialize","holochain_core::workflows::application","",N,N],[0,"author_entry","holochain_core::workflows","",N,N],[5,"author_entry","holochain_core::workflows::author_entry","",N,N],[0,"get_entry_result","holochain_core::workflows","",N,N],[5,"get_entry_with_meta_workflow","holochain_core::workflows::get_entry_result","Get Entry workflow",N,N],[5,"get_entry_result_workflow","","Get GetEntryResult workflow",N,N],[0,"handle_custom_direct_message","holochain_core::workflows","",N,N],[5,"handle_custom_direct_message","holochain_core::workflows::handle_custom_direct_message","",N,N],[0,"hold_entry","holochain_core::workflows","",N,N],[5,"hold_entry_workflow","holochain_core::workflows::hold_entry","",N,N],[0,"hold_link","holochain_core::workflows","",N,N],[5,"hold_link_workflow","holochain_core::workflows::hold_link","",N,N],[0,"respond_validation_package_request","holochain_core::workflows","",N,N],[5,"respond_validation_package_request","holochain_core::workflows::respond_validation_package_request","",N,N],[11,"from","holochain_core::action","",3,[[["t"]],["t"]]],[11,"into","","",3,[[["self"]],["u"]]],[11,"to_owned","","",3,[[["self"]],["t"]]],[11,"clone_into","","",3,N],[11,"try_from","","",3,[[["u"]],["result"]]],[11,"borrow","","",3,[[["self"]],["t"]]],[11,"get_type_id","","",3,[[["self"]],["typeid"]]],[11,"try_into","","",3,[[["self"]],["result"]]],[11,"borrow_mut","","",3,[[["self"]],["t"]]],[11,"equivalent","","",3,[[["self"],["k"]],["bool"]]],[11,"clone_box","","",3,N],[11,"from","","",0,[[["t"]],["t"]]],[11,"into","","",0,[[["self"]],["u"]]],[11,"to_owned","","",0,[[["self"]],["t"]]],[11,"clone_into","","",0,N],[11,"try_from","","",0,[[["u"]],["result"]]],[11,"borrow","","",0,[[["self"]],["t"]]],[11,"get_type_id","","",0,[[["self"]],["typeid"]]],[11,"try_into","","",0,[[["self"]],["result"]]],[11,"borrow_mut","","",0,[[["self"]],["t"]]],[11,"clone_box","","",0,N],[11,"from","","",1,[[["t"]],["t"]]],[11,"into","","",1,[[["self"]],["u"]]],[11,"to_owned","","",1,[[["self"]],["t"]]],[11,"clone_into","","",1,N],[11,"try_from","","",1,[[["u"]],["result"]]],[11,"borrow","","",1,[[["self"]],["t"]]],[11,"get_type_id","","",1,[[["self"]],["typeid"]]],[11,"try_into","","",1,[[["self"]],["result"]]],[11,"borrow_mut","","",1,[[["self"]],["t"]]],[11,"clone_box","","",1,N],[11,"from","","",2,[[["t"]],["t"]]],[11,"into","","",2,[[["self"]],["u"]]],[11,"to_owned","","",2,[[["self"]],["t"]]],[11,"clone_into","","",2,N],[11,"try_from","","",2,[[["u"]],["result"]]],[11,"borrow","","",2,[[["self"]],["t"]]],[11,"get_type_id","","",2,[[["self"]],["typeid"]]],[11,"try_into","","",2,[[["self"]],["result"]]],[11,"borrow_mut","","",2,[[["self"]],["t"]]],[11,"clone_box","","",2,N],[11,"from","holochain_core::agent::actions::commit","",37,[[["t"]],["t"]]],[11,"into","","",37,[[["self"]],["u"]]],[11,"try_from","","",37,[[["u"]],["result"]]],[11,"borrow","","",37,[[["self"]],["t"]]],[11,"get_type_id","","",37,[[["self"]],["typeid"]]],[11,"try_into","","",37,[[["self"]],["result"]]],[11,"borrow_mut","","",37,[[["self"]],["t"]]],[11,"try_poll","","",37,[[["pin"],["localwaker"]],["poll"]]],[11,"from","holochain_core::agent::actions::update_entry","",38,[[["t"]],["t"]]],[11,"into","","",38,[[["self"]],["u"]]],[11,"try_from","","",38,[[["u"]],["result"]]],[11,"borrow","","",38,[[["self"]],["t"]]],[11,"get_type_id","","",38,[[["self"]],["typeid"]]],[11,"try_into","","",38,[[["self"]],["result"]]],[11,"borrow_mut","","",38,[[["self"]],["t"]]],[11,"try_poll","","",38,[[["pin"],["localwaker"]],["poll"]]],[11,"from","holochain_core::agent::chain_store","",4,[[["t"]],["t"]]],[11,"into","","",4,[[["self"]],["u"]]],[11,"to_owned","","",4,[[["self"]],["t"]]],[11,"clone_into","","",4,N],[11,"try_from","","",4,[[["u"]],["result"]]],[11,"borrow","","",4,[[["self"]],["t"]]],[11,"get_type_id","","",4,[[["self"]],["typeid"]]],[11,"try_into","","",4,[[["self"]],["result"]]],[11,"borrow_mut","","",4,[[["self"]],["t"]]],[11,"clone_box","","",4,N],[11,"from","","",5,[[["t"]],["t"]]],[11,"into_iter","","",5,[[["self"]],["i"]]],[11,"into","","",5,[[["self"]],["u"]]],[11,"try_from","","",5,[[["u"]],["result"]]],[11,"borrow","","",5,[[["self"]],["t"]]],[11,"get_type_id","","",5,[[["self"]],["typeid"]]],[11,"try_into","","",5,[[["self"]],["result"]]],[11,"borrow_mut","","",5,[[["self"]],["t"]]],[11,"from","","",6,[[["t"]],["t"]]],[11,"into_iter","","",6,[[["self"]],["i"]]],[11,"into","","",6,[[["self"]],["u"]]],[11,"try_from","","",6,[[["u"]],["result"]]],[11,"borrow","","",6,[[["self"]],["t"]]],[11,"get_type_id","","",6,[[["self"]],["typeid"]]],[11,"try_into","","",6,[[["self"]],["result"]]],[11,"borrow_mut","","",6,[[["self"]],["t"]]],[11,"from","holochain_core::agent::state","",8,[[["t"]],["t"]]],[11,"into","","",8,[[["self"]],["u"]]],[11,"to_owned","","",8,[[["self"]],["t"]]],[11,"clone_into","","",8,N],[11,"try_from","","",8,[[["u"]],["result"]]],[11,"borrow","","",8,[[["self"]],["t"]]],[11,"get_type_id","","",8,[[["self"]],["typeid"]]],[11,"try_into","","",8,[[["self"]],["result"]]],[11,"borrow_mut","","",8,[[["self"]],["t"]]],[11,"clone_box","","",8,N],[11,"from","","",9,[[["t"]],["t"]]],[11,"into","","",9,[[["self"]],["u"]]],[11,"to_owned","","",9,[[["self"]],["t"]]],[11,"clone_into","","",9,N],[11,"try_from","","",9,[[["u"]],["result"]]],[11,"borrow","","",9,[[["self"]],["t"]]],[11,"get_type_id","","",9,[[["self"]],["typeid"]]],[11,"try_into","","",9,[[["self"]],["result"]]],[11,"borrow_mut","","",9,[[["self"]],["t"]]],[11,"clone_box","","",9,N],[11,"from","","",7,[[["t"]],["t"]]],[11,"into","","",7,[[["self"]],["u"]]],[11,"to_owned","","",7,[[["self"]],["t"]]],[11,"clone_into","","",7,N],[11,"try_from","","",7,[[["u"]],["result"]]],[11,"borrow","","",7,[[["self"]],["t"]]],[11,"get_type_id","","",7,[[["self"]],["typeid"]]],[11,"try_into","","",7,[[["self"]],["result"]]],[11,"borrow_mut","","",7,[[["self"]],["t"]]],[11,"clone_box","","",7,N],[11,"from","holochain_core::context","",10,[[["t"]],["t"]]],[11,"into","","",10,[[["self"]],["u"]]],[11,"to_owned","","",10,[[["self"]],["t"]]],[11,"clone_into","","",10,N],[11,"try_from","","",10,[[["u"]],["result"]]],[11,"borrow","","",10,[[["self"]],["t"]]],[11,"get_type_id","","",10,[[["self"]],["typeid"]]],[11,"try_into","","",10,[[["self"]],["result"]]],[11,"borrow_mut","","",10,[[["self"]],["t"]]],[11,"clone_box","","",10,N],[11,"from","holochain_core::dht::actions::add_link","",39,[[["t"]],["t"]]],[11,"into","","",39,[[["self"]],["u"]]],[11,"try_from","","",39,[[["u"]],["result"]]],[11,"borrow","","",39,[[["self"]],["t"]]],[11,"get_type_id","","",39,[[["self"]],["typeid"]]],[11,"try_into","","",39,[[["self"]],["result"]]],[11,"borrow_mut","","",39,[[["self"]],["t"]]],[11,"try_poll","","",39,[[["pin"],["localwaker"]],["poll"]]],[11,"from","holochain_core::dht::actions::hold","",40,[[["t"]],["t"]]],[11,"into","","",40,[[["self"]],["u"]]],[11,"try_from","","",40,[[["u"]],["result"]]],[11,"borrow","","",40,[[["self"]],["t"]]],[11,"get_type_id","","",40,[[["self"]],["typeid"]]],[11,"try_into","","",40,[[["self"]],["result"]]],[11,"borrow_mut","","",40,[[["self"]],["t"]]],[11,"try_poll","","",40,[[["pin"],["localwaker"]],["poll"]]],[11,"from","holochain_core::dht::actions::remove_entry","",41,[[["t"]],["t"]]],[11,"into","","",41,[[["self"]],["u"]]],[11,"try_from","","",41,[[["u"]],["result"]]],[11,"borrow","","",41,[[["self"]],["t"]]],[11,"get_type_id","","",41,[[["self"]],["typeid"]]],[11,"try_into","","",41,[[["self"]],["result"]]],[11,"borrow_mut","","",41,[[["self"]],["t"]]],[11,"try_poll","","",41,[[["pin"],["localwaker"]],["poll"]]],[11,"from","holochain_core::dht::dht_store","",11,[[["t"]],["t"]]],[11,"into","","",11,[[["self"]],["u"]]],[11,"to_owned","","",11,[[["self"]],["t"]]],[11,"clone_into","","",11,N],[11,"try_from","","",11,[[["u"]],["result"]]],[11,"borrow","","",11,[[["self"]],["t"]]],[11,"get_type_id","","",11,[[["self"]],["typeid"]]],[11,"try_into","","",11,[[["self"]],["result"]]],[11,"borrow_mut","","",11,[[["self"]],["t"]]],[11,"clone_box","","",11,N],[11,"from","holochain_core::instance","",13,[[["t"]],["t"]]],[11,"into","","",13,[[["self"]],["u"]]],[11,"to_owned","","",13,[[["self"]],["t"]]],[11,"clone_into","","",13,N],[11,"try_from","","",13,[[["u"]],["result"]]],[11,"borrow","","",13,[[["self"]],["t"]]],[11,"get_type_id","","",13,[[["self"]],["typeid"]]],[11,"try_into","","",13,[[["self"]],["result"]]],[11,"borrow_mut","","",13,[[["self"]],["t"]]],[11,"clone_box","","",13,N],[11,"from","","",12,[[["t"]],["t"]]],[11,"into","","",12,[[["self"]],["u"]]],[11,"try_from","","",12,[[["u"]],["result"]]],[11,"borrow","","",12,[[["self"]],["t"]]],[11,"get_type_id","","",12,[[["self"]],["typeid"]]],[11,"try_into","","",12,[[["self"]],["result"]]],[11,"borrow_mut","","",12,[[["self"]],["t"]]],[11,"from","holochain_core::logger","",42,[[["t"]],["t"]]],[11,"into","","",42,[[["self"]],["u"]]],[11,"to_owned","","",42,[[["self"]],["t"]]],[11,"clone_into","","",42,N],[11,"try_from","","",42,[[["u"]],["result"]]],[11,"borrow","","",42,[[["self"]],["t"]]],[11,"get_type_id","","",42,[[["self"]],["typeid"]]],[11,"try_into","","",42,[[["self"]],["result"]]],[11,"borrow_mut","","",42,[[["self"]],["t"]]],[11,"clone_box","","",42,N],[11,"from","holochain_core::network::actions","",15,[[["t"]],["t"]]],[11,"into","","",15,[[["self"]],["u"]]],[11,"to_owned","","",15,[[["self"]],["t"]]],[11,"clone_into","","",15,N],[11,"try_from","","",15,[[["u"]],["result"]]],[11,"borrow","","",15,[[["self"]],["t"]]],[11,"get_type_id","","",15,[[["self"]],["typeid"]]],[11,"try_into","","",15,[[["self"]],["result"]]],[11,"borrow_mut","","",15,[[["self"]],["t"]]],[11,"clone_box","","",15,N],[11,"from","holochain_core::network::actions::custom_send","",43,[[["t"]],["t"]]],[11,"into","","",43,[[["self"]],["u"]]],[11,"try_from","","",43,[[["u"]],["result"]]],[11,"borrow","","",43,[[["self"]],["t"]]],[11,"get_type_id","","",43,[[["self"]],["typeid"]]],[11,"try_into","","",43,[[["self"]],["result"]]],[11,"borrow_mut","","",43,[[["self"]],["t"]]],[11,"try_poll","","",43,[[["pin"],["localwaker"]],["poll"]]],[11,"from","holochain_core::network::actions::get_entry","",44,[[["t"]],["t"]]],[11,"into","","",44,[[["self"]],["u"]]],[11,"try_from","","",44,[[["u"]],["result"]]],[11,"borrow","","",44,[[["self"]],["t"]]],[11,"get_type_id","","",44,[[["self"]],["typeid"]]],[11,"try_into","","",44,[[["self"]],["result"]]],[11,"borrow_mut","","",44,[[["self"]],["t"]]],[11,"try_poll","","",44,[[["pin"],["localwaker"]],["poll"]]],[11,"from","holochain_core::network::actions::get_validation_package","",45,[[["t"]],["t"]]],[11,"into","","",45,[[["self"]],["u"]]],[11,"try_from","","",45,[[["u"]],["result"]]],[11,"borrow","","",45,[[["self"]],["t"]]],[11,"get_type_id","","",45,[[["self"]],["typeid"]]],[11,"try_into","","",45,[[["self"]],["result"]]],[11,"borrow_mut","","",45,[[["self"]],["t"]]],[11,"try_poll","","",45,[[["pin"],["localwaker"]],["poll"]]],[11,"from","holochain_core::network::actions::initialize_network","",46,[[["t"]],["t"]]],[11,"into","","",46,[[["self"]],["u"]]],[11,"try_from","","",46,[[["u"]],["result"]]],[11,"borrow","","",46,[[["self"]],["t"]]],[11,"get_type_id","","",46,[[["self"]],["typeid"]]],[11,"try_into","","",46,[[["self"]],["result"]]],[11,"borrow_mut","","",46,[[["self"]],["t"]]],[11,"try_poll","","",46,[[["pin"],["localwaker"]],["poll"]]],[11,"from","holochain_core::network::actions::publish","",47,[[["t"]],["t"]]],[11,"into","","",47,[[["self"]],["u"]]],[11,"try_from","","",47,[[["u"]],["result"]]],[11,"borrow","","",47,[[["self"]],["t"]]],[11,"get_type_id","","",47,[[["self"]],["typeid"]]],[11,"try_into","","",47,[[["self"]],["result"]]],[11,"borrow_mut","","",47,[[["self"]],["t"]]],[11,"try_poll","","",47,[[["pin"],["localwaker"]],["poll"]]],[11,"from","holochain_core::network::direct_message","",16,[[["t"]],["t"]]],[11,"into","","",16,[[["self"]],["u"]]],[11,"to_owned","","",16,[[["self"]],["t"]]],[11,"clone_into","","",16,N],[11,"try_from","","",16,[[["u"]],["result"]]],[11,"borrow","","",16,[[["self"]],["t"]]],[11,"get_type_id","","",16,[[["self"]],["typeid"]]],[11,"try_into","","",16,[[["self"]],["result"]]],[11,"borrow_mut","","",16,[[["self"]],["t"]]],[11,"clone_box","","",16,N],[11,"from","","",17,[[["t"]],["t"]]],[11,"into","","",17,[[["self"]],["u"]]],[11,"to_owned","","",17,[[["self"]],["t"]]],[11,"clone_into","","",17,N],[11,"try_from","","",17,[[["u"]],["result"]]],[11,"borrow","","",17,[[["self"]],["t"]]],[11,"get_type_id","","",17,[[["self"]],["typeid"]]],[11,"try_into","","",17,[[["self"]],["result"]]],[11,"borrow_mut","","",17,[[["self"]],["t"]]],[11,"clone_box","","",17,N],[11,"from","holochain_core::network::entry_with_header","",18,[[["t"]],["t"]]],[11,"into","","",18,[[["self"]],["u"]]],[11,"try_from","","",18,[[["u"]],["result"]]],[11,"borrow","","",18,[[["self"]],["t"]]],[11,"get_type_id","","",18,[[["self"]],["typeid"]]],[11,"try_into","","",18,[[["self"]],["result"]]],[11,"borrow_mut","","",18,[[["self"]],["t"]]],[11,"from","holochain_core::network::state","",19,[[["t"]],["t"]]],[11,"into","","",19,[[["self"]],["u"]]],[11,"to_owned","","",19,[[["self"]],["t"]]],[11,"clone_into","","",19,N],[11,"try_from","","",19,[[["u"]],["result"]]],[11,"borrow","","",19,[[["self"]],["t"]]],[11,"get_type_id","","",19,[[["self"]],["typeid"]]],[11,"try_into","","",19,[[["self"]],["result"]]],[11,"borrow_mut","","",19,[[["self"]],["t"]]],[11,"clone_box","","",19,N],[11,"from","holochain_core::nucleus","",20,[[["t"]],["t"]]],[11,"into","","",20,[[["self"]],["u"]]],[11,"to_owned","","",20,[[["self"]],["t"]]],[11,"clone_into","","",20,N],[11,"try_from","","",20,[[["u"]],["result"]]],[11,"borrow","","",20,[[["self"]],["t"]]],[11,"get_type_id","","",20,[[["self"]],["typeid"]]],[11,"try_into","","",20,[[["self"]],["result"]]],[11,"borrow_mut","","",20,[[["self"]],["t"]]],[11,"equivalent","","",20,[[["self"],["k"]],["bool"]]],[11,"clone_box","","",20,N],[11,"from","","",21,[[["t"]],["t"]]],[11,"into","","",21,[[["self"]],["u"]]],[11,"to_owned","","",21,[[["self"]],["t"]]],[11,"clone_into","","",21,N],[11,"try_from","","",21,[[["u"]],["result"]]],[11,"borrow","","",21,[[["self"]],["t"]]],[11,"get_type_id","","",21,[[["self"]],["typeid"]]],[11,"try_into","","",21,[[["self"]],["result"]]],[11,"borrow_mut","","",21,[[["self"]],["t"]]],[11,"equivalent","","",21,[[["self"],["k"]],["bool"]]],[11,"clone_box","","",21,N],[11,"from","","",32,[[["t"]],["t"]]],[11,"into","","",32,[[["self"]],["u"]]],[11,"to_owned","","",32,[[["self"]],["t"]]],[11,"clone_into","","",32,N],[11,"try_from","","",32,[[["u"]],["result"]]],[11,"borrow","","",32,[[["self"]],["t"]]],[11,"get_type_id","","",32,[[["self"]],["typeid"]]],[11,"try_into","","",32,[[["self"]],["result"]]],[11,"borrow_mut","","",32,[[["self"]],["t"]]],[11,"clone_box","","",32,N],[11,"from","holochain_core::nucleus::actions::build_validation_package","",48,[[["t"]],["t"]]],[11,"into","","",48,[[["self"]],["u"]]],[11,"try_from","","",48,[[["u"]],["result"]]],[11,"borrow","","",48,[[["self"]],["t"]]],[11,"get_type_id","","",48,[[["self"]],["typeid"]]],[11,"try_into","","",48,[[["self"]],["result"]]],[11,"borrow_mut","","",48,[[["self"]],["t"]]],[11,"try_poll","","",48,[[["pin"],["localwaker"]],["poll"]]],[11,"from","holochain_core::nucleus::actions::initialize","",49,[[["t"]],["t"]]],[11,"into","","",49,[[["self"]],["u"]]],[11,"try_from","","",49,[[["u"]],["result"]]],[11,"borrow","","",49,[[["self"]],["t"]]],[11,"get_type_id","","",49,[[["self"]],["typeid"]]],[11,"try_into","","",49,[[["self"]],["result"]]],[11,"borrow_mut","","",49,[[["self"]],["t"]]],[11,"try_poll","","",49,[[["pin"],["localwaker"]],["poll"]]],[11,"from","holochain_core::nucleus::actions::validate","",50,[[["t"]],["t"]]],[11,"into","","",50,[[["self"]],["u"]]],[11,"try_from","","",50,[[["u"]],["result"]]],[11,"borrow","","",50,[[["self"]],["t"]]],[11,"get_type_id","","",50,[[["self"]],["typeid"]]],[11,"try_into","","",50,[[["self"]],["result"]]],[11,"borrow_mut","","",50,[[["self"]],["t"]]],[11,"try_poll","","",50,[[["pin"],["localwaker"]],["poll"]]],[11,"from","holochain_core::nucleus::ribosome","",22,[[["t"]],["t"]]],[11,"into","","",22,[[["self"]],["u"]]],[11,"to_owned","","",22,[[["self"]],["t"]]],[11,"clone_into","","",22,N],[11,"try_from","","",22,[[["u"]],["result"]]],[11,"borrow","","",22,[[["self"]],["t"]]],[11,"get_type_id","","",22,[[["self"]],["typeid"]]],[11,"try_into","","",22,[[["self"]],["result"]]],[11,"borrow_mut","","",22,[[["self"]],["t"]]],[11,"clone_box","","",22,N],[11,"from","holochain_core::nucleus::ribosome::api","",23,[[["t"]],["t"]]],[11,"into","","",23,[[["self"]],["u"]]],[11,"try_from","","",23,[[["u"]],["result"]]],[11,"borrow","","",23,[[["self"]],["t"]]],[11,"get_type_id","","",23,[[["self"]],["typeid"]]],[11,"try_into","","",23,[[["self"]],["result"]]],[11,"borrow_mut","","",23,[[["self"]],["t"]]],[11,"equivalent","","",23,[[["self"],["k"]],["bool"]]],[11,"from","holochain_core::nucleus::ribosome::callback","",24,[[["t"]],["t"]]],[11,"into","","",24,[[["self"]],["u"]]],[11,"try_from","","",24,[[["u"]],["result"]]],[11,"borrow","","",24,[[["self"]],["t"]]],[11,"get_type_id","","",24,[[["self"]],["typeid"]]],[11,"try_into","","",24,[[["self"]],["result"]]],[11,"borrow_mut","","",24,[[["self"]],["t"]]],[11,"from","","",25,[[["t"]],["t"]]],[11,"into","","",25,[[["self"]],["u"]]],[11,"to_string","","",25,[[["self"]],["string"]]],[11,"try_from","","",25,[[["u"]],["result"]]],[11,"borrow","","",25,[[["self"]],["t"]]],[11,"get_type_id","","",25,[[["self"]],["typeid"]]],[11,"try_into","","",25,[[["self"]],["result"]]],[11,"borrow_mut","","",25,[[["self"]],["t"]]],[11,"from","","",26,[[["t"]],["t"]]],[11,"into","","",26,[[["self"]],["u"]]],[11,"to_owned","","",26,[[["self"]],["t"]]],[11,"clone_into","","",26,N],[11,"try_from","","",26,[[["u"]],["result"]]],[11,"borrow","","",26,[[["self"]],["t"]]],[11,"get_type_id","","",26,[[["self"]],["typeid"]]],[11,"try_into","","",26,[[["self"]],["result"]]],[11,"borrow_mut","","",26,[[["self"]],["t"]]],[11,"clone_box","","",26,N],[11,"from","holochain_core::nucleus::ribosome::callback::links_utils","",27,[[["t"]],["t"]]],[11,"into","","",27,[[["self"]],["u"]]],[11,"try_from","","",27,[[["u"]],["result"]]],[11,"borrow","","",27,[[["self"]],["t"]]],[11,"get_type_id","","",27,[[["self"]],["typeid"]]],[11,"try_into","","",27,[[["self"]],["result"]]],[11,"borrow_mut","","",27,[[["self"]],["t"]]],[11,"from","holochain_core::nucleus::ribosome::memory","",28,[[["t"]],["t"]]],[11,"into","","",28,[[["self"]],["u"]]],[11,"to_owned","","",28,[[["self"]],["t"]]],[11,"clone_into","","",28,N],[11,"try_from","","",28,[[["u"]],["result"]]],[11,"borrow","","",28,[[["self"]],["t"]]],[11,"get_type_id","","",28,[[["self"]],["typeid"]]],[11,"try_into","","",28,[[["self"]],["result"]]],[11,"borrow_mut","","",28,[[["self"]],["t"]]],[11,"clone_box","","",28,N],[11,"from","holochain_core::nucleus::state","",30,[[["t"]],["t"]]],[11,"into","","",30,[[["self"]],["u"]]],[11,"to_owned","","",30,[[["self"]],["t"]]],[11,"clone_into","","",30,N],[11,"try_from","","",30,[[["u"]],["result"]]],[11,"borrow","","",30,[[["self"]],["t"]]],[11,"get_type_id","","",30,[[["self"]],["typeid"]]],[11,"try_into","","",30,[[["self"]],["result"]]],[11,"borrow_mut","","",30,[[["self"]],["t"]]],[11,"clone_box","","",30,N],[11,"from","","",31,[[["t"]],["t"]]],[11,"into","","",31,[[["self"]],["u"]]],[11,"to_owned","","",31,[[["self"]],["t"]]],[11,"clone_into","","",31,N],[11,"try_from","","",31,[[["u"]],["result"]]],[11,"borrow","","",31,[[["self"]],["t"]]],[11,"get_type_id","","",31,[[["self"]],["typeid"]]],[11,"try_into","","",31,[[["self"]],["result"]]],[11,"borrow_mut","","",31,[[["self"]],["t"]]],[11,"clone_box","","",31,N],[11,"from","holochain_core::persister","",34,[[["t"]],["t"]]],[11,"into","","",34,[[["self"]],["u"]]],[11,"to_owned","","",34,[[["self"]],["t"]]],[11,"clone_into","","",34,N],[11,"try_from","","",34,[[["u"]],["result"]]],[11,"borrow","","",34,[[["self"]],["t"]]],[11,"get_type_id","","",34,[[["self"]],["typeid"]]],[11,"try_into","","",34,[[["self"]],["result"]]],[11,"borrow_mut","","",34,[[["self"]],["t"]]],[11,"clone_box","","",34,N],[11,"from","holochain_core::signal","",35,[[["t"]],["t"]]],[11,"into","","",35,[[["self"]],["u"]]],[11,"try_from","","",35,[[["u"]],["result"]]],[11,"borrow","","",35,[[["self"]],["t"]]],[11,"get_type_id","","",35,[[["self"]],["typeid"]]],[11,"try_into","","",35,[[["self"]],["result"]]],[11,"borrow_mut","","",35,[[["self"]],["t"]]],[11,"from","holochain_core::state","",36,[[["t"]],["t"]]],[11,"into","","",36,[[["self"]],["u"]]],[11,"to_owned","","",36,[[["self"]],["t"]]],[11,"clone_into","","",36,N],[11,"try_from","","",36,[[["u"]],["result"]]],[11,"borrow","","",36,[[["self"]],["t"]]],[11,"get_type_id","","",36,[[["self"]],["typeid"]]],[11,"try_into","","",36,[[["self"]],["result"]]],[11,"borrow_mut","","",36,[[["self"]],["t"]]],[11,"clone_box","","",36,N],[11,"log","holochain_core::logger","",42,[[["self"],["string"]]]],[11,"as_str","holochain_core::nucleus::ribosome::api","",23,[[["self"]],["str"]]],[11,"str_to_index","","",23,[[["str"]],["usize"]]],[11,"from_index","","",23,[[["usize"]],["self"]]],[11,"capability","","",23,[[["self"]],["reservedcapabilitynames"]]],[11,"as_str","holochain_core::nucleus::ribosome::callback","",24,[[["self"]],["str"]]],[11,"str_to_index","","",24,[[["str"]],["usize"]]],[11,"from_index","","",24,[[["usize"]],["self"]]],[11,"capability","","",24,[[["self"]],["reservedcapabilitynames"]]],[11,"save","holochain_core::persister","",34,[[["self"],["state"]],["result",["holochainerror"]]]],[11,"load","","",34,[[["self"],["arc",["context"]]],["result",["option","holochainerror"]]]],[11,"eq","holochain_core::action","",3,[[["self"],["actionwrapper"]],["bool"]]],[11,"eq","","",2,[[["self"],["action"]],["bool"]]],[11,"ne","","",2,[[["self"],["action"]],["bool"]]],[11,"eq","","",0,[[["self"],["directmessagedata"]],["bool"]]],[11,"ne","","",0,[[["self"],["directmessagedata"]],["bool"]]],[11,"eq","","",1,[[["self"],["networksettings"]],["bool"]]],[11,"ne","","",1,[[["self"],["networksettings"]],["bool"]]],[11,"eq","holochain_core::agent::chain_store","",4,[[["self"],["chainstore"]],["bool"]]],[11,"eq","holochain_core::agent::state","",8,[[["self"],["agentstate"]],["bool"]]],[11,"ne","","",8,[[["self"],["agentstate"]],["bool"]]],[11,"eq","","",7,[[["self"],["actionresponse"]],["bool"]]],[11,"ne","","",7,[[["self"],["actionresponse"]],["bool"]]],[11,"eq","holochain_core::dht::dht_store","",11,[[["self"],["dhtstore"]],["bool"]]],[11,"eq","holochain_core::network::direct_message","",16,[[["self"],["customdirectmessage"]],["bool"]]],[11,"ne","","",16,[[["self"],["customdirectmessage"]],["bool"]]],[11,"eq","","",17,[[["self"],["directmessage"]],["bool"]]],[11,"ne","","",17,[[["self"],["directmessage"]],["bool"]]],[11,"eq","holochain_core::network::state","",19,[[["self"],["networkstate"]],["bool"]]],[11,"eq","holochain_core::nucleus::ribosome::api","",23,[[["self"],["zomeapifunction"]],["bool"]]],[11,"eq","holochain_core::nucleus::ribosome::callback","",24,[[["self"],["callback"]],["bool"]]],[11,"eq","","",26,[[["self"],["callbackresult"]],["bool"]]],[11,"ne","","",26,[[["self"],["callbackresult"]],["bool"]]],[11,"eq","holochain_core::nucleus::state","",31,[[["self"],["nucleusstatus"]],["bool"]]],[11,"ne","","",31,[[["self"],["nucleusstatus"]],["bool"]]],[11,"eq","","",30,[[["self"],["nucleusstate"]],["bool"]]],[11,"ne","","",30,[[["self"],["nucleusstate"]],["bool"]]],[11,"eq","holochain_core::nucleus","",20,[[["self"],["zomefncall"]],["bool"]]],[11,"ne","","",20,[[["self"],["zomefncall"]],["bool"]]],[11,"eq","","",21,[[["self"],["entrysubmission"]],["bool"]]],[11,"ne","","",21,[[["self"],["entrysubmission"]],["bool"]]],[11,"eq","","",32,[[["self"],["executezomefnresponse"]],["bool"]]],[11,"ne","","",32,[[["self"],["executezomefnresponse"]],["bool"]]],[11,"eq","holochain_core::persister","",34,[[["self"],["simplepersister"]],["bool"]]],[11,"eq","holochain_core::state","",36,[[["self"],["state"]],["bool"]]],[11,"ne","","",36,[[["self"],["state"]],["bool"]]],[11,"from","holochain_core::nucleus::ribosome::callback","",26,[[["jsonstring"]],["callbackresult"]]],[11,"from","","",26,[[["ribosomereturncode"]],["callbackresult"]]],[11,"clone","holochain_core::action","",3,[[["self"]],["actionwrapper"]]],[11,"clone","","",2,[[["self"]],["action"]]],[11,"clone","","",0,[[["self"]],["directmessagedata"]]],[11,"clone","","",1,[[["self"]],["networksettings"]]],[11,"clone","holochain_core::agent::chain_store","",4,[[["self"]],["chainstore"]]],[11,"clone","holochain_core::agent::state","",8,[[["self"]],["agentstate"]]],[11,"clone","","",9,[[["self"]],["agentstatesnapshot"]]],[11,"clone","","",7,[[["self"]],["actionresponse"]]],[11,"clone","holochain_core::context","",10,[[["self"]],["context"]]],[11,"clone","holochain_core::dht::dht_store","",11,[[["self"]],["dhtstore"]]],[11,"clone","holochain_core::instance","",13,[[["self"]],["instance"]]],[11,"clone","holochain_core::logger","",42,[[["self"]],["simplelogger"]]],[11,"clone","holochain_core::network::actions","",15,[[["self"]],["actionresponse"]]],[11,"clone","holochain_core::network::direct_message","",16,[[["self"]],["customdirectmessage"]]],[11,"clone","","",17,[[["self"]],["directmessage"]]],[11,"clone","holochain_core::network::state","",19,[[["self"]],["networkstate"]]],[11,"clone","holochain_core::nucleus::ribosome::callback","",26,[[["self"]],["callbackresult"]]],[11,"clone","holochain_core::nucleus::ribosome::memory","",28,[[["self"]],["singlepagemanager"]]],[11,"clone","holochain_core::nucleus::ribosome","",22,[[["self"]],["runtime"]]],[11,"clone","holochain_core::nucleus::state","",31,[[["self"]],["nucleusstatus"]]],[11,"clone","","",30,[[["self"]],["nucleusstate"]]],[11,"clone","holochain_core::nucleus","",20,[[["self"]],["zomefncall"]]],[11,"clone","","",21,[[["self"]],["entrysubmission"]]],[11,"clone","","",32,[[["self"]],["executezomefnresponse"]]],[11,"clone","holochain_core::persister","",34,[[["self"]],["simplepersister"]]],[11,"clone","holochain_core::state","",36,[[["self"]],["state"]]],[11,"next","holochain_core::agent::chain_store","May panic if there is an underlying error in the table",5,[[["self"]],["option",["chainheader"]]]],[11,"next","","May panic if there is an underlying error in the table",6,[[["self"]],["option",["chainheader"]]]],[11,"to_string","holochain_core::nucleus::ribosome::callback","",25,[[["self"]],["string"]]],[11,"default","holochain_core::nucleus::state","",31,[[],["self"]]],[11,"default","","",30,[[],["nucleusstate"]]],[11,"fmt","holochain_core::action","",3,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",2,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",0,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",1,[[["self"],["formatter"]],["result"]]],[11,"fmt","holochain_core::agent::chain_store","",4,[[["self"],["formatter"]],["result"]]],[11,"fmt","holochain_core::agent::state","",8,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",9,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",7,[[["self"],["formatter"]],["result"]]],[11,"fmt","holochain_core::dht::dht_store","",11,[[["self"],["formatter"]],["result"]]],[11,"fmt","holochain_core::network::actions","",15,[[["self"],["formatter"]],["result"]]],[11,"fmt","holochain_core::network::direct_message","",16,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",17,[[["self"],["formatter"]],["result"]]],[11,"fmt","holochain_core::network::state","",19,[[["self"],["formatter"]],["result"]]],[11,"fmt","holochain_core::nucleus::ribosome::api","",23,[[["self"],["formatter"]],["result"]]],[11,"fmt","holochain_core::nucleus::ribosome::callback","",24,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",25,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",26,[[["self"],["formatter"]],["result"]]],[11,"fmt","holochain_core::nucleus::ribosome::memory","",28,[[["self"],["formatter"]],["result"]]],[11,"fmt","holochain_core::nucleus::state","",31,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",30,[[["self"],["formatter"]],["result"]]],[11,"fmt","holochain_core::nucleus","",20,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",21,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",32,[[["self"],["formatter"]],["result"]]],[11,"fmt","holochain_core::signal","",35,[[["self"],["formatter"]],["result"]]],[11,"fmt","holochain_core::state","",36,[[["self"],["formatter"]],["result"]]],[11,"try_from","holochain_core::agent::state","",9,[[["jsonstring"]],["result"]]],[11,"try_from","","",9,[[["jsonstring"]],["result"]]],[11,"try_from","","",9,[[["state"]],["result"]]],[11,"try_from","","",7,[[["jsonstring"]],["result"]]],[11,"try_from","","",7,[[["jsonstring"]],["result"]]],[11,"try_from","holochain_core::network::direct_message","",16,[[["jsonstring"]],["result"]]],[11,"try_from","","",16,[[["jsonstring"]],["result"]]],[11,"try_from","holochain_core::nucleus::ribosome::callback","",25,[[["jsonstring"]],["result"]]],[11,"try_from","","",25,[[["jsonstring"]],["result"]]],[11,"from_str","holochain_core::nucleus::ribosome::api","",23,[[["str"]],["result"]]],[11,"from_str","holochain_core::nucleus::ribosome::callback","",24,[[["str"]],["result"]]],[11,"hash","holochain_core::action","@TODO dangerous when persisted! snowflake only guarantees uniqueness per process @see https://github.com/holochain/holochain-rust/issues/203",3,[[["self"],["h"]]]],[11,"hash","holochain_core::nucleus","",20,N],[11,"hash","","",21,N],[11,"hash","","",32,N],[11,"poll","holochain_core::agent::actions::commit","",37,[[["pin"],["localwaker"]],["poll"]]],[11,"poll","holochain_core::agent::actions::update_entry","",38,[[["pin"],["localwaker"]],["poll"]]],[11,"poll","holochain_core::dht::actions::add_link","",39,[[["pin"],["localwaker"]],["poll"]]],[11,"poll","holochain_core::dht::actions::hold","",40,[[["pin"],["localwaker"]],["poll"]]],[11,"poll","holochain_core::dht::actions::remove_entry","",41,[[["pin"],["localwaker"]],["poll"]]],[11,"poll","holochain_core::network::actions::custom_send","",43,[[["pin"],["localwaker"]],["poll"]]],[11,"poll","holochain_core::network::actions::get_entry","",44,[[["pin"],["localwaker"]],["poll"]]],[11,"poll","holochain_core::network::actions::get_validation_package","",45,[[["pin"],["localwaker"]],["poll"]]],[11,"poll","holochain_core::network::actions::initialize_network","",46,[[["pin"],["localwaker"]],["poll"]]],[11,"poll","holochain_core::network::actions::publish","",47,[[["pin"],["localwaker"]],["poll"]]],[11,"poll","holochain_core::nucleus::actions::build_validation_package","",48,[[["pin"],["localwaker"]],["poll"]]],[11,"poll","holochain_core::nucleus::actions::initialize","",49,[[["pin"],["localwaker"]],["poll"]]],[11,"poll","holochain_core::nucleus::actions::validate","",50,[[["pin"],["localwaker"]],["poll"]]],[11,"from_i64","holochain_core::nucleus::ribosome::api","",23,[[["i64"]],["option"]]],[11,"from_u64","","",23,[[["u64"]],["option"]]],[11,"from_i64","holochain_core::nucleus::ribosome::callback","",24,[[["i64"]],["option"]]],[11,"from_u64","","",24,[[["u64"]],["option"]]],[11,"serialize","holochain_core::agent::state","",9,[[["self"],["__s"]],["result"]]],[11,"serialize","","",7,[[["self"],["__s"]],["result"]]],[11,"serialize","holochain_core::network::direct_message","",16,[[["self"],["__s"]],["result"]]],[11,"serialize","","",17,[[["self"],["__s"]],["result"]]],[11,"serialize","holochain_core::network::entry_with_header","",18,[[["self"],["__s"]],["result"]]],[11,"serialize","holochain_core::nucleus::ribosome::callback","",25,[[["self"],["__s"]],["result"]]],[11,"serialize","","",26,[[["self"],["__s"]],["result"]]],[11,"deserialize","holochain_core::agent::state","",9,[[["__d"]],["result"]]],[11,"deserialize","","",7,[[["__d"]],["result"]]],[11,"deserialize","holochain_core::network::direct_message","",16,[[["__d"]],["result"]]],[11,"deserialize","","",17,[[["__d"]],["result"]]],[11,"deserialize","holochain_core::network::entry_with_header","",18,[[["__d"]],["result"]]],[11,"deserialize","holochain_core::nucleus::ribosome::callback","",25,[[["__d"]],["result"]]],[11,"deserialize","","",26,[[["__d"]],["result"]]],[11,"invoke_index","holochain_core::nucleus::ribosome","",22,[[["self"],["usize"],["runtimeargs"]],["zomeapiresult"]]],[11,"content","holochain_core::agent::state","",9,[[["self"]],["content"]]],[11,"try_from_content","","",9,[[["content"]],["result",["holochainerror"]]]],[11,"address","","",9,[[["self"]],["address"]]]],"paths":[[3,"DirectMessageData"],[3,"NetworkSettings"],[4,"Action"],[3,"ActionWrapper"],[3,"ChainStore"],[3,"ChainStoreIterator"],[3,"ChainStoreTypeIterator"],[4,"ActionResponse"],[3,"AgentState"],[3,"AgentStateSnapshot"],[3,"Context"],[3,"DhtStore"],[3,"Observer"],[3,"Instance"],[8,"Logger"],[4,"ActionResponse"],[3,"CustomDirectMessage"],[4,"DirectMessage"],[3,"EntryWithHeader"],[3,"NetworkState"],[3,"ZomeFnCall"],[3,"EntrySubmission"],[3,"Runtime"],[4,"ZomeApiFunction"],[4,"Callback"],[4,"CallbackParams"],[4,"CallbackResult"],[3,"LinkDefinitionPath"],[3,"SinglePageManager"],[8,"Defn"],[3,"NucleusState"],[4,"NucleusStatus"],[3,"ExecuteZomeFnResponse"],[8,"Persister"],[3,"SimplePersister"],[4,"Signal"],[3,"State"],[3,"CommitFuture"],[3,"UpdateEntryFuture"],[3,"AddLinkFuture"],[3,"HoldEntryFuture"],[3,"RemoveEntryFuture"],[3,"SimpleLogger"],[3,"SendResponseFuture"],[3,"GetEntryFuture"],[3,"GetValidationPackageFuture"],[3,"InitNetworkFuture"],[3,"PublishFuture"],[3,"ValidationPackageFuture"],[3,"InitializationFuture"],[3,"ValidationFuture"]]};
searchIndex["holochain_core_api_c_binding"]={"doc":"","items":[[5,"holochain_new","holochain_core_api_c_binding","",N,N],[5,"holochain_load","","",N,N],[5,"holochain_start","","",N,N],[5,"holochain_stop","","",N,N],[5,"holochain_call","","",N,N]],"paths":[]};
searchIndex["holochain_core_types"]={"doc":"Holochain Core Types","items":[[0,"cas","holochain_core_types","This module contains trait definitions, examples, and test suites for AddressableContent and ContentAddressableStorage.",N,N],[0,"content","holochain_core_types::cas","Implements a definition of what AddressableContent is by defining Content, defining Address, and defining the relationship between them. AddressableContent is a trait, meaning that it can be implemented for other structs. A test suite for AddressableContent is also implemented here.",N,N],[3,"ExampleAddressableContent","holochain_core_types::cas::content","some struct that can be content addressed imagine an Entry, ChainHeader, Meta Value, etc.",N,N],[3,"OtherExampleAddressableContent","","another struct that can be content addressed used to show ExampleCas storing multiple types",N,N],[3,"AddressableContentTestSuite","","",N,N],[6,"Address","","an Address for some Content ideally would be the Content but pragmatically must be Address consider what would happen if we had multi GB addresses...",N,N],[6,"Content","","the Content is a JsonString this is the only way to be confident in persisting all Rust types across all backends",N,N],[8,"AddressableContent","","can be stored as serialized content the content is the address, there is no \"location\" like a file system or URL @see https://en.wikipedia.org/wiki/Content-addressable_storage",N,N],[11,"address","","the Address the Content would be available at once stored in a ContentAddressableStorage default implementation is provided as hashing Content with sha256 the default implementation should cover most use-cases it is critical that there are no hash collisions across all stored AddressableContent it is recommended to implement an \"address space\" prefix for address algorithms that don't offer strong cryptographic guarantees like sha et. al.",0,[[["self"]],["address"]]],[10,"content","","the Content that would be stored in a ContentAddressableStorage the default implementation covers anything that implements From for JsonString",0,[[["self"]],["content"]]],[10,"try_from_content","","restore/deserialize the original struct/type from serialized Content the default implementation covers anything that implements From for Foo",0,[[["content"]],["result",["holochainerror"]]]],[11,"addressable_content_trait_test","","test that trait gives the write content",1,[[["content"],["t"],["address"]]]],[11,"addressable_contents_are_the_same_test","","test that two different addressable contents would give them same thing",1,[[["content"]]]],[11,"addressable_content_round_trip","","",1,[[["vec"],["k"]]]],[0,"storage","holochain_core_types::cas","ContentAddressableStorage (CAS) is defined here as a trait, such that there could be various implementations, such as the memory based, and file storage based implementations already in this code base. ContentAddressableStorage is a way of reading and writing AddressableContent in a persistent data store. A test suite for CAS is also implemented here.",N,N],[3,"ExampleContentAddressableStorage","holochain_core_types::cas::storage","some struct to show an example ContentAddressableStorage implementation this is a thread-safe wrapper around the non-thread-safe implementation below @see ExampleContentAddressableStorageActor",N,N],[3,"ExampleContentAddressableStorageContent","","Not thread-safe CAS implementation with a HashMap",N,N],[3,"StorageTestSuite","","",N,N],[12,"cas","","",2,N],[12,"cas_clone","","",2,N],[3,"EavTestSuite","","",N,N],[5,"test_content_addressable_storage","","",N,[[],["examplecontentaddressablestorage"]]],[8,"ContentAddressableStorage","","content addressable store (CAS) implements storage in memory or persistently anything implementing AddressableContent can be added and fetched by address CAS is append only",N,N],[10,"add","","adds AddressableContent to the ContentAddressableStorage by its Address as Content",3,[[["self"],["addressablecontent"]],["result",["holochainerror"]]]],[10,"contains","","true if the Address is in the Store, false otherwise. may be more efficient than retrieve depending on the implementation.",3,[[["self"],["address"]],["result",["bool","holochainerror"]]]],[10,"fetch","","returns Some AddressableContent if it is in the Store, else None AddressableContent::from_content() can be used to allow the compiler to infer the type @see the fetch implementation for ExampleCas in the cas module tests",3,[[["self"],["address"]],["result",["option","holochainerror"]]]],[10,"get_id","","",3,[[["self"]],["uuid"]]],[11,"new","","",4,[[],["result",["examplecontentaddressablestorage","holochainerror"]]]],[11,"new","","",5,[[],["examplecontentaddressablestoragecontent"]]],[11,"new","","",2,[[["t"]],["storagetestsuite"]]],[11,"round_trip_test","","",2,[[["self"],["content"],["content"]]]],[11,"test_round_trip","","",6,N],[11,"test_one_to_many","","",6,[[["s"]]]],[11,"test_many_to_one","","",6,[[["s"]]]],[0,"chain_header","holochain_core_types","This module contains definitions of the ChainHeader struct, constructor, and getters. This struct really defines a local source chain, in the sense that it implements the pointers between hashes that a hash chain relies on, which are then used to check the integrity of data using cryptographic hash functions.",N,N],[3,"ChainHeader","holochain_core_types::chain_header","ChainHeader of a source chain \"Item\" The address of the ChainHeader is used as the Item's key in the source chain hash table ChainHeaders are linked to next header in chain and next header of same type in chain",N,N],[5,"test_chain_header","","returns a dummy header for use in tests",N,[[],["chainheader"]]],[5,"test_sources","","",N,[[],["vec",["address"]]]],[11,"new","","build a new ChainHeader from a chain, entry type and entry. a ChainHeader is immutable, but the chain is mutable if chain.push() is used. this means that a header becomes invalid and useless as soon as the chain is mutated the only valid usage of a header is to immediately push it onto a chain in a Pair. normally (outside unit tests) the generation of valid headers is internal to the chain::SourceChain trait and should not need to be handled manually",7,[[["entrytype"],["address"],["vec"],["vec"],["option"],["option"],["option"],["iso8601"]],["self"]]],[11,"entry_type","","entry_type getter",7,[[["self"]],["entrytype"]]],[11,"timestamp","","timestamp getter",7,[[["self"]],["iso8601"]]],[11,"link","","link getter",7,[[["self"]],["option",["address"]]]],[11,"entry_address","","entry_address getter",7,[[["self"]],["address"]]],[11,"link_same_type","","link_same_type getter",7,[[["self"]],["option",["address"]]]],[11,"link_crud","","link_crud getter",7,[[["self"]],["option",["address"]]]],[11,"entry_signatures","","entry_signature getter",7,[[["self"]],["vec"]]],[11,"sources","","",7,[[["self"]],["vec"]]],[0,"crud_status","holochain_core_types","This module holds the relevant constants and an enum required for Holochain to have 'status' metadata for entries. Since Holochain uses an append-only data structure, but still wishes to provide classical features of a data store such as \"update\" and \"remove\" (delete), metadata is created pointing entries forward to their 'latest' version, even including an entry being marked as deleted.",N,N],[4,"CrudStatus","holochain_core_types::crud_status","the CRUD status of a Pair is stored using an EAV, NOT in the entry itself",N,N],[13,"Live","","",8,N],[13,"Rejected","","",8,N],[13,"Deleted","","",8,N],[13,"Modified","","",8,N],[13,"Locked","","CRDT resolution in progress",8,N],[5,"create_crud_status_eav","","Create a new EAV with an entry address as the Entity, STATUS_NAME as the attribute and CrudStatus as the value. This will come to represent the lifecycle status of an entry, when it gets stored in an EAV Storage",N,[[["address"],["crudstatus"]],["hcresult",["entityattributevalue"]]]],[5,"create_crud_link_eav","","Create a new EAV with an old entry address as the Entity, LINK_NAME as the attribute and a new entry address as the value",N,[[["address"],["address"]],["hcresult",["entityattributevalue"]]]],[17,"STATUS_NAME","","The EAV attribute name utilized for storing metadata about the lifecycle related status of an entry",N,N],[17,"LINK_NAME","","The EAV attribute name utilized for storing metadata that indicates the address of an updated version of a given entry",N,N],[0,"eav","holochain_core_types","EAV stands for entity-attribute-value. It is a pattern implemented here for adding metadata about entries in the DHT, additionally being used to define relationships between AddressableContent values. See wikipedia to learn more about this pattern.",N,N],[3,"EntityAttributeValue","holochain_core_types::eav","The basic struct for EntityAttributeValue triple, implemented as AddressableContent including the necessary serialization inherited.",N,N],[3,"ExampleEntityAttributeValueStorageNonSync","","",N,N],[3,"ExampleEntityAttributeValueStorage","","",N,N],[5,"test_eav_entity","","",N,[[],["entry"]]],[5,"test_eav_attribute","","",N,[[],["string"]]],[5,"test_eav_value","","",N,[[],["entry"]]],[5,"test_eav","","",N,[[],["entityattributevalue"]]],[5,"test_eav_content","","",N,[[],["content"]]],[5,"test_eav_address","","",N,[[],["address"]]],[5,"eav_round_trip_test_runner","","",N,N],[6,"Entity","","Address of AddressableContent representing the EAV entity",N,N],[6,"Attribute","","Using String for EAV attributes (not e.g. an enum) keeps it simple and open",N,N],[6,"Value","","Address of AddressableContent representing the EAV value",N,N],[8,"EntityAttributeValueStorage","","This provides a simple and flexible interface to define relationships between AddressableContent. It does NOT provide storage for AddressableContent. Use cas::storage::ContentAddressableStorage to store AddressableContent.",N,N],[10,"add_eav","","Adds the given EntityAttributeValue to the EntityAttributeValueStorage append only storage.",9,[[["self"],["entityattributevalue"]],["result",["holochainerror"]]]],[10,"fetch_eav","","Fetch the set of EntityAttributeValues that match constraints. - None = no constraint - Some(Entity) = requires the given entity (e.g. all a/v pairs for the entity) - Some(Attribute) = requires the given attribute (e.g. all links) - Some(Value) = requires the given value (e.g. all entities referencing an Address)",9,[[["self"],["option",["entity"]],["option",["attribute"]],["option",["value"]]],["result",["hashset","holochainerror"]]]],[11,"new","","",10,[[["entity"],["attribute"],["value"]],["hcresult",["entityattributevalue"]]]],[11,"entity","","",10,[[["self"]],["entity"]]],[11,"attribute","","",10,[[["self"]],["attribute"]]],[11,"value","","",10,[[["self"]],["value"]]],[11,"filter_on_eav","","this is a predicate for matching on eav values. Useful for reducing duplicated filtered code.",10,[[["t"],["option"]],["bool"]]],[11,"new","","",11,[[],["exampleentityattributevaluestoragenonsync"]]],[11,"new","","",12,[[],["hcresult",["exampleentityattributevaluestorage"]]]],[0,"entry","holochain_core_types","This module contains all the necessary definitions for Entry, which broadly speaking refers to any data which will be written into the ContentAddressableStorage, or the EntityAttributeValueStorage. It defines serialization behaviour for entries. Here you can find the complete list of entry_types, and special entries, like deletion_entry and cap_entry.",N,N],[3,"EntryWithMeta","holochain_core_types::entry","",N,N],[12,"entry","","",13,N],[12,"crud_status","","",13,N],[12,"maybe_crud_link","","",13,N],[4,"Entry","","Structure holding actual data in a source chain \"Item\" data is stored as a JsonString",N,N],[13,"App","","",14,N],[13,"Dna","","",14,N],[13,"AgentId","","",14,N],[13,"Deletion","","",14,N],[13,"LinkAdd","","",14,N],[13,"LinkRemove","","",14,N],[13,"LinkList","","",14,N],[13,"ChainHeader","","",14,N],[13,"ChainMigrate","","",14,N],[13,"CapToken","","",14,N],[13,"CapTokenGrant","","",14,N],[5,"test_entry_value","","dummy entry value",N,[[],["jsonstring"]]],[5,"test_entry_content","","",N,[[],["content"]]],[5,"test_entry_value_a","","dummy entry content, same as test_entry_value()",N,[[],["jsonstring"]]],[5,"test_entry_value_b","","dummy entry content, differs from test_entry_value()",N,[[],["jsonstring"]]],[5,"test_entry_value_c","","",N,[[],["jsonstring"]]],[5,"test_sys_entry_value","","",N,[[],["agentid"]]],[5,"test_entry","","dummy entry",N,[[],["entry"]]],[5,"expected_serialized_entry_content","","",N,[[],["jsonstring"]]],[5,"expected_entry_address","","the correct address for test_entry()",N,[[],["address"]]],[5,"test_entry_a","","dummy entry, same as test_entry()",N,[[],["entry"]]],[5,"test_entry_b","","dummy entry, differs from test_entry()",N,[[],["entry"]]],[5,"test_entry_c","","",N,[[],["entry"]]],[5,"test_entry_unique","","dummy entry with unique string content",N,[[],["entry"]]],[5,"test_sys_entry","","",N,[[],["entry"]]],[5,"test_sys_entry_address","","",N,[[],["address"]]],[5,"test_unpublishable_entry","","",N,[[],["entry"]]],[0,"cap_entries","","",N,N],[3,"CapToken","holochain_core_types::entry::cap_entries","System entry to hold a capability token for use as a caller",N,N],[3,"CapTokenGrant","","System entry to hold a capabilities granted by the callee",N,N],[6,"CapTokenValue","","",N,N],[11,"new","","",15,[[["captokenvalue"]],["self"]]],[11,"token","","",15,[[["self"]],["captokenvalue"]]],[11,"create","","",16,[[["capabilitytype"],["option",["vec"]]],["result",["holochainerror"]]]],[11,"token","","",16,[[["self"]],["captokenvalue"]]],[11,"cap_type","","",16,[[["self"]],["capabilitytype"]]],[11,"assignees","","",16,[[["self"]],["option",["vec"]]]],[11,"verify","","verifies that this grant is valid for a given requester and token value",16,[[["self"],["captokenvalue"],["option",["address"]],["callsignature"]],["bool"]]],[0,"deletion_entry","holochain_core_types::entry","",N,N],[3,"DeletionEntry","holochain_core_types::entry::deletion_entry","",N,N],[11,"new","","",17,[[["address"]],["self"]]],[11,"deleted_entry_address","","",17,[[["self"]],["address"]]],[0,"entry_type","holochain_core_types::entry","",N,N],[3,"AppEntryType","holochain_core_types::entry::entry_type","",N,N],[4,"EntryType","","",N,N],[13,"App","","",18,N],[13,"Dna","","",18,N],[13,"AgentId","","",18,N],[13,"Deletion","","",18,N],[13,"LinkAdd","","",18,N],[13,"LinkRemove","","",18,N],[13,"LinkList","","",18,N],[13,"ChainHeader","","",18,N],[13,"ChainMigrate","","",18,N],[13,"CapTokenGrant","","",18,N],[13,"CapToken","","",18,N],[5,"test_app_entry_type","","dummy entry type",N,[[],["appentrytype"]]],[5,"test_entry_type","","",N,[[],["entrytype"]]],[5,"test_app_entry_type_a","","dummy entry type, same as test_type()",N,[[],["appentrytype"]]],[5,"test_entry_type_a","","",N,[[],["entrytype"]]],[5,"test_app_entry_type_b","","dummy entry type, differs from test_type()",N,[[],["appentrytype"]]],[5,"test_entry_type_b","","",N,[[],["entrytype"]]],[11,"is_app","","",18,[[["self"]],["bool"]]],[11,"is_sys","","",18,[[["self"]],["bool"]]],[11,"can_publish","","",18,[[["self"]],["bool"]]],[11,"has_valid_app_name","","Checks entry_type_name is valid",18,[[["str"]],["bool"]]],[6,"AppEntryValue","holochain_core_types::entry","",N,N],[11,"entry_type","","",14,[[["self"]],["entrytype"]]],[0,"error","holochain_core_types","This module contains Error type definitions that are used throughout Holochain, and the Ribosome in particular, which is responsible for mounting and running instances of DNA, and executing WASM code.",N,N],[4,"DnaError","holochain_core_types::error","",N,N],[13,"ZomeNotFound","","",19,N],[13,"CapabilityNotFound","","",19,N],[13,"ZomeFunctionNotFound","","",19,N],[4,"RibosomeReturnCode","","Enum of all possible RETURN codes that a Zome API Function could return. Represents an encoded allocation of zero length with the return code as offset. @see SinglePageAllocation",N,N],[13,"Success","","",20,N],[13,"Failure","","",20,N],[4,"RibosomeErrorCode","","Enum of all possible ERROR codes that a Zome API Function could return.",N,N],[13,"Unspecified","","",21,N],[13,"ArgumentDeserializationFailed","","",21,N],[13,"OutOfMemory","","",21,N],[13,"ReceivedWrongActionResult","","",21,N],[13,"CallbackFailed","","",21,N],[13,"RecursiveCallForbidden","","",21,N],[13,"ResponseSerializationFailed","","",21,N],[13,"NotAnAllocation","","",21,N],[13,"ZeroSizedAllocation","","",21,N],[13,"UnknownEntryType","","",21,N],[0,"error","","",N,N],[3,"CoreError","holochain_core_types::error::error","Holochain Core Error struct Any Error in Core should be wrapped in a CoreError so it can be passed to the Zome and back to the Holochain Instance via wasm memory. Follows the Error + ErrorKind pattern Holds extra debugging info for indicating where in code ther error occured.",N,N],[12,"kind","","",22,N],[12,"file","","",22,N],[12,"line","","",22,N],[3,"ZomeApiInternalResult","","",N,N],[12,"ok","","",23,N],[12,"value","","",23,N],[12,"error","","",23,N],[4,"HolochainError","","TODO rename to CoreErrorKind Enum holding all Holochain Core errors",N,N],[13,"ErrorGeneric","","",24,N],[13,"NotImplemented","","",24,N],[13,"LoggingError","","",24,N],[13,"DnaMissing","","",24,N],[13,"Dna","","",24,N],[13,"IoError","","",24,N],[13,"SerializationError","","",24,N],[13,"InvalidOperationOnSysEntry","","",24,N],[13,"CapabilityCheckFailed","","",24,N],[13,"ValidationFailed","","",24,N],[13,"Ribosome","","",24,N],[13,"RibosomeFailed","","",24,N],[13,"ConfigError","","",24,N],[13,"Timeout","","",24,N],[6,"HcResult","","",N,N],[11,"new","","",22,[[["holochainerror"]],["self"]]],[11,"new","","",24,[[["str"]],["holochainerror"]]],[11,"success","","",23,[[["j"]],["zomeapiinternalresult"]]],[11,"failure","","",23,[[["j"]],["zomeapiinternalresult"]]],[11,"from_error","holochain_core_types::error","",20,[[["ribosomeerrorcode"]],["self"]]],[11,"from_offset","","",20,[[["u16"]],["self"]]],[11,"as_str","","",21,[[["self"]],["str"]]],[11,"from_offset","","",21,[[["u16"]],["self"]]],[11,"from_return_code","","",21,[[["ribosomereturncode"]],["self"]]],[0,"agent","holochain_core_types","Represents an agent entry in the cas",N,N],[3,"KeyBuffer","holochain_core_types::agent","A raw public key buffer Can extract the signature and encryption portions Can parse a base64url encoded user representation Can render a base64url encoded user representation",N,N],[3,"AgentId","","agent data that can be stored in the cas note thate the \"address\" of an agent entry is the base64url encoded public key identity string",N,N],[12,"nick","","a nickname for referencing this agent",25,N],[12,"key","","the base64url encoded public identity string for this agent",25,N],[5,"test_base64_to_agent_id","","",N,[[["str"]],["result",["agentid","holochainerror"]]]],[5,"test_agent_id","","",N,[[],["agentid"]]],[7,"GOOD_ID","","",N,N],[7,"BAD_ID","","",N,N],[7,"TOO_BAD_ID","","",N,N],[11,"with_corrected","","take a potentially user-entered base64url encoded user representation of an public key identity apply reed-solomon parity correction returns a raw byte buffer",26,[[["str"]],["result",["keybuffer","holochainerror"]]]],[11,"with_raw","","generate a key buffer from raw bytes (no correction)",26,N],[11,"render","","render a base64url encoded user identity with reed-solomon parity bytes",26,[[["self"]],["string"]]],[11,"get_sig","","get the signature public key portion of this buffer",26,N],[11,"get_enc","","get the encryption public key portion of this buffer",26,N],[11,"generate_fake","","generate a fake testing agent `s` will be used for the `nick` and included in the key string as well this agent is not cryptographically generated... it will not be able to sign / encrypt anything",25,[[["str"]],["self"]]],[11,"new","","initialize an Agent struct with `nick` and `key`",25,[[["str"],["keybuffer"]],["self"]]],[11,"to_buffer","","get a key buffer based on this agent's key (no correction)",25,[[["self"]],["keybuffer"]]],[0,"chain_migrate","holochain_core_types","NOT YET AVAILABLE",N,N],[3,"ChainMigrate","holochain_core_types::chain_migrate","",N,N],[0,"dna","holochain_core_types","dna is a library for working with holochain dna files/entries.",N,N],[0,"bridges","holochain_core_types::dna","",N,N],[3,"Bridge","holochain_core_types::dna::bridges","A bridge is the definition of a connection to another DNA that runs under the same agency, i.e. in the same container.",N,N],[12,"presence","","Required or optional",27,N],[12,"handle","","An arbitrary name of this bridge that is used as handle to reference this bridge in according zome API functions",27,N],[12,"reference","","Define what other DNA(s) to bridge to",27,N],[4,"BridgeReference","","This enum represents the two different ways of referring to another DNA instance. If we know a priori what exact version of another DNA we want to bridge to we can specify the DNA address (i.e. hash) and lock it in. Often, we need more flexibility when * the other DNA gets replaced by a newer version * the other DNA gets created from a template and thus we don't know the exact hash   during build-time * we want to build a complex system of components that should be pluggable. Bridges can therefore also be specified by capabilities (read traits or interfaces). That means we specify a list of functions with their signatures and allow the container (through the container bridge config) to resolve this bridge by any DNA instance that implements all specified functions, just like a dynamic binding of function calls.",N,N],[13,"Address","","A bridge reference that defines another DNA statically by its address (i.e. hash). If this variant is used the other DNA gets locked in as per DNA hash",28,N],[12,"dna_address","holochain_core_types::dna::bridges::BridgeReference","",28,N],[13,"Capability","holochain_core_types::dna::bridges","A bridge reference that defines another DNA loosely by expecting a DNA that implements a given set of capabilities, i.e. that has specific sets of zome functions with matching signatures.",28,N],[12,"capabilities","holochain_core_types::dna::bridges::BridgeReference","",28,N],[4,"BridgePresence","holochain_core_types::dna::bridges","Required or optional",N,N],[13,"Required","","A required bridge is a dependency to another DNA. This DNA won't load without it.",29,N],[13,"Optional","","An optional bridge may be missing. This DNA's code can check via API functions if the other DNA is installed and connected.",29,N],[0,"capabilities","holochain_core_types::dna","File holding all the structs for handling capabilities defined in DNA.",N,N],[3,"CallSignature","holochain_core_types::dna::capabilities","a struct to hold the signature of the call",N,N],[3,"CapabilityCall","","",N,N],[12,"cap_name","","",30,N],[12,"cap_token","","",30,N],[12,"caller","","",30,N],[12,"signature","","",30,N],[3,"FnParameter","","",N,N],[12,"parameter_type","","",31,N],[12,"name","","",31,N],[3,"FnDeclaration","","Represents a zome \"fn_declarations\" object.",N,N],[12,"name","","The name of this fn declaration.",32,N],[12,"inputs","","",32,N],[12,"outputs","","",32,N],[3,"Capability","","Represents an individual object in the \"zome\" \"capabilities\" array.",N,N],[12,"cap_type","","capability type enum",33,N],[12,"functions","","\"fn_declarations\" array",33,N],[4,"ReservedCapabilityNames","","Enumeration of all Capabilities known and used by HC Core Enumeration converts to str",N,N],[13,"MissingNo","","Development placeholder, no production fn should use MissingNo",34,N],[13,"LifeCycle","","@TODO document what LifeCycle is @see https://github.com/holochain/holochain-rust/issues/204",34,N],[13,"Communication","","@TODO document what Communication is @see https://github.com/holochain/holochain-rust/issues/204",34,N],[4,"CapabilityType","","Enum for Zome CapabilityType.  Public capabilities require no token.  Transferable capabilities require a token, but don't limit the capability to specific agent(s); this functions like a password in that you can give the token to someone else and it works. Assigned capabilities check the request's signature against the list of agents to which the capability has been granted.",N,N],[13,"Public","","",35,N],[13,"Transferable","","",35,N],[13,"Assigned","","",35,N],[11,"as_str","","",34,[[["self"]],["str"]]],[11,"new","","",30,[[["string"],["address"],["option",["address"]]],["self"]]],[11,"new","","",31,[[["s"],["s"]],["fnparameter"]]],[11,"new","","Allow sane defaults for `FnDecrlaration::new()`.",32,[[],["self"]]],[11,"new","","Capability Constructor",33,[[["capabilitytype"]],["self"]]],[0,"dna","holochain_core_types::dna","",N,N],[3,"Dna","holochain_core_types::dna::dna","Represents the top-level holochain dna object.",N,N],[12,"name","","The top-level \"name\" of a holochain application.",36,N],[12,"description","","The top-level \"description\" of a holochain application.",36,N],[12,"version","","The semantic version of your holochain application.",36,N],[12,"uuid","","A unique identifier to distinguish your holochain application.",36,N],[12,"dna_spec_version","","Which version of the holochain dna spec does this represent?",36,N],[12,"properties","","Any arbitrary application properties can be included in this object.",36,N],[12,"zomes","","An array of zomes associated with your holochain application.",36,N],[11,"new","","Create a new in-memory dna structure with some default values.",36,[[],["self"]]],[11,"to_json_pretty","","Generate a pretty-printed json string from an in-memory dna struct.",36,[[["self"]],["result",["string"]]]],[11,"get_zome","","Return a Zome",36,[[["self"],["str"]],["option",["zome"]]]],[11,"get_capability","","Return a Zome's Capability from a Zome and a Capability name.",36,[[["self"],["zome"],["str"]],["option",["capability"]]]],[11,"get_wasm_from_zome_name","","Find a Zome and return it's WASM bytecode for a specified Capability",36,[[["self"],["t"]],["option",["dnawasm"]]]],[11,"get_capability_with_zome_name","","Return a Zome's Capability from a Zome name and Capability name.",36,[[["self"],["str"],["str"]],["result",["capability","dnaerror"]]]],[11,"get_zome_name_for_app_entry_type","","Return the name of the zome holding a specified app entry_type",36,[[["self"],["appentrytype"]],["option",["string"]]]],[11,"get_entry_type_def","","Return the entry_type definition of a specified app entry_type",36,[[["self"],["str"]],["option",["entrytypedef"]]]],[11,"multihash","","",36,[[["self"]],["result",["vec","holochainerror"]]]],[11,"get_required_bridges","","",36,[[["self"]],["vec",["bridge"]]]],[0,"entry_types","holochain_core_types::dna","File holding all the structs for handling entry types defined by DNA.",N,N],[3,"LinksTo","holochain_core_types::dna::entry_types","An individual object in a \"links_to\" array.",N,N],[12,"target_type","","The target_type of this links_to entry",37,N],[12,"tag","","The tag of this links_to entry",37,N],[3,"LinkedFrom","","An a definition of a link from another type (including anchors and system hashes) to the entry type it is part of.",N,N],[12,"base_type","","The target_type of this links_to entry",38,N],[12,"tag","","The tag of this links_to entry",38,N],[3,"EntryTypeDef","","Represents an individual object in the \"zome\" \"entry_types\" array.",N,N],[12,"description","","A description of this entry type.",39,N],[12,"sharing","","The sharing model of this entry type (public, private, encrypted).",39,N],[12,"links_to","","An array of link definitions associated with this entry type",39,N],[12,"linked_from","","An array of link definitions for links pointing to entries of this type",39,N],[4,"Sharing","","Enum for Zome EntryType \"sharing\" property.",N,N],[13,"Public","","",40,N],[13,"Private","","",40,N],[13,"Encrypted","","",40,N],[5,"serialize_entry_types","","",N,[[["zomeentrytypes"],["s"]],["result"]]],[5,"deserialize_entry_types","","",N,[[["d"]],["result",["zomeentrytypes"]]]],[11,"can_publish","","",40,[[["self"]],["bool"]]],[11,"new","","Allow sane defaults for `LinksTo::new()`.",37,[[],["self"]]],[11,"new","","Allow sane defaults for `LinkedFrom::new()`.",38,[[],["self"]]],[11,"new","","Allow sane defaults for `EntryType::new()`.",39,[[],["self"]]],[0,"wasm","holochain_core_types::dna","holochain_core_types::dna::wasm is a module for managing webassembly code - within the in-memory dna struct - and serialized to json",N,N],[3,"DnaWasm","holochain_core_types::dna::wasm","Represents web assembly code.",N,N],[12,"code","","The actual binary WebAssembly bytecode goes here.",41,N],[11,"new","","Allow sane defaults for `DnaWasm::new()`.",41,[[],["self"]]],[0,"zome","holochain_core_types::dna","holochain_core_types::dna::zome is a set of structs for working with holochain dna.",N,N],[3,"Config","holochain_core_types::dna::zome","Represents the \"config\" object on a \"zome\".",N,N],[12,"error_handling","","How errors should be handled within this zome.",42,N],[3,"Zome","","Represents an individual \"zome\".",N,N],[12,"description","","A description of this zome.",43,N],[12,"config","","Configuration associated with this zome. Note, this should perhaps be a more free-form serde_json::Value, \"throw-errors\" may not make sense for wasm, or other ribosome types.",43,N],[12,"entry_types","","An array of entry_types associated with this zome.",43,N],[12,"capabilities","","An array of capabilities associated with this zome.",43,N],[12,"code","","Validation code for this entry_type.",43,N],[12,"bridges","","A list of bridges to other DNAs that this DNA can use or depends on.",43,N],[4,"ErrorHandling","","Enum for \"zome\" \"config\" \"error_handling\" property.",N,N],[13,"ThrowErrors","","",44,N],[6,"ZomeEntryTypes","","",N,N],[6,"ZomeCapabilities","","",N,N],[11,"new","","Allow sane defaults for `Config::new()`.",42,[[],["self"]]],[11,"new","","Allow sane defaults for `Zome::new()`.",43,[[["str"],["config"],["btreemap"],["btreemap"],["dnawasm"]],["zome"]]],[11,"get_required_bridges","","",43,[[["self"]],["vec",["bridge"]]]],[0,"file_validation","holochain_core_types","",N,N],[5,"validate_canonical_path","holochain_core_types::file_validation","",N,[[["str"]],["result",["string","holochainerror"]]]],[0,"hash","holochain_core_types","The HashString type is defined here. It is used for type safety throughout the codebase to keep track of places where a string is the product of a hash function, and as a base type for Address to use.",N,N],[3,"HashString","holochain_core_types::hash","",N,N],[11,"new","","",45,[[],["hashstring"]]],[11,"encode_from_bytes","","convert bytes to a b58 hashed string",45,N],[11,"encode_from_str","","convert a string as bytes to a b58 hashed string",45,[[["str"],["hash"]],["hashstring"]]],[11,"encode_from_json_string","","magic all in one fn, take a JsonString + hash type and get a hashed b58 string back",45,[[["jsonstring"],["hash"]],["hashstring"]]],[0,"json","holochain_core_types","The JsonString type is defined here. It is used throughout Holochain to enforce a standardized serialization of data to/from json.",N,N],[3,"JsonString","holochain_core_types::json","track json serialization with the rust type system! JsonString wraps a string containing JSON serialized data avoid accidental double-serialization or forgetting to serialize serialize any type consistently including hard-to-reach places like Option and Result JsonString must not itself be serialized/deserialized instead, implement and use the native `From` trait to move between types - moving to/from String, str, JsonString and JsonString simply (un)wraps it as raw JSON data - moving to/from any other type must offer a reliable serialization/deserialization strategy",N,N],[3,"RawString","","generic type to facilitate Jsonifying values directly JsonString simply wraps String and str as-is but will Jsonify RawString(\"foo\") as \"\"foo\"\" RawString must not implement Serialize because it should always convert to JsonString with from RawString can implement Deserialize because JsonString uses default serde to step down",N,N],[5,"default_to_json","","if all you want to do is implement the default behaviour then use #[derive(DefaultJson)] should only be used with From for JsonString i.e. when failure should be impossible so an expect is ok this is always true for serializable structs/enums standard boilerplate: impl From for JsonString {     fn from(v: MyStruct) -> Self {         default_to_json(v)     } }",N,[[["v"]],["jsonstring"]]],[5,"default_try_from_json","","if all you want to do is implement the default behaviour then use #[derive(DefaultJson)] standard boilerplate should include HolochainError as the Error: impl TryFrom for T {     type Error = HolochainError;     fn try_from(j: JsonString) -> HcResult {         default_try_from_json(j)     } }",N,[[["jsonstring"]],["result",["holochainerror"]]]],[6,"JsonResult","","",N,N],[8,"JsonError","","signifies type can be converted to JsonString in Err from some Result can't use std::error::Error for this because String has Error as a reserved future trait",N,N],[8,"DefaultJson","","",N,N],[11,"null","","a null JSON value e.g. represents None when implementing From<Option>",46,[[],["jsonstring"]]],[11,"empty_object","","",46,[[],["jsonstring"]]],[11,"is_null","","",46,[[["self"]],["bool"]]],[11,"into_bytes","","achieves the same outcome as serde_json::to_vec()",46,[[["self"]],["vec",["u8"]]]],[0,"keys","holochain_core_types","",N,N],[3,"Key","holochain_core_types::keys","represents a single Key e.g. private + public keys would be two Key structs",N,N],[3,"Keys","","represents a set of Keys for an agent includes both public and private keys also includes the node id of the agent with these keys",N,N],[5,"test_key","","generates a new key suitable for testing",N,[[],["key"]]],[5,"test_public_key","","dummy public key",N,[[],["key"]]],[5,"test_private_key","","dummy private key",N,[[],["key"]]],[5,"test_node_id","","generates a new node id suitable for testing",N,[[],["string"]]],[5,"test_keys","","generates new id/pub/priv keys suitable for testing",N,[[],["keys"]]],[11,"new","","returns a new agent Key",47,[[],["key"]]],[11,"new","","returns a new set of agent Keys",48,[[["key"],["key"],["s"]],["keys"]]],[11,"public_key","","getter for the public key",48,[[["self"]],["key"]]],[11,"private_key","","getter for the private key",48,[[["self"]],["key"]]],[11,"node_id","","getter for the node id",48,[[["self"]],["string"]]],[0,"link","holochain_core_types","This module contains definitions for what a Link is in Holochain, as well as structs relating to the adding and removing of links between entries and lists of links.",N,N],[3,"Link","holochain_core_types::link","",N,N],[4,"LinkActionKind","","",N,N],[13,"ADD","","",49,N],[13,"DELETE","","",49,N],[0,"link_add","","",N,N],[3,"LinkAdd","holochain_core_types::link::link_add","",N,N],[11,"new","","",50,[[["address"],["address"],["str"]],["self"]]],[11,"action_kind","","",50,[[["self"]],["linkactionkind"]]],[11,"link","","",50,[[["self"]],["link"]]],[11,"from_link","","",50,[[["link"]],["self"]]],[0,"link_list","holochain_core_types::link","",N,N],[3,"LinkList","holochain_core_types::link::link_list","",N,N],[11,"new","","",51,N],[11,"links","","",51,[[["self"]],["vec"]]],[0,"link_remove","holochain_core_types::link","",N,N],[3,"LinkRemove","holochain_core_types::link::link_remove","",N,N],[11,"new","holochain_core_types::link","",52,[[["address"],["address"],["str"]],["self"]]],[11,"base","","",52,[[["self"]],["address"]]],[11,"target","","",52,[[["self"]],["address"]]],[11,"tag","","",52,[[["self"]],["string"]]],[0,"signature","holochain_core_types","The Signature type is defined here. They are used in ChainHeaders as a way of providing cryptographically verifiable proof of a given agent as having been the author of a given data entry.",N,N],[3,"Signature","holochain_core_types::signature","Signature is meant in the classic cryptographic sense, as a string which can be validated as having been signed by the private key associated with a given public key",N,N],[5,"test_signatures","","",N,[[],["vec",["signature"]]]],[5,"test_signature_b","","",N,[[],["signature"]]],[5,"test_signature_c","","",N,[[],["signature"]]],[0,"time","holochain_core_types","The Iso8601 type is defined here. It is used in particular within ChainHeader to enforce that their timestamps are defined in a useful and consistent way.",N,N],[3,"Iso8601","holochain_core_types::time","This struct represents datetime data stored as a string in the ISO 8601 format. More info on the relevant wikipedia article.",N,N],[5,"test_iso_8601","","",N,[[],["iso8601"]]],[0,"validation","holochain_core_types","This module defines structs that are used in the interchange of data that is used for validation of chain modifying agent actions between Holochain and Zomes.",N,N],[3,"ValidationPackage","holochain_core_types::validation","",N,N],[12,"chain_header","","",53,N],[12,"source_chain_entries","","",53,N],[12,"source_chain_headers","","",53,N],[12,"custom","","",53,N],[3,"ValidationData","","This structs carries information contextual for the process of validating an entry of link and is passed in to the according callbacks.",N,N],[12,"package","","The validation package is data from the entry's/link's source agent that is needed to determine the validity of a given entry. What specific data gets put into the validation package has to be defined throught the validation_package callbacks in the entry! and link! macros.",54,N],[12,"sources","","The list of authors that have signed this entry.",54,N],[12,"lifecycle","","In which lifecycle of the entry creation are we running this validation callback?",54,N],[12,"action","","Does the entry get committed, modified or deleted?",54,N],[4,"ValidationPackageDefinition","","",N,N],[13,"Entry","","sending only the entry",55,N],[13,"ChainEntries","","sending all (public?) source chain entries",55,N],[13,"ChainHeaders","","sending all source chain headers",55,N],[13,"ChainFull","","sending the whole chain, entries and headers",55,N],[13,"Custom","","sending something custom",55,N],[4,"EntryLifecycle","","",N,N],[13,"Chain","","",56,N],[13,"Dht","","",56,N],[13,"Meta","","",56,N],[4,"EntryAction","","",N,N],[13,"Create","","",57,N],[13,"Modify","","",57,N],[13,"Delete","","",57,N],[4,"LinkAction","","",N,N],[13,"Create","","",58,N],[13,"Delete","","",58,N],[11,"only_header","","",53,[[["chainheader"]],["validationpackage"]]],[11,"from","holochain_core_types::cas::content","",59,[[["t"]],["t"]]],[11,"into","","",59,[[["self"]],["u"]]],[11,"to_owned","","",59,[[["self"]],["t"]]],[11,"clone_into","","",59,N],[11,"try_from","","",59,[[["u"]],["result"]]],[11,"borrow","","",59,[[["self"]],["t"]]],[11,"get_type_id","","",59,[[["self"]],["typeid"]]],[11,"try_into","","",59,[[["self"]],["result"]]],[11,"borrow_mut","","",59,[[["self"]],["t"]]],[11,"equivalent","","",59,[[["self"],["k"]],["bool"]]],[11,"clone_box","","",59,N],[11,"from","","",60,[[["t"]],["t"]]],[11,"into","","",60,[[["self"]],["u"]]],[11,"to_owned","","",60,[[["self"]],["t"]]],[11,"clone_into","","",60,N],[11,"try_from","","",60,[[["u"]],["result"]]],[11,"borrow","","",60,[[["self"]],["t"]]],[11,"get_type_id","","",60,[[["self"]],["typeid"]]],[11,"try_into","","",60,[[["self"]],["result"]]],[11,"borrow_mut","","",60,[[["self"]],["t"]]],[11,"clone_box","","",60,N],[11,"from","","",1,[[["t"]],["t"]]],[11,"into","","",1,[[["self"]],["u"]]],[11,"try_from","","",1,[[["u"]],["result"]]],[11,"borrow","","",1,[[["self"]],["t"]]],[11,"get_type_id","","",1,[[["self"]],["typeid"]]],[11,"try_into","","",1,[[["self"]],["result"]]],[11,"borrow_mut","","",1,[[["self"]],["t"]]],[11,"from","holochain_core_types::cas::storage","",4,[[["t"]],["t"]]],[11,"into","","",4,[[["self"]],["u"]]],[11,"to_owned","","",4,[[["self"]],["t"]]],[11,"clone_into","","",4,N],[11,"try_from","","",4,[[["u"]],["result"]]],[11,"borrow","","",4,[[["self"]],["t"]]],[11,"get_type_id","","",4,[[["self"]],["typeid"]]],[11,"try_into","","",4,[[["self"]],["result"]]],[11,"borrow_mut","","",4,[[["self"]],["t"]]],[11,"clone_box","","",4,N],[11,"from","","",5,[[["t"]],["t"]]],[11,"into","","",5,[[["self"]],["u"]]],[11,"try_from","","",5,[[["u"]],["result"]]],[11,"borrow","","",5,[[["self"]],["t"]]],[11,"get_type_id","","",5,[[["self"]],["typeid"]]],[11,"try_into","","",5,[[["self"]],["result"]]],[11,"borrow_mut","","",5,[[["self"]],["t"]]],[11,"from","","",2,[[["t"]],["t"]]],[11,"into","","",2,[[["self"]],["u"]]],[11,"try_from","","",2,[[["u"]],["result"]]],[11,"borrow","","",2,[[["self"]],["t"]]],[11,"get_type_id","","",2,[[["self"]],["typeid"]]],[11,"try_into","","",2,[[["self"]],["result"]]],[11,"borrow_mut","","",2,[[["self"]],["t"]]],[11,"from","","",6,[[["t"]],["t"]]],[11,"into","","",6,[[["self"]],["u"]]],[11,"try_from","","",6,[[["u"]],["result"]]],[11,"borrow","","",6,[[["self"]],["t"]]],[11,"get_type_id","","",6,[[["self"]],["typeid"]]],[11,"try_into","","",6,[[["self"]],["result"]]],[11,"borrow_mut","","",6,[[["self"]],["t"]]],[11,"from","holochain_core_types::chain_header","",7,[[["t"]],["t"]]],[11,"into","","",7,[[["self"]],["u"]]],[11,"to_owned","","",7,[[["self"]],["t"]]],[11,"clone_into","","",7,N],[11,"try_from","","",7,[[["u"]],["result"]]],[11,"borrow","","",7,[[["self"]],["t"]]],[11,"get_type_id","","",7,[[["self"]],["typeid"]]],[11,"try_into","","",7,[[["self"]],["result"]]],[11,"borrow_mut","","",7,[[["self"]],["t"]]],[11,"clone_box","","",7,N],[11,"from","holochain_core_types::crud_status","",8,[[["t"]],["t"]]],[11,"into","","",8,[[["self"]],["u"]]],[11,"to_owned","","",8,[[["self"]],["t"]]],[11,"clone_into","","",8,N],[11,"try_from","","",8,[[["u"]],["result"]]],[11,"borrow","","",8,[[["self"]],["t"]]],[11,"get_type_id","","",8,[[["self"]],["typeid"]]],[11,"try_into","","",8,[[["self"]],["result"]]],[11,"borrow_mut","","",8,[[["self"]],["t"]]],[11,"clone_box","","",8,N],[11,"from","holochain_core_types::eav","",10,[[["t"]],["t"]]],[11,"into","","",10,[[["self"]],["u"]]],[11,"to_owned","","",10,[[["self"]],["t"]]],[11,"clone_into","","",10,N],[11,"try_from","","",10,[[["u"]],["result"]]],[11,"borrow","","",10,[[["self"]],["t"]]],[11,"get_type_id","","",10,[[["self"]],["typeid"]]],[11,"try_into","","",10,[[["self"]],["result"]]],[11,"borrow_mut","","",10,[[["self"]],["t"]]],[11,"equivalent","","",10,[[["self"],["k"]],["bool"]]],[11,"clone_box","","",10,N],[11,"from","","",11,[[["t"]],["t"]]],[11,"into","","",11,[[["self"]],["u"]]],[11,"to_owned","","",11,[[["self"]],["t"]]],[11,"clone_into","","",11,N],[11,"try_from","","",11,[[["u"]],["result"]]],[11,"borrow","","",11,[[["self"]],["t"]]],[11,"get_type_id","","",11,[[["self"]],["typeid"]]],[11,"try_into","","",11,[[["self"]],["result"]]],[11,"borrow_mut","","",11,[[["self"]],["t"]]],[11,"clone_box","","",11,N],[11,"from","","",12,[[["t"]],["t"]]],[11,"into","","",12,[[["self"]],["u"]]],[11,"to_owned","","",12,[[["self"]],["t"]]],[11,"clone_into","","",12,N],[11,"try_from","","",12,[[["u"]],["result"]]],[11,"borrow","","",12,[[["self"]],["t"]]],[11,"get_type_id","","",12,[[["self"]],["typeid"]]],[11,"try_into","","",12,[[["self"]],["result"]]],[11,"borrow_mut","","",12,[[["self"]],["t"]]],[11,"clone_box","","",12,N],[11,"from","holochain_core_types::entry","",13,[[["t"]],["t"]]],[11,"into","","",13,[[["self"]],["u"]]],[11,"to_owned","","",13,[[["self"]],["t"]]],[11,"clone_into","","",13,N],[11,"try_from","","",13,[[["u"]],["result"]]],[11,"borrow","","",13,[[["self"]],["t"]]],[11,"get_type_id","","",13,[[["self"]],["typeid"]]],[11,"try_into","","",13,[[["self"]],["result"]]],[11,"borrow_mut","","",13,[[["self"]],["t"]]],[11,"clone_box","","",13,N],[11,"from","","",14,[[["t"]],["t"]]],[11,"into","","",14,[[["self"]],["u"]]],[11,"to_owned","","",14,[[["self"]],["t"]]],[11,"clone_into","","",14,N],[11,"try_from","","",14,[[["u"]],["result"]]],[11,"borrow","","",14,[[["self"]],["t"]]],[11,"get_type_id","","",14,[[["self"]],["typeid"]]],[11,"try_into","","",14,[[["self"]],["result"]]],[11,"borrow_mut","","",14,[[["self"]],["t"]]],[11,"clone_box","","",14,N],[11,"from","holochain_core_types::entry::cap_entries","",15,[[["t"]],["t"]]],[11,"into","","",15,[[["self"]],["u"]]],[11,"to_owned","","",15,[[["self"]],["t"]]],[11,"clone_into","","",15,N],[11,"try_from","","",15,[[["u"]],["result"]]],[11,"borrow","","",15,[[["self"]],["t"]]],[11,"get_type_id","","",15,[[["self"]],["typeid"]]],[11,"try_into","","",15,[[["self"]],["result"]]],[11,"borrow_mut","","",15,[[["self"]],["t"]]],[11,"clone_box","","",15,N],[11,"from","","",16,[[["t"]],["t"]]],[11,"into","","",16,[[["self"]],["u"]]],[11,"to_owned","","",16,[[["self"]],["t"]]],[11,"clone_into","","",16,N],[11,"try_from","","",16,[[["u"]],["result"]]],[11,"borrow","","",16,[[["self"]],["t"]]],[11,"get_type_id","","",16,[[["self"]],["typeid"]]],[11,"try_into","","",16,[[["self"]],["result"]]],[11,"borrow_mut","","",16,[[["self"]],["t"]]],[11,"clone_box","","",16,N],[11,"from","holochain_core_types::entry::deletion_entry","",17,[[["t"]],["t"]]],[11,"into","","",17,[[["self"]],["u"]]],[11,"to_owned","","",17,[[["self"]],["t"]]],[11,"clone_into","","",17,N],[11,"try_from","","",17,[[["u"]],["result"]]],[11,"borrow","","",17,[[["self"]],["t"]]],[11,"get_type_id","","",17,[[["self"]],["typeid"]]],[11,"try_into","","",17,[[["self"]],["result"]]],[11,"borrow_mut","","",17,[[["self"]],["t"]]],[11,"clone_box","","",17,N],[11,"from","holochain_core_types::entry::entry_type","",61,[[["t"]],["t"]]],[11,"into","","",61,[[["self"]],["u"]]],[11,"to_owned","","",61,[[["self"]],["t"]]],[11,"clone_into","","",61,N],[11,"to_string","","",61,[[["self"]],["string"]]],[11,"try_from","","",61,[[["u"]],["result"]]],[11,"borrow","","",61,[[["self"]],["t"]]],[11,"get_type_id","","",61,[[["self"]],["typeid"]]],[11,"try_into","","",61,[[["self"]],["result"]]],[11,"borrow_mut","","",61,[[["self"]],["t"]]],[11,"equivalent","","",61,[[["self"],["k"]],["bool"]]],[11,"clone_box","","",61,N],[11,"from","","",18,[[["t"]],["t"]]],[11,"into","","",18,[[["self"]],["u"]]],[11,"to_owned","","",18,[[["self"]],["t"]]],[11,"clone_into","","",18,N],[11,"to_string","","",18,[[["self"]],["string"]]],[11,"try_from","","",18,[[["u"]],["result"]]],[11,"borrow","","",18,[[["self"]],["t"]]],[11,"get_type_id","","",18,[[["self"]],["typeid"]]],[11,"try_into","","",18,[[["self"]],["result"]]],[11,"borrow_mut","","",18,[[["self"]],["t"]]],[11,"equivalent","","",18,[[["self"],["k"]],["bool"]]],[11,"clone_box","","",18,N],[11,"from","holochain_core_types::error","",19,[[["t"]],["t"]]],[11,"into","","",19,[[["self"]],["u"]]],[11,"to_owned","","",19,[[["self"]],["t"]]],[11,"clone_into","","",19,N],[11,"to_string","","",19,[[["self"]],["string"]]],[11,"try_from","","",19,[[["u"]],["result"]]],[11,"borrow","","",19,[[["self"]],["t"]]],[11,"get_type_id","","",19,[[["self"]],["typeid"]]],[11,"try_into","","",19,[[["self"]],["result"]]],[11,"borrow_mut","","",19,[[["self"]],["t"]]],[11,"equivalent","","",19,[[["self"],["k"]],["bool"]]],[11,"clone_box","","",19,N],[11,"from","","",20,[[["t"]],["t"]]],[11,"into","","",20,[[["self"]],["u"]]],[11,"to_owned","","",20,[[["self"]],["t"]]],[11,"clone_into","","",20,N],[11,"to_string","","",20,[[["self"]],["string"]]],[11,"try_from","","",20,[[["u"]],["result"]]],[11,"borrow","","",20,[[["self"]],["t"]]],[11,"get_type_id","","",20,[[["self"]],["typeid"]]],[11,"try_into","","",20,[[["self"]],["result"]]],[11,"borrow_mut","","",20,[[["self"]],["t"]]],[11,"clone_box","","",20,N],[11,"from","","",21,[[["t"]],["t"]]],[11,"into","","",21,[[["self"]],["u"]]],[11,"to_owned","","",21,[[["self"]],["t"]]],[11,"clone_into","","",21,N],[11,"to_string","","",21,[[["self"]],["string"]]],[11,"try_from","","",21,[[["u"]],["result"]]],[11,"borrow","","",21,[[["self"]],["t"]]],[11,"get_type_id","","",21,[[["self"]],["typeid"]]],[11,"try_into","","",21,[[["self"]],["result"]]],[11,"borrow_mut","","",21,[[["self"]],["t"]]],[11,"equivalent","","",21,[[["self"],["k"]],["bool"]]],[11,"clone_box","","",21,N],[11,"from","holochain_core_types::error::error","",22,[[["t"]],["t"]]],[11,"into","","",22,[[["self"]],["u"]]],[11,"to_owned","","",22,[[["self"]],["t"]]],[11,"clone_into","","",22,N],[11,"to_string","","",22,[[["self"]],["string"]]],[11,"try_from","","",22,[[["u"]],["result"]]],[11,"borrow","","",22,[[["self"]],["t"]]],[11,"get_type_id","","",22,[[["self"]],["typeid"]]],[11,"try_into","","",22,[[["self"]],["result"]]],[11,"borrow_mut","","",22,[[["self"]],["t"]]],[11,"equivalent","","",22,[[["self"],["k"]],["bool"]]],[11,"clone_box","","",22,N],[11,"from","","",23,[[["t"]],["t"]]],[11,"into","","",23,[[["self"]],["u"]]],[11,"try_from","","",23,[[["u"]],["result"]]],[11,"borrow","","",23,[[["self"]],["t"]]],[11,"get_type_id","","",23,[[["self"]],["typeid"]]],[11,"try_into","","",23,[[["self"]],["result"]]],[11,"borrow_mut","","",23,[[["self"]],["t"]]],[11,"from","","",24,[[["t"]],["t"]]],[11,"into","","",24,[[["self"]],["u"]]],[11,"to_owned","","",24,[[["self"]],["t"]]],[11,"clone_into","","",24,N],[11,"to_string","","",24,[[["self"]],["string"]]],[11,"try_from","","",24,[[["u"]],["result"]]],[11,"borrow","","",24,[[["self"]],["t"]]],[11,"get_type_id","","",24,[[["self"]],["typeid"]]],[11,"try_into","","",24,[[["self"]],["result"]]],[11,"borrow_mut","","",24,[[["self"]],["t"]]],[11,"equivalent","","",24,[[["self"],["k"]],["bool"]]],[11,"clone_box","","",24,N],[11,"from","holochain_core_types::agent","",26,[[["t"]],["t"]]],[11,"into","","",26,[[["self"]],["u"]]],[11,"to_owned","","",26,[[["self"]],["t"]]],[11,"clone_into","","",26,N],[11,"try_from","","",26,[[["u"]],["result"]]],[11,"borrow","","",26,[[["self"]],["t"]]],[11,"get_type_id","","",26,[[["self"]],["typeid"]]],[11,"try_into","","",26,[[["self"]],["result"]]],[11,"borrow_mut","","",26,[[["self"]],["t"]]],[11,"clone_box","","",26,N],[11,"from","","",25,[[["t"]],["t"]]],[11,"into","","",25,[[["self"]],["u"]]],[11,"to_owned","","",25,[[["self"]],["t"]]],[11,"clone_into","","",25,N],[11,"try_from","","",25,[[["u"]],["result"]]],[11,"borrow","","",25,[[["self"]],["t"]]],[11,"get_type_id","","",25,[[["self"]],["typeid"]]],[11,"try_into","","",25,[[["self"]],["result"]]],[11,"borrow_mut","","",25,[[["self"]],["t"]]],[11,"clone_box","","",25,N],[11,"from","holochain_core_types::chain_migrate","",62,[[["t"]],["t"]]],[11,"into","","",62,[[["self"]],["u"]]],[11,"to_owned","","",62,[[["self"]],["t"]]],[11,"clone_into","","",62,N],[11,"try_from","","",62,[[["u"]],["result"]]],[11,"borrow","","",62,[[["self"]],["t"]]],[11,"get_type_id","","",62,[[["self"]],["typeid"]]],[11,"try_into","","",62,[[["self"]],["result"]]],[11,"borrow_mut","","",62,[[["self"]],["t"]]],[11,"clone_box","","",62,N],[11,"from","holochain_core_types::dna::bridges","",27,[[["t"]],["t"]]],[11,"into","","",27,[[["self"]],["u"]]],[11,"to_owned","","",27,[[["self"]],["t"]]],[11,"clone_into","","",27,N],[11,"try_from","","",27,[[["u"]],["result"]]],[11,"borrow","","",27,[[["self"]],["t"]]],[11,"get_type_id","","",27,[[["self"]],["typeid"]]],[11,"try_into","","",27,[[["self"]],["result"]]],[11,"borrow_mut","","",27,[[["self"]],["t"]]],[11,"clone_box","","",27,N],[11,"from","","",28,[[["t"]],["t"]]],[11,"into","","",28,[[["self"]],["u"]]],[11,"to_owned","","",28,[[["self"]],["t"]]],[11,"clone_into","","",28,N],[11,"try_from","","",28,[[["u"]],["result"]]],[11,"borrow","","",28,[[["self"]],["t"]]],[11,"get_type_id","","",28,[[["self"]],["typeid"]]],[11,"try_into","","",28,[[["self"]],["result"]]],[11,"borrow_mut","","",28,[[["self"]],["t"]]],[11,"clone_box","","",28,N],[11,"from","","",29,[[["t"]],["t"]]],[11,"into","","",29,[[["self"]],["u"]]],[11,"to_owned","","",29,[[["self"]],["t"]]],[11,"clone_into","","",29,N],[11,"try_from","","",29,[[["u"]],["result"]]],[11,"borrow","","",29,[[["self"]],["t"]]],[11,"get_type_id","","",29,[[["self"]],["typeid"]]],[11,"try_into","","",29,[[["self"]],["result"]]],[11,"borrow_mut","","",29,[[["self"]],["t"]]],[11,"clone_box","","",29,N],[11,"from","holochain_core_types::dna::capabilities","",63,[[["t"]],["t"]]],[11,"into","","",63,[[["self"]],["u"]]],[11,"to_owned","","",63,[[["self"]],["t"]]],[11,"clone_into","","",63,N],[11,"try_from","","",63,[[["u"]],["result"]]],[11,"borrow","","",63,[[["self"]],["t"]]],[11,"get_type_id","","",63,[[["self"]],["typeid"]]],[11,"try_into","","",63,[[["self"]],["result"]]],[11,"borrow_mut","","",63,[[["self"]],["t"]]],[11,"equivalent","","",63,[[["self"],["k"]],["bool"]]],[11,"clone_box","","",63,N],[11,"from","","",30,[[["t"]],["t"]]],[11,"into","","",30,[[["self"]],["u"]]],[11,"to_owned","","",30,[[["self"]],["t"]]],[11,"clone_into","","",30,N],[11,"try_from","","",30,[[["u"]],["result"]]],[11,"borrow","","",30,[[["self"]],["t"]]],[11,"get_type_id","","",30,[[["self"]],["typeid"]]],[11,"try_into","","",30,[[["self"]],["result"]]],[11,"borrow_mut","","",30,[[["self"]],["t"]]],[11,"equivalent","","",30,[[["self"],["k"]],["bool"]]],[11,"clone_box","","",30,N],[11,"from","","",31,[[["t"]],["t"]]],[11,"into","","",31,[[["self"]],["u"]]],[11,"to_owned","","",31,[[["self"]],["t"]]],[11,"clone_into","","",31,N],[11,"try_from","","",31,[[["u"]],["result"]]],[11,"borrow","","",31,[[["self"]],["t"]]],[11,"get_type_id","","",31,[[["self"]],["typeid"]]],[11,"try_into","","",31,[[["self"]],["result"]]],[11,"borrow_mut","","",31,[[["self"]],["t"]]],[11,"clone_box","","",31,N],[11,"from","","",32,[[["t"]],["t"]]],[11,"into","","",32,[[["self"]],["u"]]],[11,"to_owned","","",32,[[["self"]],["t"]]],[11,"clone_into","","",32,N],[11,"try_from","","",32,[[["u"]],["result"]]],[11,"borrow","","",32,[[["self"]],["t"]]],[11,"get_type_id","","",32,[[["self"]],["typeid"]]],[11,"try_into","","",32,[[["self"]],["result"]]],[11,"borrow_mut","","",32,[[["self"]],["t"]]],[11,"clone_box","","",32,N],[11,"from","","",33,[[["t"]],["t"]]],[11,"into","","",33,[[["self"]],["u"]]],[11,"to_owned","","",33,[[["self"]],["t"]]],[11,"clone_into","","",33,N],[11,"try_from","","",33,[[["u"]],["result"]]],[11,"borrow","","",33,[[["self"]],["t"]]],[11,"get_type_id","","",33,[[["self"]],["typeid"]]],[11,"try_into","","",33,[[["self"]],["result"]]],[11,"borrow_mut","","",33,[[["self"]],["t"]]],[11,"clone_box","","",33,N],[11,"from","","",34,[[["t"]],["t"]]],[11,"into","","",34,[[["self"]],["u"]]],[11,"try_from","","",34,[[["u"]],["result"]]],[11,"borrow","","",34,[[["self"]],["t"]]],[11,"get_type_id","","",34,[[["self"]],["typeid"]]],[11,"try_into","","",34,[[["self"]],["result"]]],[11,"borrow_mut","","",34,[[["self"]],["t"]]],[11,"from","","",35,[[["t"]],["t"]]],[11,"into","","",35,[[["self"]],["u"]]],[11,"to_owned","","",35,[[["self"]],["t"]]],[11,"clone_into","","",35,N],[11,"try_from","","",35,[[["u"]],["result"]]],[11,"borrow","","",35,[[["self"]],["t"]]],[11,"get_type_id","","",35,[[["self"]],["typeid"]]],[11,"try_into","","",35,[[["self"]],["result"]]],[11,"borrow_mut","","",35,[[["self"]],["t"]]],[11,"clone_box","","",35,N],[11,"from","holochain_core_types::dna::dna","",36,[[["t"]],["t"]]],[11,"into","","",36,[[["self"]],["u"]]],[11,"to_owned","","",36,[[["self"]],["t"]]],[11,"clone_into","","",36,N],[11,"try_from","","",36,[[["u"]],["result"]]],[11,"borrow","","",36,[[["self"]],["t"]]],[11,"get_type_id","","",36,[[["self"]],["typeid"]]],[11,"try_into","","",36,[[["self"]],["result"]]],[11,"borrow_mut","","",36,[[["self"]],["t"]]],[11,"clone_box","","",36,N],[11,"from","holochain_core_types::dna::entry_types","",37,[[["t"]],["t"]]],[11,"into","","",37,[[["self"]],["u"]]],[11,"to_owned","","",37,[[["self"]],["t"]]],[11,"clone_into","","",37,N],[11,"try_from","","",37,[[["u"]],["result"]]],[11,"borrow","","",37,[[["self"]],["t"]]],[11,"get_type_id","","",37,[[["self"]],["typeid"]]],[11,"try_into","","",37,[[["self"]],["result"]]],[11,"borrow_mut","","",37,[[["self"]],["t"]]],[11,"clone_box","","",37,N],[11,"from","","",38,[[["t"]],["t"]]],[11,"into","","",38,[[["self"]],["u"]]],[11,"to_owned","","",38,[[["self"]],["t"]]],[11,"clone_into","","",38,N],[11,"try_from","","",38,[[["u"]],["result"]]],[11,"borrow","","",38,[[["self"]],["t"]]],[11,"get_type_id","","",38,[[["self"]],["typeid"]]],[11,"try_into","","",38,[[["self"]],["result"]]],[11,"borrow_mut","","",38,[[["self"]],["t"]]],[11,"clone_box","","",38,N],[11,"from","","",39,[[["t"]],["t"]]],[11,"into","","",39,[[["self"]],["u"]]],[11,"to_owned","","",39,[[["self"]],["t"]]],[11,"clone_into","","",39,N],[11,"try_from","","",39,[[["u"]],["result"]]],[11,"borrow","","",39,[[["self"]],["t"]]],[11,"get_type_id","","",39,[[["self"]],["typeid"]]],[11,"try_into","","",39,[[["self"]],["result"]]],[11,"borrow_mut","","",39,[[["self"]],["t"]]],[11,"clone_box","","",39,N],[11,"from","","",40,[[["t"]],["t"]]],[11,"into","","",40,[[["self"]],["u"]]],[11,"to_owned","","",40,[[["self"]],["t"]]],[11,"clone_into","","",40,N],[11,"try_from","","",40,[[["u"]],["result"]]],[11,"borrow","","",40,[[["self"]],["t"]]],[11,"get_type_id","","",40,[[["self"]],["typeid"]]],[11,"try_into","","",40,[[["self"]],["result"]]],[11,"borrow_mut","","",40,[[["self"]],["t"]]],[11,"clone_box","","",40,N],[11,"from","holochain_core_types::dna::wasm","",41,[[["t"]],["t"]]],[11,"into","","",41,[[["self"]],["u"]]],[11,"to_owned","","",41,[[["self"]],["t"]]],[11,"clone_into","","",41,N],[11,"try_from","","",41,[[["u"]],["result"]]],[11,"borrow","","",41,[[["self"]],["t"]]],[11,"get_type_id","","",41,[[["self"]],["typeid"]]],[11,"try_into","","",41,[[["self"]],["result"]]],[11,"borrow_mut","","",41,[[["self"]],["t"]]],[11,"clone_box","","",41,N],[11,"from","holochain_core_types::dna::zome","",42,[[["t"]],["t"]]],[11,"into","","",42,[[["self"]],["u"]]],[11,"to_owned","","",42,[[["self"]],["t"]]],[11,"clone_into","","",42,N],[11,"try_from","","",42,[[["u"]],["result"]]],[11,"borrow","","",42,[[["self"]],["t"]]],[11,"get_type_id","","",42,[[["self"]],["typeid"]]],[11,"try_into","","",42,[[["self"]],["result"]]],[11,"borrow_mut","","",42,[[["self"]],["t"]]],[11,"clone_box","","",42,N],[11,"from","","",43,[[["t"]],["t"]]],[11,"into","","",43,[[["self"]],["u"]]],[11,"to_owned","","",43,[[["self"]],["t"]]],[11,"clone_into","","",43,N],[11,"try_from","","",43,[[["u"]],["result"]]],[11,"borrow","","",43,[[["self"]],["t"]]],[11,"get_type_id","","",43,[[["self"]],["typeid"]]],[11,"try_into","","",43,[[["self"]],["result"]]],[11,"borrow_mut","","",43,[[["self"]],["t"]]],[11,"equivalent","","",43,[[["self"],["k"]],["bool"]]],[11,"clone_box","","",43,N],[11,"from","","",44,[[["t"]],["t"]]],[11,"into","","",44,[[["self"]],["u"]]],[11,"to_owned","","",44,[[["self"]],["t"]]],[11,"clone_into","","",44,N],[11,"try_from","","",44,[[["u"]],["result"]]],[11,"borrow","","",44,[[["self"]],["t"]]],[11,"get_type_id","","",44,[[["self"]],["typeid"]]],[11,"try_into","","",44,[[["self"]],["result"]]],[11,"borrow_mut","","",44,[[["self"]],["t"]]],[11,"clone_box","","",44,N],[11,"from","holochain_core_types::hash","",45,[[["t"]],["t"]]],[11,"into","","",45,[[["self"]],["u"]]],[11,"to_owned","","",45,[[["self"]],["t"]]],[11,"clone_into","","",45,N],[11,"to_string","","",45,[[["self"]],["string"]]],[11,"try_from","","",45,[[["u"]],["result"]]],[11,"borrow","","",45,[[["self"]],["t"]]],[11,"get_type_id","","",45,[[["self"]],["typeid"]]],[11,"try_into","","",45,[[["self"]],["result"]]],[11,"borrow_mut","","",45,[[["self"]],["t"]]],[11,"equivalent","","",45,[[["self"],["k"]],["bool"]]],[11,"clone_box","","",45,N],[11,"from","holochain_core_types::json","",46,[[["t"]],["t"]]],[11,"into","","",46,[[["self"]],["u"]]],[11,"to_owned","","",46,[[["self"]],["t"]]],[11,"clone_into","","",46,N],[11,"to_string","","",46,[[["self"]],["string"]]],[11,"try_from","","",46,[[["u"]],["result"]]],[11,"borrow","","",46,[[["self"]],["t"]]],[11,"get_type_id","","",46,[[["self"]],["typeid"]]],[11,"try_into","","",46,[[["self"]],["result"]]],[11,"borrow_mut","","",46,[[["self"]],["t"]]],[11,"equivalent","","",46,[[["self"],["k"]],["bool"]]],[11,"clone_box","","",46,N],[11,"from","","",64,[[["t"]],["t"]]],[11,"into","","",64,[[["self"]],["u"]]],[11,"to_owned","","",64,[[["self"]],["t"]]],[11,"clone_into","","",64,N],[11,"try_from","","",64,[[["u"]],["result"]]],[11,"borrow","","",64,[[["self"]],["t"]]],[11,"get_type_id","","",64,[[["self"]],["typeid"]]],[11,"try_into","","",64,[[["self"]],["result"]]],[11,"borrow_mut","","",64,[[["self"]],["t"]]],[11,"clone_box","","",64,N],[11,"from","holochain_core_types::keys","",47,[[["t"]],["t"]]],[11,"into","","",47,[[["self"]],["u"]]],[11,"to_owned","","",47,[[["self"]],["t"]]],[11,"clone_into","","",47,N],[11,"try_from","","",47,[[["u"]],["result"]]],[11,"borrow","","",47,[[["self"]],["t"]]],[11,"get_type_id","","",47,[[["self"]],["typeid"]]],[11,"try_into","","",47,[[["self"]],["result"]]],[11,"borrow_mut","","",47,[[["self"]],["t"]]],[11,"clone_box","","",47,N],[11,"from","","",48,[[["t"]],["t"]]],[11,"into","","",48,[[["self"]],["u"]]],[11,"to_owned","","",48,[[["self"]],["t"]]],[11,"clone_into","","",48,N],[11,"try_from","","",48,[[["u"]],["result"]]],[11,"borrow","","",48,[[["self"]],["t"]]],[11,"get_type_id","","",48,[[["self"]],["typeid"]]],[11,"try_into","","",48,[[["self"]],["result"]]],[11,"borrow_mut","","",48,[[["self"]],["t"]]],[11,"clone_box","","",48,N],[11,"from","holochain_core_types::link","",52,[[["t"]],["t"]]],[11,"into","","",52,[[["self"]],["u"]]],[11,"to_owned","","",52,[[["self"]],["t"]]],[11,"clone_into","","",52,N],[11,"try_from","","",52,[[["u"]],["result"]]],[11,"borrow","","",52,[[["self"]],["t"]]],[11,"get_type_id","","",52,[[["self"]],["typeid"]]],[11,"try_into","","",52,[[["self"]],["result"]]],[11,"borrow_mut","","",52,[[["self"]],["t"]]],[11,"equivalent","","",52,[[["self"],["k"]],["bool"]]],[11,"clone_box","","",52,N],[11,"from","","",49,[[["t"]],["t"]]],[11,"into","","",49,[[["self"]],["u"]]],[11,"to_owned","","",49,[[["self"]],["t"]]],[11,"clone_into","","",49,N],[11,"try_from","","",49,[[["u"]],["result"]]],[11,"borrow","","",49,[[["self"]],["t"]]],[11,"get_type_id","","",49,[[["self"]],["typeid"]]],[11,"try_into","","",49,[[["self"]],["result"]]],[11,"borrow_mut","","",49,[[["self"]],["t"]]],[11,"clone_box","","",49,N],[11,"from","holochain_core_types::link::link_add","",50,[[["t"]],["t"]]],[11,"into","","",50,[[["self"]],["u"]]],[11,"to_owned","","",50,[[["self"]],["t"]]],[11,"clone_into","","",50,N],[11,"try_from","","",50,[[["u"]],["result"]]],[11,"borrow","","",50,[[["self"]],["t"]]],[11,"get_type_id","","",50,[[["self"]],["typeid"]]],[11,"try_into","","",50,[[["self"]],["result"]]],[11,"borrow_mut","","",50,[[["self"]],["t"]]],[11,"clone_box","","",50,N],[11,"from","holochain_core_types::link::link_list","",51,[[["t"]],["t"]]],[11,"into","","",51,[[["self"]],["u"]]],[11,"to_owned","","",51,[[["self"]],["t"]]],[11,"clone_into","","",51,N],[11,"try_from","","",51,[[["u"]],["result"]]],[11,"borrow","","",51,[[["self"]],["t"]]],[11,"get_type_id","","",51,[[["self"]],["typeid"]]],[11,"try_into","","",51,[[["self"]],["result"]]],[11,"borrow_mut","","",51,[[["self"]],["t"]]],[11,"clone_box","","",51,N],[11,"from","holochain_core_types::link::link_remove","",65,[[["t"]],["t"]]],[11,"into","","",65,[[["self"]],["u"]]],[11,"to_owned","","",65,[[["self"]],["t"]]],[11,"clone_into","","",65,N],[11,"try_from","","",65,[[["u"]],["result"]]],[11,"borrow","","",65,[[["self"]],["t"]]],[11,"get_type_id","","",65,[[["self"]],["typeid"]]],[11,"try_into","","",65,[[["self"]],["result"]]],[11,"borrow_mut","","",65,[[["self"]],["t"]]],[11,"clone_box","","",65,N],[11,"from","holochain_core_types::signature","",66,[[["t"]],["t"]]],[11,"into","","",66,[[["self"]],["u"]]],[11,"to_owned","","",66,[[["self"]],["t"]]],[11,"clone_into","","",66,N],[11,"try_from","","",66,[[["u"]],["result"]]],[11,"borrow","","",66,[[["self"]],["t"]]],[11,"get_type_id","","",66,[[["self"]],["typeid"]]],[11,"try_into","","",66,[[["self"]],["result"]]],[11,"borrow_mut","","",66,[[["self"]],["t"]]],[11,"clone_box","","",66,N],[11,"from","holochain_core_types::time","",67,[[["t"]],["t"]]],[11,"into","","",67,[[["self"]],["u"]]],[11,"to_owned","","",67,[[["self"]],["t"]]],[11,"clone_into","","",67,N],[11,"try_from","","",67,[[["u"]],["result"]]],[11,"borrow","","",67,[[["self"]],["t"]]],[11,"get_type_id","","",67,[[["self"]],["typeid"]]],[11,"try_into","","",67,[[["self"]],["result"]]],[11,"borrow_mut","","",67,[[["self"]],["t"]]],[11,"clone_box","","",67,N],[11,"from","holochain_core_types::validation","",53,[[["t"]],["t"]]],[11,"into","","",53,[[["self"]],["u"]]],[11,"to_owned","","",53,[[["self"]],["t"]]],[11,"clone_into","","",53,N],[11,"try_from","","",53,[[["u"]],["result"]]],[11,"borrow","","",53,[[["self"]],["t"]]],[11,"get_type_id","","",53,[[["self"]],["typeid"]]],[11,"try_into","","",53,[[["self"]],["result"]]],[11,"borrow_mut","","",53,[[["self"]],["t"]]],[11,"clone_box","","",53,N],[11,"from","","",54,[[["t"]],["t"]]],[11,"into","","",54,[[["self"]],["u"]]],[11,"to_owned","","",54,[[["self"]],["t"]]],[11,"clone_into","","",54,N],[11,"try_from","","",54,[[["u"]],["result"]]],[11,"borrow","","",54,[[["self"]],["t"]]],[11,"get_type_id","","",54,[[["self"]],["typeid"]]],[11,"try_into","","",54,[[["self"]],["result"]]],[11,"borrow_mut","","",54,[[["self"]],["t"]]],[11,"clone_box","","",54,N],[11,"from","","",55,[[["t"]],["t"]]],[11,"into","","",55,[[["self"]],["u"]]],[11,"to_owned","","",55,[[["self"]],["t"]]],[11,"clone_into","","",55,N],[11,"try_from","","",55,[[["u"]],["result"]]],[11,"borrow","","",55,[[["self"]],["t"]]],[11,"get_type_id","","",55,[[["self"]],["typeid"]]],[11,"try_into","","",55,[[["self"]],["result"]]],[11,"borrow_mut","","",55,[[["self"]],["t"]]],[11,"clone_box","","",55,N],[11,"from","","",56,[[["t"]],["t"]]],[11,"into","","",56,[[["self"]],["u"]]],[11,"to_owned","","",56,[[["self"]],["t"]]],[11,"clone_into","","",56,N],[11,"try_from","","",56,[[["u"]],["result"]]],[11,"borrow","","",56,[[["self"]],["t"]]],[11,"get_type_id","","",56,[[["self"]],["typeid"]]],[11,"try_into","","",56,[[["self"]],["result"]]],[11,"borrow_mut","","",56,[[["self"]],["t"]]],[11,"clone_box","","",56,N],[11,"from","","",57,[[["t"]],["t"]]],[11,"into","","",57,[[["self"]],["u"]]],[11,"to_owned","","",57,[[["self"]],["t"]]],[11,"clone_into","","",57,N],[11,"try_from","","",57,[[["u"]],["result"]]],[11,"borrow","","",57,[[["self"]],["t"]]],[11,"get_type_id","","",57,[[["self"]],["typeid"]]],[11,"try_into","","",57,[[["self"]],["result"]]],[11,"borrow_mut","","",57,[[["self"]],["t"]]],[11,"clone_box","","",57,N],[11,"from","","",58,[[["t"]],["t"]]],[11,"into","","",58,[[["self"]],["u"]]],[11,"to_owned","","",58,[[["self"]],["t"]]],[11,"clone_into","","",58,N],[11,"try_from","","",58,[[["u"]],["result"]]],[11,"borrow","","",58,[[["self"]],["t"]]],[11,"get_type_id","","",58,[[["self"]],["typeid"]]],[11,"try_into","","",58,[[["self"]],["result"]]],[11,"borrow_mut","","",58,[[["self"]],["t"]]],[11,"clone_box","","",58,N],[11,"content","holochain_core_types","",68,[[["self"]],["content"]]],[11,"try_from_content","","",68,[[["content"]],["result",["holochainerror"]]]],[11,"content","holochain_core_types::cas::content","",59,[[["self"]],["content"]]],[11,"try_from_content","","",59,[[["content"]],["result",["holochainerror"]]]],[11,"address","","",60,[[["self"]],["address"]]],[11,"content","","",60,[[["self"]],["content"]]],[11,"try_from_content","","",60,[[["content"]],["result",["holochainerror"]]]],[11,"content","holochain_core_types::chain_header","",7,[[["self"]],["content"]]],[11,"try_from_content","","",7,[[["content"]],["result",["holochainerror"]]]],[11,"content","holochain_core_types::crud_status","",8,[[["self"]],["content"]]],[11,"try_from_content","","",8,[[["content"]],["result",["holochainerror"]]]],[11,"content","holochain_core_types::eav","",10,[[["self"]],["content"]]],[11,"try_from_content","","",10,[[["content"]],["result",["holochainerror"]]]],[11,"address","holochain_core_types::entry","",14,[[["self"]],["address"]]],[11,"content","","",14,[[["self"]],["content"]]],[11,"try_from_content","","",14,[[["content"]],["hcresult",["entry"]]]],[11,"address","holochain_core_types::agent","for an Agent, the address is their public base64url encoded itentity string",25,[[["self"]],["address"]]],[11,"content","","get the entry content",25,[[["self"]],["content"]]],[11,"try_from_content","","",25,[[["content"]],["hcresult"]]],[11,"add","holochain_core_types::cas::storage","",4,[[["self"],["addressablecontent"]],["result",["holochainerror"]]]],[11,"contains","","",4,[[["self"],["address"]],["result",["bool","holochainerror"]]]],[11,"fetch","","",4,[[["self"],["address"]],["result",["option","holochainerror"]]]],[11,"get_id","","",4,[[["self"]],["uuid"]]],[11,"add_eav","holochain_core_types::eav","",12,[[["self"],["entityattributevalue"]],["hcresult"]]],[11,"fetch_eav","","",12,[[["self"],["option",["entity"]],["option",["attribute"]],["option",["value"]]],["result",["hashset","holochainerror"]]]],[11,"cmp","holochain_core_types::entry::entry_type","",61,[[["self"],["appentrytype"]],["ordering"]]],[11,"cmp","","",18,[[["self"],["entrytype"]],["ordering"]]],[11,"cmp","holochain_core_types::hash","",45,[[["self"],["hashstring"]],["ordering"]]],[11,"eq","holochain_core_types::cas::content","",59,[[["self"],["exampleaddressablecontent"]],["bool"]]],[11,"ne","","",59,[[["self"],["exampleaddressablecontent"]],["bool"]]],[11,"eq","","",60,[[["self"],["otherexampleaddressablecontent"]],["bool"]]],[11,"ne","","",60,[[["self"],["otherexampleaddressablecontent"]],["bool"]]],[11,"eq","holochain_core_types::cas::storage","",3,[[["self"],["contentaddressablestorage"]],["bool"]]],[11,"eq","holochain_core_types::chain_header","",7,[[["self"],["chainheader"]],["bool"]]],[11,"eq","holochain_core_types::crud_status","",8,[[["self"],["crudstatus"]],["bool"]]],[11,"eq","holochain_core_types::eav","",10,[[["self"],["entityattributevalue"]],["bool"]]],[11,"ne","","",10,[[["self"],["entityattributevalue"]],["bool"]]],[11,"eq","","",9,[[["self"],["entityattributevaluestorage"]],["bool"]]],[11,"eq","holochain_core_types::entry::cap_entries","",15,[[["self"],["captoken"]],["bool"]]],[11,"ne","","",15,[[["self"],["captoken"]],["bool"]]],[11,"eq","","",16,[[["self"],["captokengrant"]],["bool"]]],[11,"ne","","",16,[[["self"],["captokengrant"]],["bool"]]],[11,"eq","holochain_core_types::entry::deletion_entry","",17,[[["self"],["deletionentry"]],["bool"]]],[11,"ne","","",17,[[["self"],["deletionentry"]],["bool"]]],[11,"eq","holochain_core_types::entry::entry_type","",61,[[["self"],["appentrytype"]],["bool"]]],[11,"ne","","",61,[[["self"],["appentrytype"]],["bool"]]],[11,"eq","","",18,[[["self"],["entrytype"]],["bool"]]],[11,"ne","","",18,[[["self"],["entrytype"]],["bool"]]],[11,"eq","holochain_core_types::entry","",14,[[["self"],["entry"]],["bool"]]],[11,"eq","","",13,[[["self"],["entrywithmeta"]],["bool"]]],[11,"ne","","",13,[[["self"],["entrywithmeta"]],["bool"]]],[11,"eq","holochain_core_types::error","",19,[[["self"],["dnaerror"]],["bool"]]],[11,"ne","","",19,[[["self"],["dnaerror"]],["bool"]]],[11,"eq","holochain_core_types::error::error","",22,[[["self"],["coreerror"]],["bool"]]],[11,"ne","","",22,[[["self"],["coreerror"]],["bool"]]],[11,"eq","","",24,[[["self"],["holochainerror"]],["bool"]]],[11,"ne","","",24,[[["self"],["holochainerror"]],["bool"]]],[11,"eq","holochain_core_types::error","",20,[[["self"],["ribosomereturncode"]],["bool"]]],[11,"ne","","",20,[[["self"],["ribosomereturncode"]],["bool"]]],[11,"eq","","",21,[[["self"],["ribosomeerrorcode"]],["bool"]]],[11,"eq","holochain_core_types::agent","",25,[[["self"],["agentid"]],["bool"]]],[11,"ne","","",25,[[["self"],["agentid"]],["bool"]]],[11,"eq","holochain_core_types::dna::bridges","",27,[[["self"],["bridge"]],["bool"]]],[11,"ne","","",27,[[["self"],["bridge"]],["bool"]]],[11,"eq","","",28,[[["self"],["bridgereference"]],["bool"]]],[11,"ne","","",28,[[["self"],["bridgereference"]],["bool"]]],[11,"eq","","",29,[[["self"],["bridgepresence"]],["bool"]]],[11,"eq","holochain_core_types::dna::capabilities","",34,[[["self"],["reservedcapabilitynames"]],["bool"]]],[11,"eq","","",63,[[["self"],["callsignature"]],["bool"]]],[11,"eq","","",30,[[["self"],["capabilitycall"]],["bool"]]],[11,"ne","","",30,[[["self"],["capabilitycall"]],["bool"]]],[11,"eq","","",35,[[["self"],["capabilitytype"]],["bool"]]],[11,"eq","","",31,[[["self"],["fnparameter"]],["bool"]]],[11,"ne","","",31,[[["self"],["fnparameter"]],["bool"]]],[11,"eq","","",32,[[["self"],["fndeclaration"]],["bool"]]],[11,"ne","","",32,[[["self"],["fndeclaration"]],["bool"]]],[11,"eq","","",33,[[["self"],["capability"]],["bool"]]],[11,"ne","","",33,[[["self"],["capability"]],["bool"]]],[11,"eq","holochain_core_types::dna::dna","",36,[[["self"],["dna"]],["bool"]]],[11,"eq","holochain_core_types::dna::entry_types","",40,[[["self"],["sharing"]],["bool"]]],[11,"eq","","",37,[[["self"],["linksto"]],["bool"]]],[11,"ne","","",37,[[["self"],["linksto"]],["bool"]]],[11,"eq","","",38,[[["self"],["linkedfrom"]],["bool"]]],[11,"ne","","",38,[[["self"],["linkedfrom"]],["bool"]]],[11,"eq","","",39,[[["self"],["entrytypedef"]],["bool"]]],[11,"ne","","",39,[[["self"],["entrytypedef"]],["bool"]]],[11,"eq","holochain_core_types::dna::wasm","",41,[[["self"],["dnawasm"]],["bool"]]],[11,"ne","","",41,[[["self"],["dnawasm"]],["bool"]]],[11,"eq","holochain_core_types::dna::zome","",44,[[["self"],["errorhandling"]],["bool"]]],[11,"eq","","",42,[[["self"],["config"]],["bool"]]],[11,"ne","","",42,[[["self"],["config"]],["bool"]]],[11,"eq","","",43,[[["self"],["zome"]],["bool"]]],[11,"ne","","",43,[[["self"],["zome"]],["bool"]]],[11,"eq","holochain_core_types::hash","",45,[[["self"],["hashstring"]],["bool"]]],[11,"ne","","",45,[[["self"],["hashstring"]],["bool"]]],[11,"eq","holochain_core_types::json","",46,[[["self"],["jsonstring"]],["bool"]]],[11,"ne","","",46,[[["self"],["jsonstring"]],["bool"]]],[11,"eq","","",64,[[["self"],["rawstring"]],["bool"]]],[11,"ne","","",64,[[["self"],["rawstring"]],["bool"]]],[11,"eq","holochain_core_types::keys","",47,[[["self"],["key"]],["bool"]]],[11,"eq","","",48,[[["self"],["keys"]],["bool"]]],[11,"ne","","",48,[[["self"],["keys"]],["bool"]]],[11,"eq","holochain_core_types::link::link_add","",50,[[["self"],["linkadd"]],["bool"]]],[11,"ne","","",50,[[["self"],["linkadd"]],["bool"]]],[11,"eq","holochain_core_types::link::link_list","",51,[[["self"],["linklist"]],["bool"]]],[11,"ne","","",51,[[["self"],["linklist"]],["bool"]]],[11,"eq","holochain_core_types::link","",52,[[["self"],["link"]],["bool"]]],[11,"ne","","",52,[[["self"],["link"]],["bool"]]],[11,"eq","","",49,[[["self"],["linkactionkind"]],["bool"]]],[11,"eq","holochain_core_types::signature","",66,[[["self"],["signature"]],["bool"]]],[11,"ne","","",66,[[["self"],["signature"]],["bool"]]],[11,"eq","holochain_core_types::time","",67,[[["self"],["iso8601"]],["bool"]]],[11,"ne","","",67,[[["self"],["iso8601"]],["bool"]]],[11,"eq","holochain_core_types::validation","",53,[[["self"],["validationpackage"]],["bool"]]],[11,"ne","","",53,[[["self"],["validationpackage"]],["bool"]]],[11,"eq","","",55,[[["self"],["validationpackagedefinition"]],["bool"]]],[11,"ne","","",55,[[["self"],["validationpackagedefinition"]],["bool"]]],[11,"from","holochain_core_types::json","",46,[[["chainheader"]],["jsonstring"]]],[11,"from","","",46,[[["chainheader"]],["jsonstring"]]],[11,"from","","",46,[[["crudstatus"]],["jsonstring"]]],[11,"from","","",46,[[["crudstatus"]],["jsonstring"]]],[11,"from","","",46,[[["entityattributevalue"]],["jsonstring"]]],[11,"from","","",46,[[["entityattributevalue"]],["jsonstring"]]],[11,"from","","",46,[[["captoken"]],["jsonstring"]]],[11,"from","","",46,[[["captoken"]],["jsonstring"]]],[11,"from","","",46,[[["captokengrant"]],["jsonstring"]]],[11,"from","","",46,[[["captokengrant"]],["jsonstring"]]],[11,"from","","",46,[[["deletionentry"]],["jsonstring"]]],[11,"from","","",46,[[["deletionentry"]],["jsonstring"]]],[11,"from","holochain_core_types::entry::entry_type","",61,[[["str"]],["self"]]],[11,"from","","",61,[[["string"]],["self"]]],[11,"from","holochain_core_types::json","",46,[[["entrytype"]],["jsonstring"]]],[11,"from","","",46,[[["entrytype"]],["jsonstring"]]],[11,"from","holochain_core_types::entry::entry_type","",18,[[["appentrytype"]],["self"]]],[11,"from","","",18,[[["string"]],["entrytype"]]],[11,"from","","",18,[[["str"]],["entrytype"]]],[11,"from","holochain_core_types::json","",46,[[["entry"]],["jsonstring"]]],[11,"from","","",46,[[["entry"]],["jsonstring"]]],[11,"from","","",46,[[["option",["entry"]]],["self"]]],[11,"from","","",46,[[["entrywithmeta"]],["jsonstring"]]],[11,"from","","",46,[[["entrywithmeta"]],["jsonstring"]]],[11,"from","","",46,[[["coreerror"]],["jsonstring"]]],[11,"from","","",46,[[["coreerror"]],["jsonstring"]]],[11,"from","","",46,[[["holochainerror"]],["jsonstring"]]],[11,"from","","",46,[[["holochainerror"]],["jsonstring"]]],[11,"from","holochain_core_types::error::error","",24,[[["string"]],["self"]]],[11,"from","","",24,[[["str"]],["self"]]],[11,"from","","",24,[[["poisonerror"]],["self"]]],[11,"from","","",24,[[["ioerror"]],["self"]]],[11,"from","","",24,[[["serdeerror"]],["self"]]],[11,"from","","",24,[[["decodeerror"]],["self"]]],[11,"from","","",24,[[["decodererror"]],["self"]]],[11,"from","","",24,[[["futurecanceled"]],["self"]]],[11,"from","holochain_core_types::json","",46,[[["zomeapiinternalresult"]],["jsonstring"]]],[11,"from","","",46,[[["zomeapiinternalresult"]],["jsonstring"]]],[11,"from","","",46,[[["ribosomereturncode"]],["jsonstring"]]],[11,"from","","",46,[[["ribosomeerrorcode"]],["jsonstring"]]],[11,"from","","",46,[[["ribosomeerrorcode"]],["jsonstring"]]],[11,"from","","",46,[[["agentid"]],["jsonstring"]]],[11,"from","","",46,[[["agentid"]],["jsonstring"]]],[11,"from","","",46,[[["dna"]],["jsonstring"]]],[11,"from","","",46,[[["dna"]],["jsonstring"]]],[11,"from","","",46,[[["entrytypedef"]],["jsonstring"]]],[11,"from","","",46,[[["entrytypedef"]],["jsonstring"]]],[11,"from","","",46,[[["zome"]],["jsonstring"]]],[11,"from","","",46,[[["zome"]],["jsonstring"]]],[11,"from","","",46,[[["hashstring"]],["jsonstring"]]],[11,"from","","",46,[[["hashstring"]],["jsonstring"]]],[11,"from","holochain_core_types::hash","",45,[[["string"]],["hashstring"]]],[11,"from","","",45,[[["str"]],["hashstring"]]],[11,"from","holochain_core_types::json","",46,[[["string"]],["jsonstring"]]],[11,"from","","",46,[[["u32"]],["jsonstring"]]],[11,"from","","",46,[[["value"]],["jsonstring"]]],[11,"from","","",46,[[["str"]],["jsonstring"]]],[11,"from","","",46,[[["vec"]],["jsonstring"]]],[11,"from","","",46,[[["result"]],["jsonstring"]]],[11,"from","","",46,[[["result",["string"]]],["jsonstring"]]],[11,"from","","",46,N],[11,"from","","",64,[[["str"]],["rawstring"]]],[11,"from","","",64,[[["string"]],["rawstring"]]],[11,"from","","",64,[[["f64"]],["rawstring"]]],[11,"from","","",64,[[["i32"]],["rawstring"]]],[11,"from","","",46,[[["rawstring"]],["jsonstring"]]],[11,"from","","",46,[[["linkadd"]],["jsonstring"]]],[11,"from","","",46,[[["linkadd"]],["jsonstring"]]],[11,"from","","",46,[[["linklist"]],["jsonstring"]]],[11,"from","","",46,[[["linklist"]],["jsonstring"]]],[11,"from","","",46,[[["link"]],["jsonstring"]]],[11,"from","","",46,[[["link"]],["jsonstring"]]],[11,"from","holochain_core_types::signature","",66,[[["str"]],["signature"]]],[11,"from","holochain_core_types::time","",67,[[["str"]],["iso8601"]]],[11,"from","holochain_core_types::json","",46,[[["validationpackage"]],["jsonstring"]]],[11,"from","","",46,[[["validationpackage"]],["jsonstring"]]],[11,"from","","",46,[[["validationpackagedefinition"]],["jsonstring"]]],[11,"from","","",46,[[["validationpackagedefinition"]],["jsonstring"]]],[11,"clone","holochain_core_types::cas::content","",59,[[["self"]],["exampleaddressablecontent"]]],[11,"clone","","",60,[[["self"]],["otherexampleaddressablecontent"]]],[11,"clone","holochain_core_types::cas::storage","",4,[[["self"]],["examplecontentaddressablestorage"]]],[11,"clone","holochain_core_types::chain_header","",7,[[["self"]],["chainheader"]]],[11,"clone","holochain_core_types::crud_status","",8,[[["self"]],["crudstatus"]]],[11,"clone","holochain_core_types::eav","",10,[[["self"]],["entityattributevalue"]]],[11,"clone","","",11,[[["self"]],["exampleentityattributevaluestoragenonsync"]]],[11,"clone","","",12,[[["self"]],["exampleentityattributevaluestorage"]]],[11,"clone","holochain_core_types::entry::cap_entries","",15,[[["self"]],["captoken"]]],[11,"clone","","",16,[[["self"]],["captokengrant"]]],[11,"clone","holochain_core_types::entry::deletion_entry","",17,[[["self"]],["deletionentry"]]],[11,"clone","holochain_core_types::entry::entry_type","",61,[[["self"]],["appentrytype"]]],[11,"clone","","",18,[[["self"]],["entrytype"]]],[11,"clone","holochain_core_types::entry","",14,[[["self"]],["entry"]]],[11,"clone","","",13,[[["self"]],["entrywithmeta"]]],[11,"clone","holochain_core_types::error","",19,[[["self"]],["dnaerror"]]],[11,"clone","holochain_core_types::error::error","",22,[[["self"]],["coreerror"]]],[11,"clone","","",24,[[["self"]],["holochainerror"]]],[11,"clone","holochain_core_types::error","",20,[[["self"]],["ribosomereturncode"]]],[11,"clone","","",21,[[["self"]],["ribosomeerrorcode"]]],[11,"clone","holochain_core_types::agent","",26,[[["self"]],["keybuffer"]]],[11,"clone","","",25,[[["self"]],["agentid"]]],[11,"clone","holochain_core_types::chain_migrate","",62,[[["self"]],["chainmigrate"]]],[11,"clone","holochain_core_types::dna::bridges","",27,[[["self"]],["bridge"]]],[11,"clone","","",28,[[["self"]],["bridgereference"]]],[11,"clone","","",29,[[["self"]],["bridgepresence"]]],[11,"clone","holochain_core_types::dna::capabilities","",63,[[["self"]],["callsignature"]]],[11,"clone","","",30,[[["self"]],["capabilitycall"]]],[11,"clone","","",35,[[["self"]],["capabilitytype"]]],[11,"clone","","",31,[[["self"]],["fnparameter"]]],[11,"clone","","",32,[[["self"]],["fndeclaration"]]],[11,"clone","","",33,[[["self"]],["capability"]]],[11,"clone","holochain_core_types::dna::dna","",36,[[["self"]],["dna"]]],[11,"clone","holochain_core_types::dna::entry_types","",40,[[["self"]],["sharing"]]],[11,"clone","","",37,[[["self"]],["linksto"]]],[11,"clone","","",38,[[["self"]],["linkedfrom"]]],[11,"clone","","",39,[[["self"]],["entrytypedef"]]],[11,"clone","holochain_core_types::dna::wasm","",41,[[["self"]],["dnawasm"]]],[11,"clone","holochain_core_types::dna::zome","",44,[[["self"]],["errorhandling"]]],[11,"clone","","",42,[[["self"]],["config"]]],[11,"clone","","",43,[[["self"]],["zome"]]],[11,"clone","holochain_core_types::hash","",45,[[["self"]],["hashstring"]]],[11,"clone","holochain_core_types::json","",46,[[["self"]],["jsonstring"]]],[11,"clone","","",64,[[["self"]],["rawstring"]]],[11,"clone","holochain_core_types::keys","",47,[[["self"]],["key"]]],[11,"clone","","",48,[[["self"]],["keys"]]],[11,"clone","holochain_core_types::link::link_add","",50,[[["self"]],["linkadd"]]],[11,"clone","holochain_core_types::link::link_list","",51,[[["self"]],["linklist"]]],[11,"clone","holochain_core_types::link::link_remove","",65,[[["self"]],["linkremove"]]],[11,"clone","holochain_core_types::link","",52,[[["self"]],["link"]]],[11,"clone","","",49,[[["self"]],["linkactionkind"]]],[11,"clone","holochain_core_types::signature","",66,[[["self"]],["signature"]]],[11,"clone","holochain_core_types::time","",67,[[["self"]],["iso8601"]]],[11,"clone","holochain_core_types::validation","",53,[[["self"]],["validationpackage"]]],[11,"clone","","",55,[[["self"]],["validationpackagedefinition"]]],[11,"clone","","",54,[[["self"]],["validationdata"]]],[11,"clone","","",56,[[["self"]],["entrylifecycle"]]],[11,"clone","","",57,[[["self"]],["entryaction"]]],[11,"clone","","",58,[[["self"]],["linkaction"]]],[11,"partial_cmp","holochain_core_types::entry::entry_type","",61,[[["self"],["appentrytype"]],["option",["ordering"]]]],[11,"lt","","",61,[[["self"],["appentrytype"]],["bool"]]],[11,"le","","",61,[[["self"],["appentrytype"]],["bool"]]],[11,"gt","","",61,[[["self"],["appentrytype"]],["bool"]]],[11,"ge","","",61,[[["self"],["appentrytype"]],["bool"]]],[11,"partial_cmp","","",18,[[["self"],["entrytype"]],["option",["ordering"]]]],[11,"lt","","",18,[[["self"],["entrytype"]],["bool"]]],[11,"le","","",18,[[["self"],["entrytype"]],["bool"]]],[11,"gt","","",18,[[["self"],["entrytype"]],["bool"]]],[11,"ge","","",18,[[["self"],["entrytype"]],["bool"]]],[11,"partial_cmp","holochain_core_types::hash","",45,[[["self"],["hashstring"]],["option",["ordering"]]]],[11,"lt","","",45,[[["self"],["hashstring"]],["bool"]]],[11,"le","","",45,[[["self"],["hashstring"]],["bool"]]],[11,"gt","","",45,[[["self"],["hashstring"]],["bool"]]],[11,"ge","","",45,[[["self"],["hashstring"]],["bool"]]],[11,"to_string","holochain_core_types::entry::entry_type","",61,[[["self"]],["string"]]],[11,"to_string","holochain_core_types::error","",20,[[["self"]],["string"]]],[11,"to_string","","",21,[[["self"]],["string"]]],[11,"default","holochain_core_types::crud_status","",8,[[],["crudstatus"]]],[11,"default","holochain_core_types::error::error","",23,[[],["zomeapiinternalresult"]]],[11,"default","holochain_core_types::dna::capabilities","Defaults for a \"fn_declarations\" object.",32,[[],["self"]]],[11,"default","","Provide defaults for a Capability object",33,[[],["self"]]],[11,"default","holochain_core_types::dna::dna","Provide defaults for a dna object.",36,[[],["self"]]],[11,"default","holochain_core_types::dna::entry_types","Default zome entry_type sharing is \"public\"",40,[[],["self"]]],[11,"default","","Provide defaults for a \"links_to\" object.",37,[[],["self"]]],[11,"default","","Provide defaults for a \"links_to\" object.",38,[[],["self"]]],[11,"default","","",39,[[],["entrytypedef"]]],[11,"default","holochain_core_types::dna::wasm","Provide defaults for wasm entries in dna structs.",41,[[],["self"]]],[11,"default","holochain_core_types::dna::zome","Default zome config error_handling is \"throw-errors\"",44,[[],["self"]]],[11,"default","","Provide defaults for the \"zome\" \"config\" object.",42,[[],["self"]]],[11,"default","","Provide defaults for an individual \"zome\".",43,[[],["self"]]],[11,"default","holochain_core_types::hash","",45,[[],["hashstring"]]],[11,"default","holochain_core_types::keys","",47,[[],["key"]]],[11,"default","","",48,[[],["keys"]]],[11,"default","holochain_core_types::validation","",53,[[],["validationpackage"]]],[11,"default","","",54,[[],["validationdata"]]],[11,"default","","",56,[[],["self"]]],[11,"default","","",57,[[],["self"]]],[11,"fmt","holochain_core_types::cas::content","",59,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",60,[[["self"],["formatter"]],["result"]]],[11,"fmt","holochain_core_types::cas::storage","",4,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",5,[[["self"],["formatter"]],["result"]]],[11,"fmt","holochain_core_types::chain_header","",7,[[["self"],["formatter"]],["result"]]],[11,"fmt","holochain_core_types::crud_status","",8,[[["self"],["formatter"]],["result"]]],[11,"fmt","holochain_core_types::eav","",10,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",11,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",12,[[["self"],["formatter"]],["result"]]],[11,"fmt","holochain_core_types::entry::cap_entries","",15,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",16,[[["self"],["formatter"]],["result"]]],[11,"fmt","holochain_core_types::entry::deletion_entry","",17,[[["self"],["formatter"]],["result"]]],[11,"fmt","holochain_core_types::entry::entry_type","",61,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",18,[[["self"],["formatter"]],["result"]]],[11,"fmt","holochain_core_types::entry","",14,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",13,[[["self"],["formatter"]],["result"]]],[11,"fmt","holochain_core_types::error","",19,[[["self"],["formatter"]],["result"]]],[11,"fmt","holochain_core_types::error::error","",22,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",24,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",23,[[["self"],["formatter"]],["result"]]],[11,"fmt","holochain_core_types::error","",20,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",21,[[["self"],["formatter"]],["result"]]],[11,"fmt","holochain_core_types::agent","",25,[[["self"],["formatter"]],["result"]]],[11,"fmt","holochain_core_types::chain_migrate","",62,[[["self"],["formatter"]],["result"]]],[11,"fmt","holochain_core_types::dna::bridges","",27,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",28,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",29,[[["self"],["formatter"]],["result"]]],[11,"fmt","holochain_core_types::dna::capabilities","",34,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",63,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",30,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",35,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",31,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",32,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",33,[[["self"],["formatter"]],["result"]]],[11,"fmt","holochain_core_types::dna::dna","",36,[[["self"],["formatter"]],["result"]]],[11,"fmt","holochain_core_types::dna::entry_types","",40,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",37,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",38,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",39,[[["self"],["formatter"]],["result"]]],[11,"fmt","holochain_core_types::dna::wasm","",41,[[["self"],["formatter"]],["result"]]],[11,"fmt","holochain_core_types::dna::zome","",44,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",42,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",43,[[["self"],["formatter"]],["result"]]],[11,"fmt","holochain_core_types::hash","",45,[[["self"],["formatter"]],["result"]]],[11,"fmt","holochain_core_types::json","",46,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",64,[[["self"],["formatter"]],["result"]]],[11,"fmt","holochain_core_types::keys","",47,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",48,[[["self"],["formatter"]],["result"]]],[11,"fmt","holochain_core_types::link::link_add","",50,[[["self"],["formatter"]],["result"]]],[11,"fmt","holochain_core_types::link::link_list","",51,[[["self"],["formatter"]],["result"]]],[11,"fmt","holochain_core_types::link::link_remove","",65,[[["self"],["formatter"]],["result"]]],[11,"fmt","holochain_core_types::link","",52,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",49,[[["self"],["formatter"]],["result"]]],[11,"fmt","holochain_core_types::signature","",66,[[["self"],["formatter"]],["result"]]],[11,"fmt","holochain_core_types::time","",67,[[["self"],["formatter"]],["result"]]],[11,"fmt","holochain_core_types::validation","",53,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",55,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",54,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",56,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",57,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",58,[[["self"],["formatter"]],["result"]]],[11,"fmt","holochain_core_types::entry::entry_type","",18,[[["self"],["formatter"]],["fmtresult"]]],[11,"fmt","holochain_core_types::error","",19,[[["self"],["formatter"]],["result"]]],[11,"fmt","holochain_core_types::error::error","",22,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",24,[[["self"],["formatter"]],["result"]]],[11,"fmt","holochain_core_types::hash","",45,[[["self"],["formatter"]],["result"]]],[11,"fmt","holochain_core_types::json","",46,[[["self"],["formatter"]],["fmtresult"]]],[11,"try_from","holochain_core_types::chain_header","",7,[[["jsonstring"]],["result"]]],[11,"try_from","","",7,[[["jsonstring"]],["result"]]],[11,"try_from","holochain_core_types::crud_status","",8,[[["jsonstring"]],["result"]]],[11,"try_from","","",8,[[["jsonstring"]],["result"]]],[11,"try_from","holochain_core_types::eav","",10,[[["jsonstring"]],["result"]]],[11,"try_from","","",10,[[["jsonstring"]],["result"]]],[11,"try_from","holochain_core_types::entry::cap_entries","",15,[[["jsonstring"]],["result"]]],[11,"try_from","","",15,[[["jsonstring"]],["result"]]],[11,"try_from","","",16,[[["jsonstring"]],["result"]]],[11,"try_from","","",16,[[["jsonstring"]],["result"]]],[11,"try_from","holochain_core_types::entry::deletion_entry","",17,[[["jsonstring"]],["result"]]],[11,"try_from","","",17,[[["jsonstring"]],["result"]]],[11,"try_from","holochain_core_types::entry::entry_type","",18,[[["jsonstring"]],["result"]]],[11,"try_from","","",18,[[["jsonstring"]],["result"]]],[11,"try_from","","",61,[[["entrytype"]],["result"]]],[11,"try_from","holochain_core_types::entry","",14,[[["jsonstring"]],["result"]]],[11,"try_from","","",14,[[["jsonstring"]],["result"]]],[11,"try_from","","",13,[[["jsonstring"]],["result"]]],[11,"try_from","","",13,[[["jsonstring"]],["result"]]],[11,"try_from","holochain_core_types::error::error","",22,[[["jsonstring"]],["result"]]],[11,"try_from","","",22,[[["jsonstring"]],["result"]]],[11,"try_from","","",22,[[["zomeapiinternalresult"]],["result"]]],[11,"try_from","","",24,[[["jsonstring"]],["result"]]],[11,"try_from","","",24,[[["jsonstring"]],["result"]]],[11,"try_from","","",23,[[["jsonstring"]],["result"]]],[11,"try_from","","",23,[[["jsonstring"]],["result"]]],[11,"try_from","holochain_core_types::error","",20,[[["jsonstring"]],["result"]]],[11,"try_from","","",21,[[["jsonstring"]],["result"]]],[11,"try_from","","",21,[[["jsonstring"]],["result"]]],[11,"try_from","holochain_core_types::agent","",25,[[["jsonstring"]],["result"]]],[11,"try_from","","",25,[[["jsonstring"]],["result"]]],[11,"try_from","holochain_core_types::dna::dna","",36,[[["jsonstring"]],["result"]]],[11,"try_from","","",36,[[["jsonstring"]],["result"]]],[11,"try_from","holochain_core_types::dna::entry_types","",39,[[["jsonstring"]],["result"]]],[11,"try_from","","",39,[[["jsonstring"]],["result"]]],[11,"try_from","holochain_core_types::dna::zome","",43,[[["jsonstring"]],["result"]]],[11,"try_from","","",43,[[["jsonstring"]],["result"]]],[11,"try_from","holochain_core_types::hash","",45,[[["jsonstring"]],["result"]]],[11,"try_from","","",45,[[["jsonstring"]],["result"]]],[11,"try_from","holochain_core_types::json","",64,[[["jsonstring"]],["hcresult"]]],[11,"try_from","holochain_core_types::link::link_add","",50,[[["jsonstring"]],["result"]]],[11,"try_from","","",50,[[["jsonstring"]],["result"]]],[11,"try_from","holochain_core_types::link::link_list","",51,[[["jsonstring"]],["result"]]],[11,"try_from","","",51,[[["jsonstring"]],["result"]]],[11,"try_from","holochain_core_types::link","",52,[[["jsonstring"]],["result"]]],[11,"try_from","","",52,[[["jsonstring"]],["result"]]],[11,"try_from","holochain_core_types::validation","",53,[[["jsonstring"]],["result"]]],[11,"try_from","","",53,[[["jsonstring"]],["result"]]],[11,"try_from","","",55,[[["jsonstring"]],["result"]]],[11,"try_from","","",55,[[["jsonstring"]],["result"]]],[11,"from_str","holochain_core_types::crud_status","",8,[[["str"]],["result"]]],[11,"from_str","holochain_core_types::entry::entry_type","",18,[[["str"]],["result"]]],[11,"from_str","holochain_core_types::error","",20,[[["str"]],["result"]]],[11,"from_str","","",21,[[["str"]],["result"]]],[11,"from_str","holochain_core_types::dna::capabilities","",34,[[["str"]],["result"]]],[11,"hash","holochain_core_types::cas::content","",59,N],[11,"hash","holochain_core_types::eav","",10,N],[11,"hash","holochain_core_types::entry::entry_type","",61,N],[11,"hash","","",18,N],[11,"hash","holochain_core_types::error","",19,N],[11,"hash","holochain_core_types::error::error","",22,N],[11,"hash","","",24,N],[11,"hash","holochain_core_types::error","",21,N],[11,"hash","holochain_core_types::dna::bridges","",27,N],[11,"hash","","",28,N],[11,"hash","","",29,N],[11,"hash","holochain_core_types::dna::capabilities","",63,N],[11,"hash","","",30,N],[11,"hash","","",35,N],[11,"hash","","",31,N],[11,"hash","","",32,N],[11,"hash","","",33,N],[11,"hash","holochain_core_types::dna::dna","",36,[[["self"],["h"]]]],[11,"hash","holochain_core_types::dna::entry_types","",40,N],[11,"hash","","",37,N],[11,"hash","","",38,N],[11,"hash","","",39,N],[11,"hash","holochain_core_types::dna::wasm","",41,N],[11,"hash","holochain_core_types::dna::zome","",44,N],[11,"hash","","",42,N],[11,"hash","holochain_core_types::hash","",45,N],[11,"hash","holochain_core_types::json","",46,N],[11,"hash","holochain_core_types::link","",52,N],[11,"description","holochain_core_types::error","",19,[[["self"]],["str"]]],[11,"description","holochain_core_types::error::error","",22,[[["self"]],["str"]]],[11,"cause","","",22,[[["self"]],["option",["error"]]]],[11,"description","","",24,[[["self"]],["str"]]],[11,"serialize","holochain_core_types::chain_header","",7,[[["self"],["__s"]],["result"]]],[11,"serialize","holochain_core_types::crud_status","",8,[[["self"],["__s"]],["result"]]],[11,"serialize","holochain_core_types::eav","",10,[[["self"],["__s"]],["result"]]],[11,"serialize","holochain_core_types::entry::cap_entries","",15,[[["self"],["__s"]],["result"]]],[11,"serialize","","",16,[[["self"],["__s"]],["result"]]],[11,"serialize","holochain_core_types::entry::deletion_entry","",17,[[["self"],["__s"]],["result"]]],[11,"serialize","holochain_core_types::entry::entry_type","",61,[[["self"],["__s"]],["result"]]],[11,"serialize","","",18,[[["self"],["__s"]],["result"]]],[11,"serialize","holochain_core_types::entry","",14,[[["self"],["__s"]],["result"]]],[11,"serialize","","",13,[[["self"],["__s"]],["result"]]],[11,"serialize","holochain_core_types::error","",19,[[["self"],["__s"]],["result"]]],[11,"serialize","holochain_core_types::error::error","",22,[[["self"],["__s"]],["result"]]],[11,"serialize","","",24,[[["self"],["__s"]],["result"]]],[11,"serialize","","",23,[[["self"],["__s"]],["result"]]],[11,"serialize","holochain_core_types::error","",21,[[["self"],["s"]],["result"]]],[11,"serialize","holochain_core_types::agent","",25,[[["self"],["__s"]],["result"]]],[11,"serialize","holochain_core_types::chain_migrate","",62,[[["self"],["__s"]],["result"]]],[11,"serialize","holochain_core_types::dna::bridges","",27,[[["self"],["__s"]],["result"]]],[11,"serialize","","",28,[[["self"],["__s"]],["result"]]],[11,"serialize","","",29,[[["self"],["__s"]],["result"]]],[11,"serialize","holochain_core_types::dna::capabilities","",63,[[["self"],["__s"]],["result"]]],[11,"serialize","","",30,[[["self"],["__s"]],["result"]]],[11,"serialize","","",35,[[["self"],["__s"]],["result"]]],[11,"serialize","","",31,[[["self"],["__s"]],["result"]]],[11,"serialize","","",32,[[["self"],["__s"]],["result"]]],[11,"serialize","","",33,[[["self"],["__s"]],["result"]]],[11,"serialize","holochain_core_types::dna::dna","",36,[[["self"],["__s"]],["result"]]],[11,"serialize","holochain_core_types::dna::entry_types","",40,[[["self"],["__s"]],["result"]]],[11,"serialize","","",37,[[["self"],["__s"]],["result"]]],[11,"serialize","","",38,[[["self"],["__s"]],["result"]]],[11,"serialize","","",39,[[["self"],["__s"]],["result"]]],[11,"serialize","holochain_core_types::dna::wasm","",41,[[["self"],["__s"]],["result"]]],[11,"serialize","holochain_core_types::dna::zome","",44,[[["self"],["__s"]],["result"]]],[11,"serialize","","",42,[[["self"],["__s"]],["result"]]],[11,"serialize","","",43,[[["self"],["__s"]],["result"]]],[11,"serialize","holochain_core_types::hash","",45,[[["self"],["__s"]],["result"]]],[11,"serialize","holochain_core_types::keys","",47,[[["self"],["__s"]],["result"]]],[11,"serialize","","",48,[[["self"],["__s"]],["result"]]],[11,"serialize","holochain_core_types::link::link_add","",50,[[["self"],["__s"]],["result"]]],[11,"serialize","holochain_core_types::link::link_list","",51,[[["self"],["__s"]],["result"]]],[11,"serialize","holochain_core_types::link::link_remove","",65,[[["self"],["__s"]],["result"]]],[11,"serialize","holochain_core_types::link","",52,[[["self"],["__s"]],["result"]]],[11,"serialize","","",49,[[["self"],["__s"]],["result"]]],[11,"serialize","holochain_core_types::signature","",66,[[["self"],["__s"]],["result"]]],[11,"serialize","holochain_core_types::time","",67,[[["self"],["__s"]],["result"]]],[11,"serialize","holochain_core_types::validation","",53,[[["self"],["__s"]],["result"]]],[11,"serialize","","",55,[[["self"],["__s"]],["result"]]],[11,"serialize","","",54,[[["self"],["__s"]],["result"]]],[11,"serialize","","",56,[[["self"],["__s"]],["result"]]],[11,"serialize","","",57,[[["self"],["__s"]],["result"]]],[11,"serialize","","",58,[[["self"],["__s"]],["result"]]],[11,"deserialize","holochain_core_types::chain_header","",7,[[["__d"]],["result"]]],[11,"deserialize","holochain_core_types::crud_status","",8,[[["__d"]],["result"]]],[11,"deserialize","holochain_core_types::eav","",10,[[["__d"]],["result"]]],[11,"deserialize","holochain_core_types::entry::cap_entries","",15,[[["__d"]],["result"]]],[11,"deserialize","","",16,[[["__d"]],["result"]]],[11,"deserialize","holochain_core_types::entry::deletion_entry","",17,[[["__d"]],["result"]]],[11,"deserialize","holochain_core_types::entry::entry_type","",61,[[["__d"]],["result"]]],[11,"deserialize","","",18,[[["__d"]],["result"]]],[11,"deserialize","holochain_core_types::entry","",14,[[["__d"]],["result"]]],[11,"deserialize","","",13,[[["__d"]],["result"]]],[11,"deserialize","holochain_core_types::error","",19,[[["__d"]],["result"]]],[11,"deserialize","holochain_core_types::error::error","",22,[[["__d"]],["result"]]],[11,"deserialize","","",24,[[["__d"]],["result"]]],[11,"deserialize","","",23,[[["__d"]],["result"]]],[11,"deserialize","holochain_core_types::error","",21,[[["d"]],["result"]]],[11,"deserialize","holochain_core_types::agent","",25,[[["__d"]],["result"]]],[11,"deserialize","holochain_core_types::chain_migrate","",62,[[["__d"]],["result"]]],[11,"deserialize","holochain_core_types::dna::bridges","",27,[[["__d"]],["result"]]],[11,"deserialize","","",28,[[["__d"]],["result"]]],[11,"deserialize","","",29,[[["__d"]],["result"]]],[11,"deserialize","holochain_core_types::dna::capabilities","",63,[[["__d"]],["result"]]],[11,"deserialize","","",30,[[["__d"]],["result"]]],[11,"deserialize","","",35,[[["__d"]],["result"]]],[11,"deserialize","","",31,[[["__d"]],["result"]]],[11,"deserialize","","",32,[[["__d"]],["result"]]],[11,"deserialize","","",33,[[["__d"]],["result"]]],[11,"deserialize","holochain_core_types::dna::dna","",36,[[["__d"]],["result"]]],[11,"deserialize","holochain_core_types::dna::entry_types","",40,[[["__d"]],["result"]]],[11,"deserialize","","",37,[[["__d"]],["result"]]],[11,"deserialize","","",38,[[["__d"]],["result"]]],[11,"deserialize","","",39,[[["__d"]],["result"]]],[11,"deserialize","holochain_core_types::dna::wasm","",41,[[["__d"]],["result"]]],[11,"deserialize","holochain_core_types::dna::zome","",44,[[["__d"]],["result"]]],[11,"deserialize","","",42,[[["__d"]],["result"]]],[11,"deserialize","","",43,[[["__d"]],["result"]]],[11,"deserialize","holochain_core_types::hash","",45,[[["__d"]],["result"]]],[11,"deserialize","holochain_core_types::json","",64,[[["__d"]],["result"]]],[11,"deserialize","holochain_core_types::keys","",47,[[["__d"]],["result"]]],[11,"deserialize","","",48,[[["__d"]],["result"]]],[11,"deserialize","holochain_core_types::link::link_add","",50,[[["__d"]],["result"]]],[11,"deserialize","holochain_core_types::link::link_list","",51,[[["__d"]],["result"]]],[11,"deserialize","holochain_core_types::link::link_remove","",65,[[["__d"]],["result"]]],[11,"deserialize","holochain_core_types::link","",52,[[["__d"]],["result"]]],[11,"deserialize","","",49,[[["__d"]],["result"]]],[11,"deserialize","holochain_core_types::signature","",66,[[["__d"]],["result"]]],[11,"deserialize","holochain_core_types::time","",67,[[["__d"]],["result"]]],[11,"deserialize","holochain_core_types::validation","",53,[[["__d"]],["result"]]],[11,"deserialize","","",55,[[["__d"]],["result"]]],[11,"deserialize","","",54,[[["__d"]],["result"]]],[11,"deserialize","","",56,[[["__d"]],["result"]]],[11,"deserialize","","",57,[[["__d"]],["result"]]],[11,"deserialize","","",58,[[["__d"]],["result"]]]],"paths":[[8,"AddressableContent"],[3,"AddressableContentTestSuite"],[3,"StorageTestSuite"],[8,"ContentAddressableStorage"],[3,"ExampleContentAddressableStorage"],[3,"ExampleContentAddressableStorageContent"],[3,"EavTestSuite"],[3,"ChainHeader"],[4,"CrudStatus"],[8,"EntityAttributeValueStorage"],[3,"EntityAttributeValue"],[3,"ExampleEntityAttributeValueStorageNonSync"],[3,"ExampleEntityAttributeValueStorage"],[3,"EntryWithMeta"],[4,"Entry"],[3,"CapToken"],[3,"CapTokenGrant"],[3,"DeletionEntry"],[4,"EntryType"],[4,"DnaError"],[4,"RibosomeReturnCode"],[4,"RibosomeErrorCode"],[3,"CoreError"],[3,"ZomeApiInternalResult"],[4,"HolochainError"],[3,"AgentId"],[3,"KeyBuffer"],[3,"Bridge"],[4,"BridgeReference"],[4,"BridgePresence"],[3,"CapabilityCall"],[3,"FnParameter"],[3,"FnDeclaration"],[3,"Capability"],[4,"ReservedCapabilityNames"],[4,"CapabilityType"],[3,"Dna"],[3,"LinksTo"],[3,"LinkedFrom"],[3,"EntryTypeDef"],[4,"Sharing"],[3,"DnaWasm"],[3,"Config"],[3,"Zome"],[4,"ErrorHandling"],[3,"HashString"],[3,"JsonString"],[3,"Key"],[3,"Keys"],[4,"LinkActionKind"],[3,"LinkAdd"],[3,"LinkList"],[3,"Link"],[3,"ValidationPackage"],[3,"ValidationData"],[4,"ValidationPackageDefinition"],[4,"EntryLifecycle"],[4,"EntryAction"],[4,"LinkAction"],[3,"ExampleAddressableContent"],[3,"OtherExampleAddressableContent"],[3,"AppEntryType"],[3,"ChainMigrate"],[3,"CallSignature"],[3,"RawString"],[3,"LinkRemove"],[3,"Signature"],[3,"Iso8601"],[6,"Content"]]};
searchIndex["holochain_core_types_derive"]={"doc":"","items":[[24,"DefaultJson","holochain_core_types_derive","",N,N]],"paths":[]};
searchIndex["holochain_dna_c_binding"]={"doc":"This crate is an ffi wrapper to provide a c-compatible dna library.","items":[[3,"CStringVec","holochain_dna_c_binding","",N,N],[5,"holochain_dna_create","","",N,N],[5,"holochain_dna_create_from_json","","",N,N],[5,"holochain_dna_free","","",N,N],[5,"holochain_dna_to_json","","",N,N],[5,"holochain_dna_string_free","","",N,N],[5,"holochain_dna_get_name","","",N,N],[5,"holochain_dna_set_name","","",N,N],[5,"holochain_dna_get_description","","",N,N],[5,"holochain_dna_set_description","","",N,N],[5,"holochain_dna_get_version","","",N,N],[5,"holochain_dna_set_version","","",N,N],[5,"holochain_dna_get_uuid","","",N,N],[5,"holochain_dna_set_uuid","","",N,N],[5,"holochain_dna_get_dna_spec_version","","",N,N],[5,"holochain_dna_set_dna_spec_version","","",N,N],[5,"holochain_dna_get_zome_names","","",N,N],[5,"holochain_dna_free_zome_names","","",N,N],[5,"holochain_dna_get_capabilities_names","","",N,N],[5,"holochain_dna_get_function_names","","",N,N],[5,"holochain_dna_get_function_parameters","","",N,N],[11,"from","","",0,[[["t"]],["t"]]],[11,"into","","",0,[[["self"]],["u"]]],[11,"try_from","","",0,[[["u"]],["result"]]],[11,"borrow","","",0,[[["self"]],["t"]]],[11,"get_type_id","","",0,[[["self"]],["typeid"]]],[11,"try_into","","",0,[[["self"]],["result"]]],[11,"borrow_mut","","",0,[[["self"]],["t"]]]],"paths":[[3,"CStringVec"]]};
searchIndex["holochain_net"]={"doc":"holochain_net is a library that defines an abstract networking layer for different network transports, providing a configurable interface for swapping different backends connection modules at load time","items":[[0,"error","holochain_net","",N,N],[4,"NetworkError","holochain_net::error","",N,N],[13,"GenericError","","",0,N],[12,"error","holochain_net::error::NetworkError","",0,N],[0,"ipc_net_worker","holochain_net","provides a NetWorker implementation for backend IPC p2p connections",N,N],[3,"IpcNetWorker","holochain_net::ipc_net_worker","a p2p net worker",N,N],[11,"new_test","","",1,[[["nethandler"],["teststruct"]],["netresult"]]],[11,"new","","",1,[[["nethandler"],["jsonstring"]],["netresult"]]],[0,"mock_worker","holochain_net","provides fake in-memory p2p worker for use in scenario testing",N,N],[3,"MockWorker","holochain_net::mock_worker","a p2p worker for mocking in-memory scenario tests",N,N],[11,"new","","create a new mock worker... no configuration required",2,[[["nethandler"]],["netresult"]]],[0,"p2p_config","holochain_net","",N,N],[3,"P2pConfig","holochain_net::p2p_config","",N,N],[12,"backend_kind","","",3,N],[12,"backend_config","","",3,N],[4,"P2pBackendKind","","",N,N],[13,"MOCK","","",4,N],[13,"IPC","","",4,N],[11,"as_str","","",3,[[["self"]],["string"]]],[11,"new","","",3,[[["p2pbackendkind"],["str"]],["self"]]],[11,"from_file","","",3,[[["str"]],["self"]]],[11,"default_mock","","",3,[[],["self"]]],[11,"default_ipc","","",3,[[],["self"]]],[18,"DEFAULT_MOCK_CONFIG","","",3,N],[18,"DEFAULT_IPC_CONFIG","","",3,N],[0,"p2p_network","holochain_net","This module provides the core abstraction for differing p2p backends P2pNetwork instances take a json configuration string and at load-time instantiate the configured \"backend\"",N,N],[3,"P2pNetwork","holochain_net::p2p_network","The p2p network instance",N,N],[11,"new","","create a new p2p network instance, given message handler and config json",5,[[["nethandler"],["p2pconfig"]],["netresult"]]],[11,"stop","","stop the network module (disconnect any sockets, join any threads, etc)",5,[[["self"]],["netresult"]]],[11,"from","holochain_net::error","",0,[[["t"]],["t"]]],[11,"into","","",0,[[["self"]],["u"]]],[11,"to_string","","",0,[[["self"]],["string"]]],[11,"try_from","","",0,[[["u"]],["result"]]],[11,"borrow","","",0,[[["self"]],["t"]]],[11,"get_type_id","","",0,[[["self"]],["typeid"]]],[11,"try_into","","",0,[[["self"]],["result"]]],[11,"borrow_mut","","",0,[[["self"]],["t"]]],[11,"as_fail","","",0,[[["self"]],["fail"]]],[11,"from","holochain_net::ipc_net_worker","",1,[[["t"]],["t"]]],[11,"into","","",1,[[["self"]],["u"]]],[11,"try_from","","",1,[[["u"]],["result"]]],[11,"borrow","","",1,[[["self"]],["t"]]],[11,"get_type_id","","",1,[[["self"]],["typeid"]]],[11,"try_into","","",1,[[["self"]],["result"]]],[11,"borrow_mut","","",1,[[["self"]],["t"]]],[11,"from","holochain_net::mock_worker","",2,[[["t"]],["t"]]],[11,"into","","",2,[[["self"]],["u"]]],[11,"try_from","","",2,[[["u"]],["result"]]],[11,"borrow","","",2,[[["self"]],["t"]]],[11,"get_type_id","","",2,[[["self"]],["typeid"]]],[11,"try_into","","",2,[[["self"]],["result"]]],[11,"borrow_mut","","",2,[[["self"]],["t"]]],[11,"from","holochain_net::p2p_config","",3,[[["t"]],["t"]]],[11,"into","","",3,[[["self"]],["u"]]],[11,"to_owned","","",3,[[["self"]],["t"]]],[11,"clone_into","","",3,N],[11,"try_from","","",3,[[["u"]],["result"]]],[11,"borrow","","",3,[[["self"]],["t"]]],[11,"get_type_id","","",3,[[["self"]],["typeid"]]],[11,"try_into","","",3,[[["self"]],["result"]]],[11,"borrow_mut","","",3,[[["self"]],["t"]]],[11,"clone_box","","",3,N],[11,"from","","",4,[[["t"]],["t"]]],[11,"into","","",4,[[["self"]],["u"]]],[11,"to_owned","","",4,[[["self"]],["t"]]],[11,"clone_into","","",4,N],[11,"try_from","","",4,[[["u"]],["result"]]],[11,"borrow","","",4,[[["self"]],["t"]]],[11,"get_type_id","","",4,[[["self"]],["typeid"]]],[11,"try_into","","",4,[[["self"]],["result"]]],[11,"borrow_mut","","",4,[[["self"]],["t"]]],[11,"clone_box","","",4,N],[11,"equivalent","","",4,[[["self"],["k"]],["bool"]]],[11,"from","holochain_net::p2p_network","",5,[[["t"]],["t"]]],[11,"into","","",5,[[["self"]],["u"]]],[11,"try_from","","",5,[[["u"]],["result"]]],[11,"borrow","","",5,[[["self"]],["t"]]],[11,"get_type_id","","",5,[[["self"]],["typeid"]]],[11,"try_into","","",5,[[["self"]],["result"]]],[11,"borrow_mut","","",5,[[["self"]],["t"]]],[11,"eq","holochain_net::p2p_config","",4,[[["self"],["p2pbackendkind"]],["bool"]]],[11,"eq","","",3,[[["self"],["p2pconfig"]],["bool"]]],[11,"ne","","",3,[[["self"],["p2pconfig"]],["bool"]]],[11,"from","","",4,[[["string"]],["p2pbackendkind"]]],[11,"from","","",4,[[["str"]],["p2pbackendkind"]]],[11,"clone","","",4,[[["self"]],["p2pbackendkind"]]],[11,"clone","","",3,[[["self"]],["p2pconfig"]]],[11,"fmt","holochain_net::error","",0,[[["self"],["formatter"]],["result"]]],[11,"fmt","holochain_net::p2p_config","",4,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",3,[[["self"],["formatter"]],["result"]]],[11,"fmt","holochain_net::p2p_network","",5,[[["self"],["formatter"]],["result"]]],[11,"fmt","holochain_net::error","",0,[[["self"],["formatter"]],["result"]]],[11,"try_from","holochain_net::p2p_config","",4,[[["jsonstring"]],["result"]]],[11,"try_from","","",4,[[["jsonstring"]],["result"]]],[11,"try_from","","",3,[[["jsonstring"]],["result"]]],[11,"try_from","","",3,[[["jsonstring"]],["result"]]],[11,"from_str","","",4,[[["str"]],["result"]]],[11,"from_str","","",3,[[["str"]],["result"]]],[11,"cause","holochain_net::error","",0,[[["self"]],["option",["fail"]]]],[11,"backtrace","","",0,[[["self"]],["option",["backtrace"]]]],[11,"deserialize","holochain_net::p2p_config","",4,[[["__d"]],["result"]]],[11,"deserialize","","",3,[[["__d"]],["result"]]],[11,"serialize","","",4,[[["self"],["__s"]],["result"]]],[11,"serialize","","",3,[[["self"],["__s"]],["result"]]],[11,"send","holochain_net::p2p_network","send a Protocol message to the p2p network instance",5,[[["self"],["protocol"]],["netresult"]]],[11,"stop","holochain_net::ipc_net_worker","stop the net worker",1,[[["box"]],["netresult"]]],[11,"receive","","we got a message from holochain core (just forwards to the internal worker relay)",1,[[["self"],["protocol"]],["netresult"]]],[11,"tick","","do some upkeep on the internal worker",1,[[["self"]],["netresult",["bool"]]]],[11,"stop","holochain_net::mock_worker","stop the net worker",2,[[["box"]],["netresult"]]],[11,"receive","","we got a message from holochain core forward to our mock singleton",2,[[["self"],["protocol"]],["netresult"]]],[11,"tick","","check for messages from our mock singleton",2,[[["self"]],["netresult",["bool"]]]]],"paths":[[4,"NetworkError"],[3,"IpcNetWorker"],[3,"MockWorker"],[3,"P2pConfig"],[4,"P2pBackendKind"],[3,"P2pNetwork"]]};
searchIndex["holochain_net_connection"]={"doc":"Provides a lightweight concurrency abstraction for holochain networking / p2p layer see holochain_net_ipc for a specific implementation, and holochain_net for the crate that pulls the implementations together","items":[[0,"net_connection","holochain_net_connection","",N,N],[3,"NetConnectionRelay","holochain_net_connection::net_connection","a simple pass-through NetConnection instance this struct can be use to compose one type of NetWorker into another",N,N],[6,"NetHandler","","closure for getting Protocol messages from the p2p abstraction system",N,N],[6,"NetShutdown","","closure for signaling shutdown incase of required cleanup",N,N],[6,"NetWorkerFactory","","closure for instantiating a NetWorker",N,N],[8,"NetConnection","","net connection - a worker manager can send Protocol messages",N,N],[10,"send","","",0,[[["self"],["protocol"]],["netresult"]]],[8,"NetWorker","","represents a worker that handles protocol messages",N,N],[11,"stop","","stop the worker",1,[[["box"]],["netresult"]]],[11,"receive","","when somebody has called `send` to send this worker a message",1,[[["self"],["protocol"]],["netresult"]]],[11,"tick","","perform any upkeep return `false` if there was no upkeep to perform",1,[[["self"]],["netresult",["bool"]]]],[11,"stop","","stop this NetConnectionRelay instance",2,[[["self"]],["netresult"]]],[11,"tick","","call tick to perform any worker upkeep",2,[[["self"]],["netresult",["bool"]]]],[11,"new","","create a new NetConnectionRelay instance with give handler / factory",2,[[["nethandler"],["networkerfactory"],["netshutdown"]],["netresult"]]],[0,"net_connection_thread","holochain_net_connection","",N,N],[3,"NetConnectionThread","holochain_net_connection::net_connection_thread","a NetConnection instance that is managed on another thread",N,N],[11,"stop","","stop (join) the worker thread",3,[[["self"]],["netresult"]]],[11,"new","","create a new NetConnectionThread instance with given handler / worker",3,[[["nethandler"],["networkerfactory"],["netshutdown"]],["netresult"]]],[0,"protocol","holochain_net_connection","This module provides the core low-level protocol enumeration for communications between holochain core and the p2p / networking process or library. See protocol_wrapper for a higher level interface.",N,N],[3,"NamedBinaryData","holochain_net_connection::protocol","send/recv binary data / i.e. encryption, signature messages",N,N],[12,"name","","",4,N],[12,"data","","",4,N],[3,"PingData","","send/recv a Ping message (ipc protocol spec)",N,N],[12,"sent","","",5,N],[3,"PongData","","send/recv a Pong message (ipc protocol spec)",N,N],[12,"orig","","",6,N],[12,"recv","","",6,N],[4,"Protocol","","Low-level interface spec for communicating with the p2p abstraction notice this is not Serializable or Deserializable rmp_serde doesn't serialize enums very well... it uses indexes and arrays which are not (easily) compatible with other endpoints we use to/from NamedBinaryData to provide our own serialization wrapper",N,N],[13,"NamedBinary","","send/recv binary data / i.e. encryption, signature messages",7,N],[13,"Json","","send/recv generic json as utf8 strings",7,N],[13,"Ping","","send/recv a Ping message (ipc protocol spec)",7,N],[13,"Pong","","send/recv a Pong message (ipc protocol spec)",7,N],[13,"P2pReady","","we have connected / configured the connection, ready for messages",7,N],[11,"is_named_binary","","",7,[[["self"]],["bool"]]],[11,"as_named_binary","","",7,[[["self"]],["namedbinarydata"]]],[11,"is_json","","",7,[[["self"]],["bool"]]],[11,"as_json","","",7,[[["self"]],["jsonstring"]]],[11,"is_ping","","",7,[[["self"]],["bool"]]],[11,"as_ping","","",7,[[["self"]],["pingdata"]]],[11,"is_pong","","",7,[[["self"]],["bool"]]],[11,"as_pong","","",7,[[["self"]],["pongdata"]]],[11,"as_json_string","","get a json string straight out of the Protocol enum",7,[[["self"]],["jsonstring"]]],[0,"protocol_wrapper","holochain_net_connection","This module provides a higher level interface to p2p / network messaging basically handles serialization / deserialization from / to the core protocol message types (NamedBinary and Json).",N,N],[3,"StateData","holochain_net_connection::protocol_wrapper","",N,N],[12,"state","","",8,N],[12,"id","","",8,N],[12,"bindings","","",8,N],[3,"ConfigData","","",N,N],[12,"config","","",9,N],[3,"ConnectData","","",N,N],[12,"address","","",10,N],[3,"PeerData","","",N,N],[12,"dna_hash","","",11,N],[12,"agent_id","","",11,N],[3,"MessageData","","",N,N],[12,"msg_id","","",12,N],[12,"dna_hash","","",12,N],[12,"to_agent_id","","",12,N],[12,"from_agent_id","","",12,N],[12,"data","","",12,N],[3,"TrackAppData","","",N,N],[12,"dna_hash","","",13,N],[12,"agent_id","","",13,N],[3,"SuccessResultData","","",N,N],[12,"msg_id","","",14,N],[12,"dna_hash","","",14,N],[12,"to_agent_id","","",14,N],[12,"success_info","","",14,N],[3,"FailureResultData","","",N,N],[12,"msg_id","","",15,N],[12,"dna_hash","","",15,N],[12,"to_agent_id","","",15,N],[12,"error_info","","",15,N],[3,"GetDhtData","","",N,N],[12,"msg_id","","",16,N],[12,"dna_hash","","",16,N],[12,"from_agent_id","","",16,N],[12,"address","","",16,N],[3,"DhtData","","",N,N],[12,"msg_id","","",17,N],[12,"dna_hash","","",17,N],[12,"agent_id","","",17,N],[12,"address","","",17,N],[12,"content","","",17,N],[3,"GetDhtMetaData","","",N,N],[12,"msg_id","","",18,N],[12,"dna_hash","","",18,N],[12,"from_agent_id","","",18,N],[12,"address","","",18,N],[12,"attribute","","",18,N],[3,"DhtMetaData","","",N,N],[12,"msg_id","","",19,N],[12,"dna_hash","","",19,N],[12,"agent_id","","",19,N],[12,"address","","",19,N],[12,"attribute","","",19,N],[12,"content","","",19,N],[4,"ProtocolWrapper","","High level p2p / network message",N,N],[13,"RequestState","","[send] request the current state from the p2p module",20,N],[13,"State","","[recv] p2p module is telling us the current state",20,N],[13,"RequestDefaultConfig","","[send] request the default config from the p2p module",20,N],[13,"DefaultConfig","","[recv] the default config from the p2p module",20,N],[13,"SetConfig","","[send] set the p2p config",20,N],[13,"Connect","","[send] connect to the specified multiaddr",20,N],[13,"PeerConnected","","[recv] notification of a peer connected",20,N],[13,"SendMessage","","[send] send a message to another node on the network",20,N],[13,"SendResult","","[recv] recv the response back from a previous `SendMessage`",20,N],[13,"HandleSend","","[recv] another node has sent us a message",20,N],[13,"HandleSendResult","","[send] send our response to a previous `HandleSend`",20,N],[13,"TrackApp","","[send] send out a \"trackApp\" request",20,N],[13,"SuccessResult","","[send / recv] report success for a messages with _id parameter",20,N],[13,"FailureResult","","[send / recv] for any message with _id parameter to indicate failure",20,N],[13,"GetDht","","[send] request data from the dht [recv] another node, or the network module itself is requesting data        from us... send a GetDhtResult message back",20,N],[13,"GetDhtResult","","[recv] response from requesting dht data from the network [send] success response if network is requesting this data of us",20,N],[13,"PublishDht","","[send] publish content to the dht",20,N],[13,"StoreDht","","[recv] the network is requesting that we store this data",20,N],[13,"GetDhtMeta","","[send] request meta data from the dht [recv] another node, or the network module itself is requesting data        from us... send a GetDhtResult message back",20,N],[13,"GetDhtMetaResult","","[recv] response from requesting meta dht data from the network [send] success response if network is requesting this data of us",20,N],[13,"PublishDhtMeta","","[send] publish meta content to the dht",20,N],[13,"StoreDhtMeta","","[recv] the network is requesting that we store this meta data",20,N],[6,"NetResult","holochain_net_connection","",N,N],[11,"from","holochain_net_connection::net_connection","",2,[[["t"]],["t"]]],[11,"into","","",2,[[["self"]],["u"]]],[11,"try_from","","",2,[[["u"]],["result"]]],[11,"borrow","","",2,[[["self"]],["t"]]],[11,"get_type_id","","",2,[[["self"]],["typeid"]]],[11,"try_into","","",2,[[["self"]],["result"]]],[11,"borrow_mut","","",2,[[["self"]],["t"]]],[11,"from","holochain_net_connection::net_connection_thread","",3,[[["t"]],["t"]]],[11,"into","","",3,[[["self"]],["u"]]],[11,"try_from","","",3,[[["u"]],["result"]]],[11,"borrow","","",3,[[["self"]],["t"]]],[11,"get_type_id","","",3,[[["self"]],["typeid"]]],[11,"try_into","","",3,[[["self"]],["result"]]],[11,"borrow_mut","","",3,[[["self"]],["t"]]],[11,"from","holochain_net_connection::protocol","",4,[[["t"]],["t"]]],[11,"into","","",4,[[["self"]],["u"]]],[11,"to_owned","","",4,[[["self"]],["t"]]],[11,"clone_into","","",4,N],[11,"try_from","","",4,[[["u"]],["result"]]],[11,"borrow","","",4,[[["self"]],["t"]]],[11,"get_type_id","","",4,[[["self"]],["typeid"]]],[11,"try_into","","",4,[[["self"]],["result"]]],[11,"borrow_mut","","",4,[[["self"]],["t"]]],[11,"clone_box","","",4,N],[11,"from","","",5,[[["t"]],["t"]]],[11,"into","","",5,[[["self"]],["u"]]],[11,"to_owned","","",5,[[["self"]],["t"]]],[11,"clone_into","","",5,N],[11,"try_from","","",5,[[["u"]],["result"]]],[11,"borrow","","",5,[[["self"]],["t"]]],[11,"get_type_id","","",5,[[["self"]],["typeid"]]],[11,"try_into","","",5,[[["self"]],["result"]]],[11,"borrow_mut","","",5,[[["self"]],["t"]]],[11,"clone_box","","",5,N],[11,"from","","",6,[[["t"]],["t"]]],[11,"into","","",6,[[["self"]],["u"]]],[11,"to_owned","","",6,[[["self"]],["t"]]],[11,"clone_into","","",6,N],[11,"try_from","","",6,[[["u"]],["result"]]],[11,"borrow","","",6,[[["self"]],["t"]]],[11,"get_type_id","","",6,[[["self"]],["typeid"]]],[11,"try_into","","",6,[[["self"]],["result"]]],[11,"borrow_mut","","",6,[[["self"]],["t"]]],[11,"clone_box","","",6,N],[11,"from","","",7,[[["t"]],["t"]]],[11,"into","","",7,[[["self"]],["u"]]],[11,"to_owned","","",7,[[["self"]],["t"]]],[11,"clone_into","","",7,N],[11,"try_from","","",7,[[["u"]],["result"]]],[11,"borrow","","",7,[[["self"]],["t"]]],[11,"get_type_id","","",7,[[["self"]],["typeid"]]],[11,"try_into","","",7,[[["self"]],["result"]]],[11,"borrow_mut","","",7,[[["self"]],["t"]]],[11,"clone_box","","",7,N],[11,"from","holochain_net_connection::protocol_wrapper","",8,[[["t"]],["t"]]],[11,"into","","",8,[[["self"]],["u"]]],[11,"to_owned","","",8,[[["self"]],["t"]]],[11,"clone_into","","",8,N],[11,"try_from","","",8,[[["u"]],["result"]]],[11,"borrow","","",8,[[["self"]],["t"]]],[11,"get_type_id","","",8,[[["self"]],["typeid"]]],[11,"try_into","","",8,[[["self"]],["result"]]],[11,"borrow_mut","","",8,[[["self"]],["t"]]],[11,"clone_box","","",8,N],[11,"from","","",9,[[["t"]],["t"]]],[11,"into","","",9,[[["self"]],["u"]]],[11,"to_owned","","",9,[[["self"]],["t"]]],[11,"clone_into","","",9,N],[11,"try_from","","",9,[[["u"]],["result"]]],[11,"borrow","","",9,[[["self"]],["t"]]],[11,"get_type_id","","",9,[[["self"]],["typeid"]]],[11,"try_into","","",9,[[["self"]],["result"]]],[11,"borrow_mut","","",9,[[["self"]],["t"]]],[11,"clone_box","","",9,N],[11,"from","","",10,[[["t"]],["t"]]],[11,"into","","",10,[[["self"]],["u"]]],[11,"to_owned","","",10,[[["self"]],["t"]]],[11,"clone_into","","",10,N],[11,"try_from","","",10,[[["u"]],["result"]]],[11,"borrow","","",10,[[["self"]],["t"]]],[11,"get_type_id","","",10,[[["self"]],["typeid"]]],[11,"try_into","","",10,[[["self"]],["result"]]],[11,"borrow_mut","","",10,[[["self"]],["t"]]],[11,"clone_box","","",10,N],[11,"from","","",11,[[["t"]],["t"]]],[11,"into","","",11,[[["self"]],["u"]]],[11,"to_owned","","",11,[[["self"]],["t"]]],[11,"clone_into","","",11,N],[11,"try_from","","",11,[[["u"]],["result"]]],[11,"borrow","","",11,[[["self"]],["t"]]],[11,"get_type_id","","",11,[[["self"]],["typeid"]]],[11,"try_into","","",11,[[["self"]],["result"]]],[11,"borrow_mut","","",11,[[["self"]],["t"]]],[11,"clone_box","","",11,N],[11,"from","","",12,[[["t"]],["t"]]],[11,"into","","",12,[[["self"]],["u"]]],[11,"to_owned","","",12,[[["self"]],["t"]]],[11,"clone_into","","",12,N],[11,"try_from","","",12,[[["u"]],["result"]]],[11,"borrow","","",12,[[["self"]],["t"]]],[11,"get_type_id","","",12,[[["self"]],["typeid"]]],[11,"try_into","","",12,[[["self"]],["result"]]],[11,"borrow_mut","","",12,[[["self"]],["t"]]],[11,"clone_box","","",12,N],[11,"from","","",13,[[["t"]],["t"]]],[11,"into","","",13,[[["self"]],["u"]]],[11,"to_owned","","",13,[[["self"]],["t"]]],[11,"clone_into","","",13,N],[11,"try_from","","",13,[[["u"]],["result"]]],[11,"borrow","","",13,[[["self"]],["t"]]],[11,"get_type_id","","",13,[[["self"]],["typeid"]]],[11,"try_into","","",13,[[["self"]],["result"]]],[11,"borrow_mut","","",13,[[["self"]],["t"]]],[11,"clone_box","","",13,N],[11,"from","","",14,[[["t"]],["t"]]],[11,"into","","",14,[[["self"]],["u"]]],[11,"to_owned","","",14,[[["self"]],["t"]]],[11,"clone_into","","",14,N],[11,"try_from","","",14,[[["u"]],["result"]]],[11,"borrow","","",14,[[["self"]],["t"]]],[11,"get_type_id","","",14,[[["self"]],["typeid"]]],[11,"try_into","","",14,[[["self"]],["result"]]],[11,"borrow_mut","","",14,[[["self"]],["t"]]],[11,"clone_box","","",14,N],[11,"from","","",15,[[["t"]],["t"]]],[11,"into","","",15,[[["self"]],["u"]]],[11,"to_owned","","",15,[[["self"]],["t"]]],[11,"clone_into","","",15,N],[11,"try_from","","",15,[[["u"]],["result"]]],[11,"borrow","","",15,[[["self"]],["t"]]],[11,"get_type_id","","",15,[[["self"]],["typeid"]]],[11,"try_into","","",15,[[["self"]],["result"]]],[11,"borrow_mut","","",15,[[["self"]],["t"]]],[11,"clone_box","","",15,N],[11,"from","","",16,[[["t"]],["t"]]],[11,"into","","",16,[[["self"]],["u"]]],[11,"to_owned","","",16,[[["self"]],["t"]]],[11,"clone_into","","",16,N],[11,"try_from","","",16,[[["u"]],["result"]]],[11,"borrow","","",16,[[["self"]],["t"]]],[11,"get_type_id","","",16,[[["self"]],["typeid"]]],[11,"try_into","","",16,[[["self"]],["result"]]],[11,"borrow_mut","","",16,[[["self"]],["t"]]],[11,"clone_box","","",16,N],[11,"from","","",17,[[["t"]],["t"]]],[11,"into","","",17,[[["self"]],["u"]]],[11,"to_owned","","",17,[[["self"]],["t"]]],[11,"clone_into","","",17,N],[11,"try_from","","",17,[[["u"]],["result"]]],[11,"borrow","","",17,[[["self"]],["t"]]],[11,"get_type_id","","",17,[[["self"]],["typeid"]]],[11,"try_into","","",17,[[["self"]],["result"]]],[11,"borrow_mut","","",17,[[["self"]],["t"]]],[11,"clone_box","","",17,N],[11,"from","","",18,[[["t"]],["t"]]],[11,"into","","",18,[[["self"]],["u"]]],[11,"to_owned","","",18,[[["self"]],["t"]]],[11,"clone_into","","",18,N],[11,"try_from","","",18,[[["u"]],["result"]]],[11,"borrow","","",18,[[["self"]],["t"]]],[11,"get_type_id","","",18,[[["self"]],["typeid"]]],[11,"try_into","","",18,[[["self"]],["result"]]],[11,"borrow_mut","","",18,[[["self"]],["t"]]],[11,"clone_box","","",18,N],[11,"from","","",19,[[["t"]],["t"]]],[11,"into","","",19,[[["self"]],["u"]]],[11,"to_owned","","",19,[[["self"]],["t"]]],[11,"clone_into","","",19,N],[11,"try_from","","",19,[[["u"]],["result"]]],[11,"borrow","","",19,[[["self"]],["t"]]],[11,"get_type_id","","",19,[[["self"]],["typeid"]]],[11,"try_into","","",19,[[["self"]],["result"]]],[11,"borrow_mut","","",19,[[["self"]],["t"]]],[11,"clone_box","","",19,N],[11,"from","","",20,[[["t"]],["t"]]],[11,"into","","",20,[[["self"]],["u"]]],[11,"to_owned","","",20,[[["self"]],["t"]]],[11,"clone_into","","",20,N],[11,"try_from","","",20,[[["u"]],["result"]]],[11,"borrow","","",20,[[["self"]],["t"]]],[11,"get_type_id","","",20,[[["self"]],["typeid"]]],[11,"try_into","","",20,[[["self"]],["result"]]],[11,"borrow_mut","","",20,[[["self"]],["t"]]],[11,"clone_box","","",20,N],[11,"send","holochain_net_connection::net_connection","send a message to the worker within this NetConnectionRelay instance",2,[[["self"],["protocol"]],["netresult"]]],[11,"send","holochain_net_connection::net_connection_thread","send a message to the worker within this NetConnectionThread instance",3,[[["self"],["protocol"]],["netresult"]]],[11,"eq","holochain_net_connection::protocol","",7,[[["self"],["protocol"]],["bool"]]],[11,"ne","","",7,[[["self"],["protocol"]],["bool"]]],[11,"eq","","",4,[[["self"],["namedbinarydata"]],["bool"]]],[11,"ne","","",4,[[["self"],["namedbinarydata"]],["bool"]]],[11,"eq","","",5,[[["self"],["pingdata"]],["bool"]]],[11,"ne","","",5,[[["self"],["pingdata"]],["bool"]]],[11,"eq","","",6,[[["self"],["pongdata"]],["bool"]]],[11,"ne","","",6,[[["self"],["pongdata"]],["bool"]]],[11,"eq","holochain_net_connection::protocol_wrapper","",8,[[["self"],["statedata"]],["bool"]]],[11,"ne","","",8,[[["self"],["statedata"]],["bool"]]],[11,"eq","","",9,[[["self"],["configdata"]],["bool"]]],[11,"ne","","",9,[[["self"],["configdata"]],["bool"]]],[11,"eq","","",10,[[["self"],["connectdata"]],["bool"]]],[11,"ne","","",10,[[["self"],["connectdata"]],["bool"]]],[11,"eq","","",11,[[["self"],["peerdata"]],["bool"]]],[11,"ne","","",11,[[["self"],["peerdata"]],["bool"]]],[11,"eq","","",12,[[["self"],["messagedata"]],["bool"]]],[11,"ne","","",12,[[["self"],["messagedata"]],["bool"]]],[11,"eq","","",13,[[["self"],["trackappdata"]],["bool"]]],[11,"ne","","",13,[[["self"],["trackappdata"]],["bool"]]],[11,"eq","","",14,[[["self"],["successresultdata"]],["bool"]]],[11,"ne","","",14,[[["self"],["successresultdata"]],["bool"]]],[11,"eq","","",15,[[["self"],["failureresultdata"]],["bool"]]],[11,"ne","","",15,[[["self"],["failureresultdata"]],["bool"]]],[11,"eq","","",16,[[["self"],["getdhtdata"]],["bool"]]],[11,"ne","","",16,[[["self"],["getdhtdata"]],["bool"]]],[11,"eq","","",17,[[["self"],["dhtdata"]],["bool"]]],[11,"ne","","",17,[[["self"],["dhtdata"]],["bool"]]],[11,"eq","","",18,[[["self"],["getdhtmetadata"]],["bool"]]],[11,"ne","","",18,[[["self"],["getdhtmetadata"]],["bool"]]],[11,"eq","","",19,[[["self"],["dhtmetadata"]],["bool"]]],[11,"ne","","",19,[[["self"],["dhtmetadata"]],["bool"]]],[11,"eq","","",20,[[["self"],["protocolwrapper"]],["bool"]]],[11,"ne","","",20,[[["self"],["protocolwrapper"]],["bool"]]],[11,"from","holochain_net_connection::protocol","",4,[[["protocol"]],["self"]]],[11,"from","","",4,[[["protocol"]],["self"]]],[11,"from","","",7,[[["namedbinarydata"]],["self"]]],[11,"from","","",7,[[["namedbinarydata"]],["self"]]],[11,"from","","",7,[[["str"]],["self"]]],[11,"from","","",7,[[["string"]],["self"]]],[11,"from","","",7,[[["protocolwrapper"]],["self"]]],[11,"from","","",7,[[["protocolwrapper"]],["self"]]],[11,"clone","","",7,[[["self"]],["protocol"]]],[11,"clone","","",4,[[["self"]],["namedbinarydata"]]],[11,"clone","","",5,[[["self"]],["pingdata"]]],[11,"clone","","",6,[[["self"]],["pongdata"]]],[11,"clone","holochain_net_connection::protocol_wrapper","",8,[[["self"]],["statedata"]]],[11,"clone","","",9,[[["self"]],["configdata"]]],[11,"clone","","",10,[[["self"]],["connectdata"]]],[11,"clone","","",11,[[["self"]],["peerdata"]]],[11,"clone","","",12,[[["self"]],["messagedata"]]],[11,"clone","","",13,[[["self"]],["trackappdata"]]],[11,"clone","","",14,[[["self"]],["successresultdata"]]],[11,"clone","","",15,[[["self"]],["failureresultdata"]]],[11,"clone","","",16,[[["self"]],["getdhtdata"]]],[11,"clone","","",17,[[["self"]],["dhtdata"]]],[11,"clone","","",18,[[["self"]],["getdhtmetadata"]]],[11,"clone","","",19,[[["self"]],["dhtmetadata"]]],[11,"clone","","",20,[[["self"]],["protocolwrapper"]]],[11,"fmt","holochain_net_connection::protocol","",7,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",4,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",5,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",6,[[["self"],["formatter"]],["result"]]],[11,"fmt","holochain_net_connection::protocol_wrapper","",8,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",9,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",10,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",11,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",12,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",13,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",14,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",15,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",16,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",17,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",18,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",19,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",20,[[["self"],["formatter"]],["result"]]],[11,"try_from","","",8,[[["jsonstring"]],["result"]]],[11,"try_from","","",8,[[["jsonstring"]],["result"]]],[11,"try_from","","",9,[[["jsonstring"]],["result"]]],[11,"try_from","","",9,[[["jsonstring"]],["result"]]],[11,"try_from","","",10,[[["jsonstring"]],["result"]]],[11,"try_from","","",10,[[["jsonstring"]],["result"]]],[11,"try_from","","",11,[[["jsonstring"]],["result"]]],[11,"try_from","","",11,[[["jsonstring"]],["result"]]],[11,"try_from","","",12,[[["jsonstring"]],["result"]]],[11,"try_from","","",12,[[["jsonstring"]],["result"]]],[11,"try_from","","",13,[[["jsonstring"]],["result"]]],[11,"try_from","","",13,[[["jsonstring"]],["result"]]],[11,"try_from","","",14,[[["jsonstring"]],["result"]]],[11,"try_from","","",14,[[["jsonstring"]],["result"]]],[11,"try_from","","",15,[[["jsonstring"]],["result"]]],[11,"try_from","","",15,[[["jsonstring"]],["result"]]],[11,"try_from","","",16,[[["jsonstring"]],["result"]]],[11,"try_from","","",16,[[["jsonstring"]],["result"]]],[11,"try_from","","",17,[[["jsonstring"]],["result"]]],[11,"try_from","","",17,[[["jsonstring"]],["result"]]],[11,"try_from","","",18,[[["jsonstring"]],["result"]]],[11,"try_from","","",18,[[["jsonstring"]],["result"]]],[11,"try_from","","",19,[[["jsonstring"]],["result"]]],[11,"try_from","","",19,[[["jsonstring"]],["result"]]],[11,"try_from","","",20,[[["jsonstring"]],["result"]]],[11,"try_from","","",20,[[["jsonstring"]],["result"]]],[11,"try_from","","",20,[[["protocol"]],["result",["error"]]]],[11,"try_from","","",20,[[["protocol"]],["result",["error"]]]],[11,"deserialize","holochain_net_connection::protocol","",4,[[["__d"]],["result"]]],[11,"deserialize","","",5,[[["__d"]],["result"]]],[11,"deserialize","","",6,[[["__d"]],["result"]]],[11,"deserialize","holochain_net_connection::protocol_wrapper","",8,[[["__d"]],["result"]]],[11,"deserialize","","",9,[[["__d"]],["result"]]],[11,"deserialize","","",10,[[["__d"]],["result"]]],[11,"deserialize","","",11,[[["__d"]],["result"]]],[11,"deserialize","","",12,[[["__d"]],["result"]]],[11,"deserialize","","",13,[[["__d"]],["result"]]],[11,"deserialize","","",14,[[["__d"]],["result"]]],[11,"deserialize","","",15,[[["__d"]],["result"]]],[11,"deserialize","","",16,[[["__d"]],["result"]]],[11,"deserialize","","",17,[[["__d"]],["result"]]],[11,"deserialize","","",18,[[["__d"]],["result"]]],[11,"deserialize","","",19,[[["__d"]],["result"]]],[11,"deserialize","","",20,[[["__d"]],["result"]]],[11,"serialize","holochain_net_connection::protocol","",4,[[["self"],["__s"]],["result"]]],[11,"serialize","","",5,[[["self"],["__s"]],["result"]]],[11,"serialize","","",6,[[["self"],["__s"]],["result"]]],[11,"serialize","holochain_net_connection::protocol_wrapper","",8,[[["self"],["__s"]],["result"]]],[11,"serialize","","",9,[[["self"],["__s"]],["result"]]],[11,"serialize","","",10,[[["self"],["__s"]],["result"]]],[11,"serialize","","",11,[[["self"],["__s"]],["result"]]],[11,"serialize","","",12,[[["self"],["__s"]],["result"]]],[11,"serialize","","",13,[[["self"],["__s"]],["result"]]],[11,"serialize","","",14,[[["self"],["__s"]],["result"]]],[11,"serialize","","",15,[[["self"],["__s"]],["result"]]],[11,"serialize","","",16,[[["self"],["__s"]],["result"]]],[11,"serialize","","",17,[[["self"],["__s"]],["result"]]],[11,"serialize","","",18,[[["self"],["__s"]],["result"]]],[11,"serialize","","",19,[[["self"],["__s"]],["result"]]],[11,"serialize","","",20,[[["self"],["__s"]],["result"]]]],"paths":[[8,"NetConnection"],[8,"NetWorker"],[3,"NetConnectionRelay"],[3,"NetConnectionThread"],[3,"NamedBinaryData"],[3,"PingData"],[3,"PongData"],[4,"Protocol"],[3,"StateData"],[3,"ConfigData"],[3,"ConnectData"],[3,"PeerData"],[3,"MessageData"],[3,"TrackAppData"],[3,"SuccessResultData"],[3,"FailureResultData"],[3,"GetDhtData"],[3,"DhtData"],[3,"GetDhtMetaData"],[3,"DhtMetaData"],[4,"ProtocolWrapper"]]};
searchIndex["holochain_net_ipc"]={"doc":"Networking / P2P IPC Abstraction","items":[[0,"errors","holochain_net_ipc","This module holds net_ipc custom error types.",N,N],[4,"IpcError","holochain_net_ipc::errors","net_ipc-specific error types",N,N],[13,"MissingDataError","","Translate an Option<_> unwrap into a Result::Err",0,N],[13,"Timeout","","Socket timeout",0,N],[13,"GenericError","","Otherwise undefined error message",0,N],[12,"error","holochain_net_ipc::errors::IpcError","",0,N],[6,"Result","holochain_net_ipc::errors","Default result type for net_ipc modules that `use errors::*`.",N,N],[0,"context","holochain_net_ipc","This module uses lazy_static! to make the zmq::Context easier to work with Just make sure to call IpcClient::destroy_context() when ready",N,N],[3,"ZMQ_CTX","holochain_net_ipc::context","pseudo global for zmq::Context",N,N],[5,"socket","","Create a new zmq socket using the lazy_static! global",N,[[["sockettype"]],["result",["socket"]]]],[5,"destroy","","Destroy the lazy_static! global",N,[[],["result"]]],[0,"socket","holochain_net_ipc","This module is a thin wrapper around a ZMQ socket It allows us to easily mock it out for unit tests as well as manage context with lazy_static!",N,N],[3,"ZmqIpcSocket","holochain_net_ipc::socket","this is the concrete ZMQ implementation of the IpcSocket trait",N,N],[3,"TestStruct","","helper for working with mock sockets",N,N],[3,"MockIpcSocket","","This is a concrete implementation of the IpcSocket trait for use in testing",N,N],[5,"make_test_channels","","helper to create mock socket channels",N,[[],["result"]]],[8,"IpcSocket","","trait that allows zmq socket abstraction",N,N],[10,"new","","create a new socket",1,[[],["result",["box"]]]],[10,"close","","close an existing socket",1,[[["box"]],["result"]]],[10,"connect","","connect the socket to a remote end",1,[[["self"],["str"]],["result"]]],[10,"poll","","see if we have any messages waiting",1,[[["self"],["i64"]],["result",["bool"]]]],[10,"recv","","if we DO have messages, fetch them",1,[[["self"]],["result",["vec"]]]],[10,"send","","send data to the remote end of the socket",1,N],[11,"new_test","","",2,[[["teststruct"]],["result",["box"]]]],[0,"util","holochain_net_ipc","This module holds util functions, such as constructing time related values",N,N],[5,"get_millis","holochain_net_ipc::util","helper to get milliseconds since the unix epoch as an f64",N,[[],["f64"]]],[0,"ipc_client","holochain_net_ipc","implements a net_connection::NetWorker for messaging with an ipc p2p node",N,N],[3,"IpcClient","holochain_net_ipc::ipc_client","NetWorker for messaging with an ipc p2p node",N,N],[11,"new","","establish a new ipc connection for now, the api simplicity is worth blocking the thread on connection",3,[[["nethandler"],["box",["ipcsocket"]],["bool"]],["netresult"]]],[14,"bail_generic","holochain_net_ipc","Macro akin to `bail!()` but returns an IpcError::GenericError.",N,N],[11,"from","holochain_net_ipc::errors","",0,[[["t"]],["t"]]],[11,"into","","",0,[[["self"]],["u"]]],[11,"to_owned","","",0,[[["self"]],["t"]]],[11,"clone_into","","",0,N],[11,"to_string","","",0,[[["self"]],["string"]]],[11,"try_from","","",0,[[["u"]],["result"]]],[11,"borrow","","",0,[[["self"]],["t"]]],[11,"get_type_id","","",0,[[["self"]],["typeid"]]],[11,"try_into","","",0,[[["self"]],["result"]]],[11,"borrow_mut","","",0,[[["self"]],["t"]]],[11,"as_fail","","",0,[[["self"]],["fail"]]],[11,"clone_box","","",0,N],[11,"from","holochain_net_ipc::context","",4,[[["t"]],["t"]]],[11,"into","","",4,[[["self"]],["u"]]],[11,"try_from","","",4,[[["u"]],["result"]]],[11,"borrow","","",4,[[["self"]],["t"]]],[11,"get_type_id","","",4,[[["self"]],["typeid"]]],[11,"try_into","","",4,[[["self"]],["result"]]],[11,"borrow_mut","","",4,[[["self"]],["t"]]],[11,"from","holochain_net_ipc::socket","",5,[[["t"]],["t"]]],[11,"into","","",5,[[["self"]],["u"]]],[11,"try_from","","",5,[[["u"]],["result"]]],[11,"borrow","","",5,[[["self"]],["t"]]],[11,"get_type_id","","",5,[[["self"]],["typeid"]]],[11,"try_into","","",5,[[["self"]],["result"]]],[11,"borrow_mut","","",5,[[["self"]],["t"]]],[11,"from","","",6,[[["t"]],["t"]]],[11,"into","","",6,[[["self"]],["u"]]],[11,"try_from","","",6,[[["u"]],["result"]]],[11,"borrow","","",6,[[["self"]],["t"]]],[11,"get_type_id","","",6,[[["self"]],["typeid"]]],[11,"try_into","","",6,[[["self"]],["result"]]],[11,"borrow_mut","","",6,[[["self"]],["t"]]],[11,"from","","",2,[[["t"]],["t"]]],[11,"into","","",2,[[["self"]],["u"]]],[11,"try_from","","",2,[[["u"]],["result"]]],[11,"borrow","","",2,[[["self"]],["t"]]],[11,"get_type_id","","",2,[[["self"]],["typeid"]]],[11,"try_into","","",2,[[["self"]],["result"]]],[11,"borrow_mut","","",2,[[["self"]],["t"]]],[11,"from","holochain_net_ipc::ipc_client","",3,[[["t"]],["t"]]],[11,"into","","",3,[[["self"]],["u"]]],[11,"try_from","","",3,[[["u"]],["result"]]],[11,"borrow","","",3,[[["self"]],["t"]]],[11,"get_type_id","","",3,[[["self"]],["typeid"]]],[11,"try_into","","",3,[[["self"]],["result"]]],[11,"borrow_mut","","",3,[[["self"]],["t"]]],[11,"new","holochain_net_ipc::socket","",5,[[],["result",["box"]]]],[11,"close","","",5,[[["box"]],["result"]]],[11,"connect","","",5,[[["self"],["str"]],["result"]]],[11,"poll","","",5,[[["self"],["i64"]],["result",["bool"]]]],[11,"recv","","",5,[[["self"]],["result",["vec"]]]],[11,"send","","",5,N],[11,"new","","",2,[[],["result",["box"]]]],[11,"close","","",2,[[["box"]],["result"]]],[11,"connect","","",2,[[["self"],["str"]],["result"]]],[11,"poll","","",2,[[["self"],["i64"]],["result",["bool"]]]],[11,"recv","","",2,[[["self"]],["result",["vec"]]]],[11,"send","","",2,N],[11,"clone","holochain_net_ipc::errors","",0,[[["self"]],["ipcerror"]]],[11,"fmt","","",0,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",0,[[["self"],["formatter"]],["result"]]],[11,"deref","holochain_net_ipc::context","",4,[[["self"]],["mutex"]]],[11,"cause","holochain_net_ipc::errors","",0,[[["self"]],["option",["fail"]]]],[11,"backtrace","","",0,[[["self"]],["option",["backtrace"]]]],[11,"stop","holochain_net_ipc::ipc_client","stop the worker",3,[[["box"]],["netresult"]]],[11,"receive","","handle messages sent to us from holochain_net",3,[[["self"],["protocol"]],["netresult"]]],[11,"tick","","perform upkeep (like ping/pong messages) on the underlying ipc socket",3,[[["self"]],["netresult",["bool"]]]],[11,"initialize","holochain_net_ipc::context","",4,[[["self"]]]]],"paths":[[4,"IpcError"],[8,"IpcSocket"],[3,"MockIpcSocket"],[3,"IpcClient"],[3,"ZMQ_CTX"],[3,"ZmqIpcSocket"],[3,"TestStruct"]]};
searchIndex["holochain_sodium"]={"doc":"","items":[[5,"check_init","holochain_sodium","make sure sodium_init is called",N,[[]]],[0,"random","","This module provides access to libsodium randomization functions",N,N],[5,"buf","holochain_sodium::random","randomize the provided SecBuf",N,[[["secbuf"]]]],[0,"secbuf","holochain_sodium","This module provides an abstraction for memory for use with libsodium",N,N],[3,"SecBuf","holochain_sodium::secbuf","A SecBuf is a memory buffer for use with libsodium functions. It can be backed by insecure (raw) memory for things like public keys, or secure (mlocked / mprotected) memory for things like private keys.",N,N],[3,"Locker","","a helper object that will automatically secure a SecBuf when dropped",N,N],[4,"ProtectState","","Represents the memory protection state of a SecBuf",N,N],[13,"NoAccess","","",0,N],[13,"ReadOnly","","",0,N],[13,"ReadWrite","","",0,N],[11,"with_insecure","","create a new SecBuf backed by insecure memory (for things like public keys)",1,[[["usize"]],["self"]]],[11,"with_secure","","create a new SecBuf backed by secure memory (for things like private keys) warning: funky sizes may result in mis-alignment",1,[[["usize"]],["self"]]],[11,"protect_state","","what is the current memory protection state of this SecBuf?",1,[[["self"]],["protectstate"]]],[11,"readable","","make this SecBuf readable",1,[[["self"]]]],[11,"writable","","make this SecBuf writable",1,[[["self"]]]],[11,"noaccess","","secure this SecBuf against reading or writing",1,[[["self"]]]],[11,"read_lock","","make this SecBuf readable, and return a locker object that will secure this SecBuf automatically when it goes out of scope.",1,[[["self"]],["locker"]]],[11,"write_lock","","make this SecBuf writeable, and return a locker object that will secure this SecBuf automatically when it goes out of scope.",1,[[["self"]],["locker"]]],[11,"new","","",2,[[["secbuf"],["bool"]],["self"]]],[0,"util","holochain_sodium","This module provides access to libsodium utility and memory functions",N,N],[5,"zero","holochain_sodium::util","zero all memory within the provided SecBuf",N,[[["secbuf"]]]],[11,"from","holochain_sodium::secbuf","",1,[[["t"]],["t"]]],[11,"into","","",1,[[["self"]],["u"]]],[11,"try_from","","",1,[[["u"]],["result"]]],[11,"borrow","","",1,[[["self"]],["t"]]],[11,"get_type_id","","",1,[[["self"]],["typeid"]]],[11,"try_into","","",1,[[["self"]],["result"]]],[11,"borrow_mut","","",1,[[["self"]],["t"]]],[11,"from","","",2,[[["t"]],["t"]]],[11,"into","","",2,[[["self"]],["u"]]],[11,"try_from","","",2,[[["u"]],["result"]]],[11,"borrow","","",2,[[["self"]],["t"]]],[11,"get_type_id","","",2,[[["self"]],["typeid"]]],[11,"try_into","","",2,[[["self"]],["result"]]],[11,"borrow_mut","","",2,[[["self"]],["t"]]],[11,"from","","",0,[[["t"]],["t"]]],[11,"into","","",0,[[["self"]],["u"]]],[11,"to_owned","","",0,[[["self"]],["t"]]],[11,"clone_into","","",0,N],[11,"try_from","","",0,[[["u"]],["result"]]],[11,"borrow","","",0,[[["self"]],["t"]]],[11,"get_type_id","","",0,[[["self"]],["typeid"]]],[11,"try_into","","",0,[[["self"]],["result"]]],[11,"borrow_mut","","",0,[[["self"]],["t"]]],[11,"eq","","",0,[[["self"],["protectstate"]],["bool"]]],[11,"clone","","",0,[[["self"]],["protectstate"]]],[11,"drop","","",2,[[["self"]]]],[11,"fmt","","",0,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",1,[[["self"],["formatter"]],["result"]]],[11,"deref","","",1,N],[11,"deref","","",2,[[["self"]],["secbuf"]]],[11,"deref_mut","","",1,N],[11,"deref_mut","","",2,[[["self"]],["secbuf"]]]],"paths":[[4,"ProtectState"],[3,"SecBuf"],[3,"Locker"]]};
searchIndex["holochain_test_bin"]={"doc":"","items":[],"paths":[]};
searchIndex["holochain_wasm_utils"]={"doc":"Library holding necessary code for the Ribosome  that is also useful for hdk-rust, or more generally for making rust code that the Ribosome can run. Must not have any dependency with any other Holochain crates.","items":[[0,"api_serialization","holochain_wasm_utils","ignore api_serialization because it is nothing but structs to hold serialization",N,N],[3,"ZomeFnCallArgs","holochain_wasm_utils::api_serialization","Struct for input data received when Zome API function call() is invoked",N,N],[12,"instance_handle","","",0,N],[12,"zome_name","","",0,N],[12,"cap","","",0,N],[12,"fn_name","","",0,N],[12,"fn_args","","",0,N],[3,"UpdateEntryArgs","","Struct for input data received when Zome API function update_entry() is invoked",N,N],[12,"new_entry","","",1,N],[12,"address","","",1,N],[3,"ZomeApiGlobals","","",N,N],[12,"dna_name","","",2,N],[12,"dna_hash","","",2,N],[12,"agent_id_str","","",2,N],[12,"agent_address","","",2,N],[12,"agent_initial_hash","","",2,N],[12,"agent_latest_hash","","",2,N],[0,"get_entry","","This module holds structs for all arguments and return types that get serialized and deserialized between core native and the WASM based ribosome.",N,N],[3,"GetEntryOptions","holochain_wasm_utils::api_serialization::get_entry","Structure used to specify what should be returned to a call to get_entry_result() The default is to return the latest entry.",N,N],[12,"status_request","","",3,N],[12,"entry","","",3,N],[12,"header","","",3,N],[12,"sources","","",3,N],[3,"GetEntryArgs","","",N,N],[12,"address","","",4,N],[12,"options","","",4,N],[3,"EntryResultMeta","","",N,N],[12,"address","","",5,N],[12,"entry_type","","",5,N],[12,"crud_status","","",5,N],[3,"GetEntryResultItem","","Structure that holds data returned from a get entry request. When the meta is None, we know the entry wasn't found.  This is because at the very least the entry_type and the address will be returned if nothing else was requested in the GetEntryOptions",N,N],[12,"meta","","",6,N],[12,"entry","","",6,N],[3,"EntryHistory","","Structure that holds a whole crud status history if the status request in the GetEntryOptions was set to StatusRequestKind::All",N,N],[12,"items","","",7,N],[12,"crud_links","","",7,N],[3,"GetEntryResult","","",N,N],[12,"result","","",8,N],[4,"StatusRequestKind","","",N,N],[13,"Initial","","",9,N],[13,"Latest","","",9,N],[13,"All","","",9,N],[4,"GetEntryResultType","","",N,N],[13,"Single","","",10,N],[13,"All","","",10,N],[11,"new","","",3,[[["statusrequestkind"],["bool"],["bool"],["bool"]],["self"]]],[11,"new","","",6,[[["option",["entrywithmeta"]]],["self"]]],[11,"new","","",7,[[],["self"]]],[11,"push","","",7,[[["self"],["entrywithmeta"]]]],[11,"new","","",8,[[["statusrequestkind"],["option",["entrywithmeta"]]],["self"]]],[11,"found","","",8,[[["self"]],["bool"]]],[11,"clear","","clears the entry result to be equivalent to not found",8,[[["self"]]]],[11,"push","","adds an item to history, or if Single, writes over the current value of the item",8,[[["self"],["entrywithmeta"]]]],[11,"latest","","returns the entry searched for.  Note that if the GetEntryOptions did not include a request for the entry value, this function will return None even if the entry was found.",8,[[["self"]],["option",["entry"]]]],[0,"get_links","holochain_wasm_utils::api_serialization","",N,N],[3,"GetLinksArgs","holochain_wasm_utils::api_serialization::get_links","",N,N],[12,"entry_address","","",11,N],[12,"tag","","",11,N],[3,"GetLinksResult","","",N,N],[11,"new","","",12,[[["vec",["address"]]],["getlinksresult"]]],[11,"addresses","","",12,[[["self"]],["vec"]]],[0,"link_entries","holochain_wasm_utils::api_serialization","",N,N],[3,"LinkEntriesArgs","holochain_wasm_utils::api_serialization::link_entries","",N,N],[12,"base","","",13,N],[12,"target","","",13,N],[12,"tag","","",13,N],[11,"to_link","","",13,[[["self"]],["link"]]],[0,"query","holochain_wasm_utils::api_serialization","",N,N],[3,"QueryArgs","holochain_wasm_utils::api_serialization::query","",N,N],[12,"entry_type_name","","",14,N],[12,"start","","",14,N],[12,"limit","","",14,N],[6,"QueryResult","","",N,N],[0,"send","holochain_wasm_utils::api_serialization","",N,N],[3,"SendArgs","holochain_wasm_utils::api_serialization::send","Struct for input data received when Zome API function send() is invoked",N,N],[12,"to_agent","","",15,N],[12,"payload","","",15,N],[0,"validation","holochain_wasm_utils::api_serialization","",N,N],[3,"EntryValidationArgs","holochain_wasm_utils::api_serialization::validation","",N,N],[12,"entry_type","","",16,N],[12,"entry","","",16,N],[12,"validation_data","","",16,N],[3,"LinkValidationPackageArgs","","",N,N],[12,"entry_type","","",17,N],[12,"tag","","",17,N],[12,"direction","","",17,N],[3,"LinkValidationArgs","","",N,N],[12,"entry_type","","",18,N],[12,"link","","",18,N],[12,"direction","","",18,N],[12,"validation_data","","",18,N],[4,"LinkDirection","","",N,N],[13,"To","","",19,N],[13,"From","","",19,N],[17,"THIS_INSTANCE","holochain_wasm_utils::api_serialization","",N,N],[0,"macros","holochain_wasm_utils","",N,N],[0,"memory_allocation","","",N,N],[3,"SinglePageAllocation","holochain_wasm_utils::memory_allocation","SinglePageAllocation is a memory allocation garanteed to fit in a WASM 64KiB Memory Page",N,N],[3,"SinglePageStack","","Struct for managing a WASM 64KiB memory page as a stack",N,N],[5,"u32_high_bits","","returns the u16 high bits from a u32",N,[[["u32"]],["u16"]]],[5,"u32_low_bits","","returns the u16 low bits from a u32 by doing a lossy cast",N,[[["u32"]],["u16"]]],[5,"u32_split_bits","","splits the high and low bits of u32 into a tuple of u16, for destructuring convenience",N,N],[5,"u32_merge_bits","","merges 2x u16 into a single u32",N,[[["u16"],["u16"]],["u32"]]],[5,"decode_encoded_allocation","","",N,[[["u32"]],["result",["singlepageallocation","ribosomereturncode"]]]],[17,"U16_MAX","","",N,N],[11,"new","","",20,[[["u16"],["u16"]],["result",["ribosomeerrorcode"]]]],[11,"from_encoded_allocation","","An Encoded Allocation is a u32 where 'offset' is first 16-bits and 'length' last 16-bits A valid allocation must not have a length of zero An Encoded Allocation with an offset but no length is actually an encoding of an ErrorCode",20,[[["u32"]],["result",["ribosomeerrorcode"]]]],[11,"encode","","returns a single u32 value encoding both the u16 offset and length values",20,[[["self"]],["u32"]]],[11,"offset","","",20,[[["self"]],["u16"]]],[11,"length","","",20,[[["self"]],["u16"]]],[11,"new","","",21,[[["singlepageallocation"]],["self"]]],[11,"from_encoded_allocation","","Create a SinglePageStack from a valid encoded allocation",21,[[["u32"]],["result",["ribosomeerrorcode"]]]],[11,"allocate","","",21,[[["self"],["u16"]],["u16"]]],[11,"deallocate","","",21,[[["self"],["singlepageallocation"]],["result"]]],[11,"top","","",21,[[["self"]],["u16"]]],[0,"memory_serialization","holochain_wasm_utils","",N,N],[5,"store_string","holochain_wasm_utils::memory_serialization","Write a string in wasm memory according to stack state.",N,[[["singlepagestack"],["str"]],["result",["singlepageallocation","ribosomeerrorcode"]]]],[5,"store_string_into_encoded_allocation","","",N,[[["singlepagestack"],["str"]],["i32"]]],[5,"load_string","","Retrieve a stored string from an encoded allocation. Return error code if encoded_allocation is invalid.",N,[[["u32"]],["result",["string","ribosomeerrorcode"]]]],[5,"store_as_json","","Write a data struct as a json string in wasm memory according to stack state.",N,[[["singlepagestack"],["j"]],["result",["singlepageallocation","ribosomeerrorcode"]]]],[5,"store_as_json_into_encoded_allocation","","",N,[[["singlepagestack"],["j"]],["i32"]]],[5,"load_json","","Retrieve a stored data struct from an encoded allocation. Return error string if encoded_allocation is invalid.",N,[[["u32"]],["result",["holochainerror"]]]],[5,"load_json_from_raw","","Convert a json string stored in wasm memory into a specified struct If json deserialization of custom struct failed, tries to deserialize a CoreError struct. If that also failed, tries to load a string directly, since we are expecting an error string at this stage.",N,N],[14,"zome_assert","holochain_wasm_utils","Macro for creating a RibosomeErrorCode as a RuntimeValue Result-Option on the spot Will panic! if out or memory or other serialization error occured.",N,N],[14,"ribosome_success","","",N,N],[14,"ribosome_error_code","","Macro for creating a RibosomeErrorCode as a RuntimeValue Result-Option on the spot",N,N],[14,"core_error","","Macro for creating a CoreError from a HolochainError on the spot with file!() and line!()",N,N],[14,"core_error_generic","","Macro for creating a generic CoreError on the spot with file!() and line!()",N,N],[11,"from","holochain_wasm_utils::api_serialization","",0,[[["t"]],["t"]]],[11,"into","","",0,[[["self"]],["u"]]],[11,"to_owned","","",0,[[["self"]],["t"]]],[11,"clone_into","","",0,N],[11,"try_from","","",0,[[["u"]],["result"]]],[11,"borrow","","",0,[[["self"]],["t"]]],[11,"get_type_id","","",0,[[["self"]],["typeid"]]],[11,"try_into","","",0,[[["self"]],["result"]]],[11,"borrow_mut","","",0,[[["self"]],["t"]]],[11,"equivalent","","",0,[[["self"],["k"]],["bool"]]],[11,"clone_box","","",0,N],[11,"from","","",1,[[["t"]],["t"]]],[11,"into","","",1,[[["self"]],["u"]]],[11,"to_owned","","",1,[[["self"]],["t"]]],[11,"clone_into","","",1,N],[11,"try_from","","",1,[[["u"]],["result"]]],[11,"borrow","","",1,[[["self"]],["t"]]],[11,"get_type_id","","",1,[[["self"]],["typeid"]]],[11,"try_into","","",1,[[["self"]],["result"]]],[11,"borrow_mut","","",1,[[["self"]],["t"]]],[11,"clone_box","","",1,N],[11,"from","","",2,[[["t"]],["t"]]],[11,"into","","",2,[[["self"]],["u"]]],[11,"to_owned","","",2,[[["self"]],["t"]]],[11,"clone_into","","",2,N],[11,"try_from","","",2,[[["u"]],["result"]]],[11,"borrow","","",2,[[["self"]],["t"]]],[11,"get_type_id","","",2,[[["self"]],["typeid"]]],[11,"try_into","","",2,[[["self"]],["result"]]],[11,"borrow_mut","","",2,[[["self"]],["t"]]],[11,"clone_box","","",2,N],[11,"from","holochain_wasm_utils::api_serialization::get_entry","",3,[[["t"]],["t"]]],[11,"into","","",3,[[["self"]],["u"]]],[11,"to_owned","","",3,[[["self"]],["t"]]],[11,"clone_into","","",3,N],[11,"try_from","","",3,[[["u"]],["result"]]],[11,"borrow","","",3,[[["self"]],["t"]]],[11,"get_type_id","","",3,[[["self"]],["typeid"]]],[11,"try_into","","",3,[[["self"]],["result"]]],[11,"borrow_mut","","",3,[[["self"]],["t"]]],[11,"clone_box","","",3,N],[11,"from","","",4,[[["t"]],["t"]]],[11,"into","","",4,[[["self"]],["u"]]],[11,"try_from","","",4,[[["u"]],["result"]]],[11,"borrow","","",4,[[["self"]],["t"]]],[11,"get_type_id","","",4,[[["self"]],["typeid"]]],[11,"try_into","","",4,[[["self"]],["result"]]],[11,"borrow_mut","","",4,[[["self"]],["t"]]],[11,"from","","",5,[[["t"]],["t"]]],[11,"into","","",5,[[["self"]],["u"]]],[11,"to_owned","","",5,[[["self"]],["t"]]],[11,"clone_into","","",5,N],[11,"try_from","","",5,[[["u"]],["result"]]],[11,"borrow","","",5,[[["self"]],["t"]]],[11,"get_type_id","","",5,[[["self"]],["typeid"]]],[11,"try_into","","",5,[[["self"]],["result"]]],[11,"borrow_mut","","",5,[[["self"]],["t"]]],[11,"clone_box","","",5,N],[11,"from","","",6,[[["t"]],["t"]]],[11,"into","","",6,[[["self"]],["u"]]],[11,"to_owned","","",6,[[["self"]],["t"]]],[11,"clone_into","","",6,N],[11,"try_from","","",6,[[["u"]],["result"]]],[11,"borrow","","",6,[[["self"]],["t"]]],[11,"get_type_id","","",6,[[["self"]],["typeid"]]],[11,"try_into","","",6,[[["self"]],["result"]]],[11,"borrow_mut","","",6,[[["self"]],["t"]]],[11,"clone_box","","",6,N],[11,"from","","",7,[[["t"]],["t"]]],[11,"into","","",7,[[["self"]],["u"]]],[11,"to_owned","","",7,[[["self"]],["t"]]],[11,"clone_into","","",7,N],[11,"try_from","","",7,[[["u"]],["result"]]],[11,"borrow","","",7,[[["self"]],["t"]]],[11,"get_type_id","","",7,[[["self"]],["typeid"]]],[11,"try_into","","",7,[[["self"]],["result"]]],[11,"borrow_mut","","",7,[[["self"]],["t"]]],[11,"clone_box","","",7,N],[11,"from","","",8,[[["t"]],["t"]]],[11,"into","","",8,[[["self"]],["u"]]],[11,"try_from","","",8,[[["u"]],["result"]]],[11,"borrow","","",8,[[["self"]],["t"]]],[11,"get_type_id","","",8,[[["self"]],["typeid"]]],[11,"try_into","","",8,[[["self"]],["result"]]],[11,"borrow_mut","","",8,[[["self"]],["t"]]],[11,"from","","",9,[[["t"]],["t"]]],[11,"into","","",9,[[["self"]],["u"]]],[11,"to_owned","","",9,[[["self"]],["t"]]],[11,"clone_into","","",9,N],[11,"try_from","","",9,[[["u"]],["result"]]],[11,"borrow","","",9,[[["self"]],["t"]]],[11,"get_type_id","","",9,[[["self"]],["typeid"]]],[11,"try_into","","",9,[[["self"]],["result"]]],[11,"borrow_mut","","",9,[[["self"]],["t"]]],[11,"clone_box","","",9,N],[11,"from","","",10,[[["t"]],["t"]]],[11,"into","","",10,[[["self"]],["u"]]],[11,"try_from","","",10,[[["u"]],["result"]]],[11,"borrow","","",10,[[["self"]],["t"]]],[11,"get_type_id","","",10,[[["self"]],["typeid"]]],[11,"try_into","","",10,[[["self"]],["result"]]],[11,"borrow_mut","","",10,[[["self"]],["t"]]],[11,"from","holochain_wasm_utils::api_serialization::get_links","",11,[[["t"]],["t"]]],[11,"into","","",11,[[["self"]],["u"]]],[11,"to_owned","","",11,[[["self"]],["t"]]],[11,"clone_into","","",11,N],[11,"try_from","","",11,[[["u"]],["result"]]],[11,"borrow","","",11,[[["self"]],["t"]]],[11,"get_type_id","","",11,[[["self"]],["typeid"]]],[11,"try_into","","",11,[[["self"]],["result"]]],[11,"borrow_mut","","",11,[[["self"]],["t"]]],[11,"equivalent","","",11,[[["self"],["k"]],["bool"]]],[11,"clone_box","","",11,N],[11,"from","","",12,[[["t"]],["t"]]],[11,"into","","",12,[[["self"]],["u"]]],[11,"try_from","","",12,[[["u"]],["result"]]],[11,"borrow","","",12,[[["self"]],["t"]]],[11,"get_type_id","","",12,[[["self"]],["typeid"]]],[11,"try_into","","",12,[[["self"]],["result"]]],[11,"borrow_mut","","",12,[[["self"]],["t"]]],[11,"from","holochain_wasm_utils::api_serialization::link_entries","",13,[[["t"]],["t"]]],[11,"into","","",13,[[["self"]],["u"]]],[11,"try_from","","",13,[[["u"]],["result"]]],[11,"borrow","","",13,[[["self"]],["t"]]],[11,"get_type_id","","",13,[[["self"]],["typeid"]]],[11,"try_into","","",13,[[["self"]],["result"]]],[11,"borrow_mut","","",13,[[["self"]],["t"]]],[11,"from","holochain_wasm_utils::api_serialization::query","",14,[[["t"]],["t"]]],[11,"into","","",14,[[["self"]],["u"]]],[11,"try_from","","",14,[[["u"]],["result"]]],[11,"borrow","","",14,[[["self"]],["t"]]],[11,"get_type_id","","",14,[[["self"]],["typeid"]]],[11,"try_into","","",14,[[["self"]],["result"]]],[11,"borrow_mut","","",14,[[["self"]],["t"]]],[11,"from","holochain_wasm_utils::api_serialization::send","",15,[[["t"]],["t"]]],[11,"into","","",15,[[["self"]],["u"]]],[11,"to_owned","","",15,[[["self"]],["t"]]],[11,"clone_into","","",15,N],[11,"try_from","","",15,[[["u"]],["result"]]],[11,"borrow","","",15,[[["self"]],["t"]]],[11,"get_type_id","","",15,[[["self"]],["typeid"]]],[11,"try_into","","",15,[[["self"]],["result"]]],[11,"borrow_mut","","",15,[[["self"]],["t"]]],[11,"clone_box","","",15,N],[11,"from","holochain_wasm_utils::api_serialization::validation","",16,[[["t"]],["t"]]],[11,"into","","",16,[[["self"]],["u"]]],[11,"try_from","","",16,[[["u"]],["result"]]],[11,"borrow","","",16,[[["self"]],["t"]]],[11,"get_type_id","","",16,[[["self"]],["typeid"]]],[11,"try_into","","",16,[[["self"]],["result"]]],[11,"borrow_mut","","",16,[[["self"]],["t"]]],[11,"from","","",17,[[["t"]],["t"]]],[11,"into","","",17,[[["self"]],["u"]]],[11,"to_owned","","",17,[[["self"]],["t"]]],[11,"clone_into","","",17,N],[11,"try_from","","",17,[[["u"]],["result"]]],[11,"borrow","","",17,[[["self"]],["t"]]],[11,"get_type_id","","",17,[[["self"]],["typeid"]]],[11,"try_into","","",17,[[["self"]],["result"]]],[11,"borrow_mut","","",17,[[["self"]],["t"]]],[11,"clone_box","","",17,N],[11,"from","","",18,[[["t"]],["t"]]],[11,"into","","",18,[[["self"]],["u"]]],[11,"to_owned","","",18,[[["self"]],["t"]]],[11,"clone_into","","",18,N],[11,"try_from","","",18,[[["u"]],["result"]]],[11,"borrow","","",18,[[["self"]],["t"]]],[11,"get_type_id","","",18,[[["self"]],["typeid"]]],[11,"try_into","","",18,[[["self"]],["result"]]],[11,"borrow_mut","","",18,[[["self"]],["t"]]],[11,"clone_box","","",18,N],[11,"from","","",19,[[["t"]],["t"]]],[11,"into","","",19,[[["self"]],["u"]]],[11,"to_owned","","",19,[[["self"]],["t"]]],[11,"clone_into","","",19,N],[11,"try_from","","",19,[[["u"]],["result"]]],[11,"borrow","","",19,[[["self"]],["t"]]],[11,"get_type_id","","",19,[[["self"]],["typeid"]]],[11,"try_into","","",19,[[["self"]],["result"]]],[11,"borrow_mut","","",19,[[["self"]],["t"]]],[11,"clone_box","","",19,N],[11,"from","holochain_wasm_utils::memory_allocation","",20,[[["t"]],["t"]]],[11,"into","","",20,[[["self"]],["u"]]],[11,"to_owned","","",20,[[["self"]],["t"]]],[11,"clone_into","","",20,N],[11,"try_from","","",20,[[["u"]],["result"]]],[11,"borrow","","",20,[[["self"]],["t"]]],[11,"get_type_id","","",20,[[["self"]],["typeid"]]],[11,"try_into","","",20,[[["self"]],["result"]]],[11,"borrow_mut","","",20,[[["self"]],["t"]]],[11,"clone_box","","",20,N],[11,"from","","",21,[[["t"]],["t"]]],[11,"into","","",21,[[["self"]],["u"]]],[11,"to_owned","","",21,[[["self"]],["t"]]],[11,"clone_into","","",21,N],[11,"try_from","","",21,[[["u"]],["result"]]],[11,"borrow","","",21,[[["self"]],["t"]]],[11,"get_type_id","","",21,[[["self"]],["typeid"]]],[11,"try_into","","",21,[[["self"]],["result"]]],[11,"borrow_mut","","",21,[[["self"]],["t"]]],[11,"clone_box","","",21,N],[11,"eq","holochain_wasm_utils::api_serialization","",0,[[["self"],["zomefncallargs"]],["bool"]]],[11,"ne","","",0,[[["self"],["zomefncallargs"]],["bool"]]],[11,"eq","holochain_wasm_utils::api_serialization::get_entry","",9,[[["self"],["statusrequestkind"]],["bool"]]],[11,"eq","holochain_wasm_utils::api_serialization::get_links","",11,[[["self"],["getlinksargs"]],["bool"]]],[11,"ne","","",11,[[["self"],["getlinksargs"]],["bool"]]],[11,"eq","holochain_wasm_utils::api_serialization::send","",15,[[["self"],["sendargs"]],["bool"]]],[11,"ne","","",15,[[["self"],["sendargs"]],["bool"]]],[11,"eq","holochain_wasm_utils::api_serialization","",1,[[["self"],["updateentryargs"]],["bool"]]],[11,"ne","","",1,[[["self"],["updateentryargs"]],["bool"]]],[11,"eq","holochain_wasm_utils::api_serialization::validation","",19,[[["self"],["linkdirection"]],["bool"]]],[11,"clone","holochain_wasm_utils::api_serialization","",0,[[["self"]],["zomefncallargs"]]],[11,"clone","holochain_wasm_utils::api_serialization::get_entry","",9,[[["self"]],["statusrequestkind"]]],[11,"clone","","",3,[[["self"]],["getentryoptions"]]],[11,"clone","","",5,[[["self"]],["entryresultmeta"]]],[11,"clone","","",6,[[["self"]],["getentryresultitem"]]],[11,"clone","","",7,[[["self"]],["entryhistory"]]],[11,"clone","holochain_wasm_utils::api_serialization::get_links","",11,[[["self"]],["getlinksargs"]]],[11,"clone","holochain_wasm_utils::api_serialization::send","",15,[[["self"]],["sendargs"]]],[11,"clone","holochain_wasm_utils::api_serialization","",1,[[["self"]],["updateentryargs"]]],[11,"clone","holochain_wasm_utils::api_serialization::validation","",19,[[["self"]],["linkdirection"]]],[11,"clone","","",17,[[["self"]],["linkvalidationpackageargs"]]],[11,"clone","","",18,[[["self"]],["linkvalidationargs"]]],[11,"clone","holochain_wasm_utils::api_serialization","",2,[[["self"]],["zomeapiglobals"]]],[11,"clone","holochain_wasm_utils::memory_allocation","",20,[[["self"]],["singlepageallocation"]]],[11,"clone","","",21,[[["self"]],["singlepagestack"]]],[11,"default","holochain_wasm_utils::api_serialization","",0,[[],["zomefncallargs"]]],[11,"default","holochain_wasm_utils::api_serialization::get_entry","",9,[[],["self"]]],[11,"default","","",3,[[],["self"]]],[11,"default","holochain_wasm_utils::api_serialization::get_links","",11,[[],["getlinksargs"]]],[11,"default","holochain_wasm_utils::api_serialization::link_entries","",13,[[],["linkentriesargs"]]],[11,"default","holochain_wasm_utils::api_serialization::query","",14,[[],["queryargs"]]],[11,"default","holochain_wasm_utils::memory_allocation","",21,[[],["singlepagestack"]]],[11,"fmt","holochain_wasm_utils::api_serialization","",0,[[["self"],["formatter"]],["result"]]],[11,"fmt","holochain_wasm_utils::api_serialization::get_entry","",9,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",3,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",4,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",5,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",6,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",7,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",10,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",8,[[["self"],["formatter"]],["result"]]],[11,"fmt","holochain_wasm_utils::api_serialization::get_links","",11,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",12,[[["self"],["formatter"]],["result"]]],[11,"fmt","holochain_wasm_utils::api_serialization::link_entries","",13,[[["self"],["formatter"]],["result"]]],[11,"fmt","holochain_wasm_utils::api_serialization::query","",14,[[["self"],["formatter"]],["result"]]],[11,"fmt","holochain_wasm_utils::api_serialization::send","",15,[[["self"],["formatter"]],["result"]]],[11,"fmt","holochain_wasm_utils::api_serialization","",1,[[["self"],["formatter"]],["result"]]],[11,"fmt","holochain_wasm_utils::api_serialization::validation","",16,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",19,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",17,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",18,[[["self"],["formatter"]],["result"]]],[11,"fmt","holochain_wasm_utils::api_serialization","",2,[[["self"],["formatter"]],["result"]]],[11,"fmt","holochain_wasm_utils::memory_allocation","",20,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",21,[[["self"],["formatter"]],["result"]]],[11,"try_from","holochain_wasm_utils::api_serialization","",0,[[["jsonstring"]],["result"]]],[11,"try_from","","",0,[[["jsonstring"]],["result"]]],[11,"try_from","holochain_wasm_utils::api_serialization::get_entry","",9,[[["jsonstring"]],["result"]]],[11,"try_from","","",9,[[["jsonstring"]],["result"]]],[11,"try_from","","",3,[[["jsonstring"]],["result"]]],[11,"try_from","","",3,[[["jsonstring"]],["result"]]],[11,"try_from","","",4,[[["jsonstring"]],["result"]]],[11,"try_from","","",4,[[["jsonstring"]],["result"]]],[11,"try_from","","",5,[[["jsonstring"]],["result"]]],[11,"try_from","","",5,[[["jsonstring"]],["result"]]],[11,"try_from","","",6,[[["jsonstring"]],["result"]]],[11,"try_from","","",6,[[["jsonstring"]],["result"]]],[11,"try_from","","",7,[[["jsonstring"]],["result"]]],[11,"try_from","","",7,[[["jsonstring"]],["result"]]],[11,"try_from","","",10,[[["jsonstring"]],["result"]]],[11,"try_from","","",10,[[["jsonstring"]],["result"]]],[11,"try_from","","",8,[[["jsonstring"]],["result"]]],[11,"try_from","","",8,[[["jsonstring"]],["result"]]],[11,"try_from","holochain_wasm_utils::api_serialization::get_links","",11,[[["jsonstring"]],["result"]]],[11,"try_from","","",11,[[["jsonstring"]],["result"]]],[11,"try_from","","",12,[[["jsonstring"]],["result"]]],[11,"try_from","","",12,[[["jsonstring"]],["result"]]],[11,"try_from","holochain_wasm_utils::api_serialization::link_entries","",13,[[["jsonstring"]],["result"]]],[11,"try_from","","",13,[[["jsonstring"]],["result"]]],[11,"try_from","holochain_wasm_utils::api_serialization::query","",14,[[["jsonstring"]],["result"]]],[11,"try_from","","",14,[[["jsonstring"]],["result"]]],[11,"try_from","holochain_wasm_utils::api_serialization::send","",15,[[["jsonstring"]],["result"]]],[11,"try_from","","",15,[[["jsonstring"]],["result"]]],[11,"try_from","holochain_wasm_utils::api_serialization","",1,[[["jsonstring"]],["result"]]],[11,"try_from","","",1,[[["jsonstring"]],["result"]]],[11,"try_from","holochain_wasm_utils::api_serialization::validation","",16,[[["jsonstring"]],["result"]]],[11,"try_from","","",16,[[["jsonstring"]],["result"]]],[11,"try_from","","",19,[[["jsonstring"]],["result"]]],[11,"try_from","","",19,[[["jsonstring"]],["result"]]],[11,"try_from","","",17,[[["jsonstring"]],["result"]]],[11,"try_from","","",17,[[["jsonstring"]],["result"]]],[11,"try_from","","",18,[[["jsonstring"]],["result"]]],[11,"try_from","","",18,[[["jsonstring"]],["result"]]],[11,"try_from","holochain_wasm_utils::api_serialization","",2,[[["jsonstring"]],["result"]]],[11,"try_from","","",2,[[["jsonstring"]],["result"]]],[11,"hash","","",0,N],[11,"hash","holochain_wasm_utils::api_serialization::get_links","",11,N],[11,"serialize","holochain_wasm_utils::api_serialization","",0,[[["self"],["__s"]],["result"]]],[11,"serialize","holochain_wasm_utils::api_serialization::get_entry","",9,[[["self"],["__s"]],["result"]]],[11,"serialize","","",3,[[["self"],["__s"]],["result"]]],[11,"serialize","","",4,[[["self"],["__s"]],["result"]]],[11,"serialize","","",5,[[["self"],["__s"]],["result"]]],[11,"serialize","","",6,[[["self"],["__s"]],["result"]]],[11,"serialize","","",7,[[["self"],["__s"]],["result"]]],[11,"serialize","","",10,[[["self"],["__s"]],["result"]]],[11,"serialize","","",8,[[["self"],["__s"]],["result"]]],[11,"serialize","holochain_wasm_utils::api_serialization::get_links","",11,[[["self"],["__s"]],["result"]]],[11,"serialize","","",12,[[["self"],["__s"]],["result"]]],[11,"serialize","holochain_wasm_utils::api_serialization::link_entries","",13,[[["self"],["__s"]],["result"]]],[11,"serialize","holochain_wasm_utils::api_serialization::query","",14,[[["self"],["__s"]],["result"]]],[11,"serialize","holochain_wasm_utils::api_serialization::send","",15,[[["self"],["__s"]],["result"]]],[11,"serialize","holochain_wasm_utils::api_serialization","",1,[[["self"],["__s"]],["result"]]],[11,"serialize","holochain_wasm_utils::api_serialization::validation","",16,[[["self"],["__s"]],["result"]]],[11,"serialize","","",19,[[["self"],["__s"]],["result"]]],[11,"serialize","","",17,[[["self"],["__s"]],["result"]]],[11,"serialize","","",18,[[["self"],["__s"]],["result"]]],[11,"serialize","holochain_wasm_utils::api_serialization","",2,[[["self"],["__s"]],["result"]]],[11,"deserialize","","",0,[[["__d"]],["result"]]],[11,"deserialize","holochain_wasm_utils::api_serialization::get_entry","",9,[[["__d"]],["result"]]],[11,"deserialize","","",3,[[["__d"]],["result"]]],[11,"deserialize","","",4,[[["__d"]],["result"]]],[11,"deserialize","","",5,[[["__d"]],["result"]]],[11,"deserialize","","",6,[[["__d"]],["result"]]],[11,"deserialize","","",7,[[["__d"]],["result"]]],[11,"deserialize","","",10,[[["__d"]],["result"]]],[11,"deserialize","","",8,[[["__d"]],["result"]]],[11,"deserialize","holochain_wasm_utils::api_serialization::get_links","",11,[[["__d"]],["result"]]],[11,"deserialize","","",12,[[["__d"]],["result"]]],[11,"deserialize","holochain_wasm_utils::api_serialization::link_entries","",13,[[["__d"]],["result"]]],[11,"deserialize","holochain_wasm_utils::api_serialization::query","",14,[[["__d"]],["result"]]],[11,"deserialize","holochain_wasm_utils::api_serialization::send","",15,[[["__d"]],["result"]]],[11,"deserialize","holochain_wasm_utils::api_serialization","",1,[[["__d"]],["result"]]],[11,"deserialize","holochain_wasm_utils::api_serialization::validation","",16,[[["__d"]],["result"]]],[11,"deserialize","","",19,[[["__d"]],["result"]]],[11,"deserialize","","",17,[[["__d"]],["result"]]],[11,"deserialize","","",18,[[["__d"]],["result"]]],[11,"deserialize","holochain_wasm_utils::api_serialization","",2,[[["__d"]],["result"]]]],"paths":[[3,"ZomeFnCallArgs"],[3,"UpdateEntryArgs"],[3,"ZomeApiGlobals"],[3,"GetEntryOptions"],[3,"GetEntryArgs"],[3,"EntryResultMeta"],[3,"GetEntryResultItem"],[3,"EntryHistory"],[3,"GetEntryResult"],[4,"StatusRequestKind"],[4,"GetEntryResultType"],[3,"GetLinksArgs"],[3,"GetLinksResult"],[3,"LinkEntriesArgs"],[3,"QueryArgs"],[3,"SendArgs"],[3,"EntryValidationArgs"],[3,"LinkValidationPackageArgs"],[3,"LinkValidationArgs"],[4,"LinkDirection"],[3,"SinglePageAllocation"],[3,"SinglePageStack"]]};
searchIndex["test_bin_ipc"]={"doc":"","items":[],"paths":[]};
searchIndex["test_bin_mock_net"]={"doc":"","items":[],"paths":[]};
initSearch(searchIndex);
