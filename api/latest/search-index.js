var N = null;var searchIndex = {};
searchIndex["hc"]={"doc":"","items":[],"paths":[]};
searchIndex["hdk"]={"doc":"Holochain Development Kit (HDK)","items":[[3,"EntryValidationArgs","hdk","",N,N],[12,"entry_type","","",0,N],[12,"entry","","",0,N],[12,"validation_data","","",0,N],[4,"LinkDirection","","",N,N],[13,"To","","",1,N],[13,"From","","",1,N],[3,"LinkValidationPackageArgs","","",N,N],[12,"entry_type","","",2,N],[12,"tag","","",2,N],[12,"direction","","",2,N],[3,"LinkValidationArgs","","",N,N],[12,"entry_type","","",3,N],[12,"link","","",3,N],[12,"direction","","",3,N],[12,"validation_data","","",3,N],[3,"ValidationPackage","","",N,N],[12,"chain_header","","",4,N],[12,"source_chain_entries","","",4,N],[12,"source_chain_headers","","",4,N],[12,"custom","","",4,N],[4,"ValidationPackageDefinition","","",N,N],[13,"Entry","","",5,N],[13,"ChainEntries","","",5,N],[13,"ChainHeaders","","",5,N],[13,"ChainFull","","",5,N],[13,"Custom","","",5,N],[3,"ValidationData","","This structs carries information contextual for the process of validating an entry of link and is passed in to the according callbacks.",N,N],[12,"package","","The validation package is data from the entry's/link's source agent that is needed to determine the validity of a given entry. What specific data gets put into the validation package has to be defined throught the validation_package callbacks in the entry! and link! macros.",6,N],[12,"sources","","The list of authors that have signed this entry.",6,N],[12,"lifecycle","","In which lifecycle of the entry creation are we running this validation callback?",6,N],[12,"action","","Does the entry get committed, modified or deleted?",6,N],[4,"EntryLifecycle","","",N,N],[13,"Chain","","",7,N],[13,"Dht","","",7,N],[13,"Meta","","",7,N],[4,"EntryAction","","",N,N],[13,"Commit","","",8,N],[13,"Modify","","",8,N],[13,"Delete","","",8,N],[4,"LinkAction","","",N,N],[13,"Commit","","",9,N],[13,"Delete","","",9,N],[0,"api","","",N,N],[3,"EntryValidationArgs","hdk::api","",N,N],[12,"entry_type","","",0,N],[12,"entry","","",0,N],[12,"validation_data","","",0,N],[4,"LinkDirection","","",N,N],[13,"To","","",1,N],[13,"From","","",1,N],[3,"LinkValidationPackageArgs","","",N,N],[12,"entry_type","","",2,N],[12,"tag","","",2,N],[12,"direction","","",2,N],[3,"LinkValidationArgs","","",N,N],[12,"entry_type","","",3,N],[12,"link","","",3,N],[12,"direction","","",3,N],[12,"validation_data","","",3,N],[3,"DNA_NAME","","The `name` property as taken from the DNA.",N,N],[3,"DNA_HASH","","The hash of the DNA the Zome is embedded within. This is often useful as a fixed value that is known by all participants running the DNA.",N,N],[3,"AGENT_ID_STR","","The identity string used when the chain was first initialized.",N,N],[3,"AGENT_ADDRESS","","The hash of your public key. This is your node address on the DHT. It can be used for node-to-node messaging with `send` and `receive` functions.",N,N],[3,"AGENT_INITIAL_HASH","","The hash of the first identity entry on your chain (The second entry on your chain). This is your peer's identity on the DHT.",N,N],[3,"EntryStatus","","",N,N],[3,"GetEntryMask","","",N,N],[4,"BundleOnClose","","",N,N],[13,"Commit","","",10,N],[13,"Discard","","",10,N],[5,"debug","","Prints a string through the stdout of the running service, and also writes that string to the logger in the execution context # Examples ```rust # #[macro_use] # extern crate hdk; # extern crate holochain_core_types; # use holochain_core_types::json::JsonString;",N,[[["j"]],["zomeapiresult"]]],[5,"call","","Call an exposed function from another zome. Arguments for the called function are passed as `JsonString`. Returns the value that's returned by the given function as a json str. # Examples In order to utilize `call`, you must have at least two separate Zomes. Here are two Zome examples, where one performs a `call` into the other.",N,[[["s"],["s"],["s"],["jsonstring"]],["zomeapiresult",["jsonstring"]]]],[5,"commit_entry","","Attempts to commit an entry to your local source chain. The entry will have to pass the defined validation rules for that entry type. If the entry type is defined as public, will also publish the entry to the DHT. Returns either an address of the committed entry as a string, or an error. # Examples ```rust # #![feature(try_from)] # extern crate hdk; # extern crate serde_json; # #[macro_use] # extern crate serde_derive; # extern crate holochain_core_types; # #[macro_use] # extern crate holochain_core_types_derive; # use holochain_core_types::json::JsonString; # use holochain_core_types::error::HolochainError; # use holochain_core_types::entry::entry_type::AppEntryType; # use holochain_core_types::entry::Entry;",N,[[["entry"]],["zomeapiresult",["address"]]]],[5,"get_entry","","Retrieves an entry from the local chain or the DHT, by looking it up using its address. # Examples `rust # extern crate hdk; # extern crate holochain_core_types; # use holochain_core_types::json::JsonString; # use holochain_core_types::cas::content::Address; # fn main() { pub fn handle_get_post(post_address: Address) -> JsonString { // get_entry returns a Result<Option<T>, ZomeApiError> // where T is the type that you used to commit the entry, in this case a Blog // It's a ZomeApiError if something went wrong (i.e. wrong type in deserialization) // Otherwise its a Some(T) or a None match hdk::get_entry(post_address) { Ok(maybe_post) => maybe_post.into(), Err(e) => e.into(), } } # }`",N,[[["address"]],["zomeapiresult",["option"]]]],[5,"get_entry_result","","Retrieves an entry and meta data from the local chain or the DHT, by looking it up using its address, and a the full options to specify exactly what data to return",N,[[["address"],["getentryoptions"]],["zomeapiresult",["option"]]]],[5,"link_entries","","Consumes three values, two of which are the addresses of entries, and one of which is a string that defines a relationship between them, called a `tag`. Later, lists of entries can be looked up by using get_links. Entries can only be looked up in the direction from the `base`, which is the first argument, to the `target`. # Examples ```rust # #![feature(try_from)] # extern crate hdk; # extern crate serde_json; # #[macro_use] # extern crate serde_derive; # extern crate holochain_core_types; # #[macro_use] # extern crate holochain_core_types_derive; # use holochain_core_types::json::JsonString; # use holochain_core_types::error::HolochainError; # use holochain_core_types::entry::entry_type::AppEntryType; # use holochain_core_types::entry::Entry; # use holochain_core_types::cas::content::Address; # use hdk::AGENT_ADDRESS; # fn main() {",N,[[["address"],["address"],["s"]],["result",["zomeapierror"]]]],[5,"property","","Not Yet Available",N,[[["s"]],["zomeapiresult",["string"]]]],[5,"entry_address","","Reconstructs an address of the given entry data. This is the same value that would be returned if `entry_type_name` and `entry_value` were passed to the commit_entry function and by which it would be retrievable from the DHT using get_entry. This is often used to reconstruct an address of a `base` argument when calling get_links. # Examples ```rust # #![feature(try_from)] # extern crate hdk; # extern crate serde_json; # #[macro_use] # extern crate serde_derive; # extern crate holochain_core_types; # #[macro_use] # extern crate holochain_core_types_derive; # use holochain_core_types::json::JsonString; # use holochain_core_types::error::HolochainError; # use holochain_core_types::entry::entry_type::AppEntryType; # use holochain_core_types::entry::Entry; # fn main() {",N,[[["entry"]],["zomeapiresult",["address"]]]],[5,"sign","","Not Yet Available",N,[[["s"]],["zomeapiresult",["string"]]]],[5,"verify_signature","","Not Yet Available",N,[[["s"],["s"],["s"]],["zomeapiresult",["bool"]]]],[5,"update_entry","","Not Yet Available",N,[[["s"],["entry"],["address"]],["zomeapiresult",["address"]]]],[5,"update_agent","","Not Yet Available",N,[[],["zomeapiresult",["address"]]]],[5,"remove_entry","","Not Yet Available",N,[[["address"],["s"]],["zomeapiresult",["address"]]]],[5,"get_links","","Consumes two values, the first of which is the address of an entry, `base`, and the second of which is a string, `tag`, used to describe the relationship between the `base` and other entries you wish to lookup. Returns a list of addresses of other entries which matched as being linked by the given `tag`. Links are created in the first place using the Zome API function link_entries. Once you have the addresses, there is a good likelihood that you will wish to call get_entry for each of them. # Examples ```rust # extern crate hdk; # extern crate holochain_core_types; # use holochain_core_types::json::JsonString; # use holochain_core_types::cas::content::Address;",N,[[["address"],["s"]],["zomeapiresult",["getlinksresult"]]]],[5,"query","","Returns a list of entries from your local source chain, that match a given type. entry_type_name: Specify type of entry to retrieve limit: Max number of entries to retrieve",N,[[["str"],["u32"],["u32"]],["zomeapiresult",["queryresult"]]]],[5,"send","","Not Yet Available",N,[[["address"],["value"]],["zomeapiresult",["value"]]]],[5,"start_bundle","","Not Yet Available",N,[[["usize"],["value"]],["zomeapiresult"]]],[5,"close_bundle","","Not Yet Available",N,[[["bundleonclose"]],["zomeapiresult"]]],[5,"check_for_ribosome_error","","",N,[[["u32"]],["result",["zomeapierror"]]]],[18,"LIVE","","",11,N],[18,"REJECTED","","",11,N],[18,"DELETED","","",11,N],[18,"MODIFIED","","",11,N],[11,"empty","","Returns an empty set of flags.",11,[[],["entrystatus"]]],[11,"all","","Returns the set containing all flags.",11,[[],["entrystatus"]]],[11,"bits","","Returns the raw value of the flags currently stored.",11,[[["self"]],["u8"]]],[11,"from_bits","","Convert from underlying bit representation, unless that representation contains bits that do not correspond to a flag.",11,[[["u8"]],["option",["entrystatus"]]]],[11,"from_bits_truncate","","Convert from underlying bit representation, dropping any bits that do not correspond to flags.",11,[[["u8"]],["entrystatus"]]],[11,"is_empty","","Returns `true` if no flags are currently stored.",11,[[["self"]],["bool"]]],[11,"is_all","","Returns `true` if all flags are currently set.",11,[[["self"]],["bool"]]],[11,"intersects","","Returns `true` if there are flags common to both `self` and `other`.",11,[[["self"],["entrystatus"]],["bool"]]],[11,"contains","","Returns `true` all of the flags in `other` are contained within `self`.",11,[[["self"],["entrystatus"]],["bool"]]],[11,"insert","","Inserts the specified flags in-place.",11,[[["self"],["entrystatus"]]]],[11,"remove","","Removes the specified flags in-place.",11,[[["self"],["entrystatus"]]]],[11,"toggle","","Toggles the specified flags in-place.",11,[[["self"],["entrystatus"]]]],[11,"set","","Inserts or removes the specified flags depending on the passed value.",11,[[["self"],["entrystatus"],["bool"]]]],[18,"ENTRY","","",12,N],[18,"ENTRY_TYPE","","",12,N],[18,"SOURCES","","",12,N],[11,"empty","","Returns an empty set of flags.",12,[[],["getentrymask"]]],[11,"all","","Returns the set containing all flags.",12,[[],["getentrymask"]]],[11,"bits","","Returns the raw value of the flags currently stored.",12,[[["self"]],["u8"]]],[11,"from_bits","","Convert from underlying bit representation, unless that representation contains bits that do not correspond to a flag.",12,[[["u8"]],["option",["getentrymask"]]]],[11,"from_bits_truncate","","Convert from underlying bit representation, dropping any bits that do not correspond to flags.",12,[[["u8"]],["getentrymask"]]],[11,"is_empty","","Returns `true` if no flags are currently stored.",12,[[["self"]],["bool"]]],[11,"is_all","","Returns `true` if all flags are currently set.",12,[[["self"]],["bool"]]],[11,"intersects","","Returns `true` if there are flags common to both `self` and `other`.",12,[[["self"],["getentrymask"]],["bool"]]],[11,"contains","","Returns `true` all of the flags in `other` are contained within `self`.",12,[[["self"],["getentrymask"]],["bool"]]],[11,"insert","","Inserts the specified flags in-place.",12,[[["self"],["getentrymask"]]]],[11,"remove","","Removes the specified flags in-place.",12,[[["self"],["getentrymask"]]]],[11,"toggle","","Toggles the specified flags in-place.",12,[[["self"],["getentrymask"]]]],[11,"set","","Inserts or removes the specified flags depending on the passed value.",12,[[["self"],["getentrymask"],["bool"]]]],[0,"entry_definition","hdk","",N,N],[3,"ValidatingEntryType","hdk::entry_definition","This struct represents a complete entry type definition. It wraps EntryTypeDef defined in the DNA crate which only represents the static parts that show up in the JSON definition of an entry type. What is missing from there is the validation callbacks that can not be defined as JSON and are added here as Box objects (types PackageCreator, Validator, LinkValidator)",N,N],[12,"name","","Name of the entry type",13,N],[12,"entry_type_definition","","All the static aspects of the entry type as",13,N],[12,"package_creator","","Callback that returns a validation package definition that Holochain reads in order to create the right validation package to pass in to the validator callback on validation.",13,N],[12,"validator","","This is the validation callback that is used to determine if an entry is valid.",13,N],[12,"links","","",13,N],[3,"ValidatingLinkDefinition","","Similar to ValidatingEntryType, this provides the dynamic aspects of link definitions, the validation callbacks, and thus completes the structs in the DNA crate. The entry! macro expects an array of links that are represented by instances of this struct.",N,N],[12,"link_type","","Is this link defined as pointing from this entry type to some other type, or from the other type to this?",14,N],[12,"other_entry_type","","The other entry type the link connects this entry type to",14,N],[12,"tag","","Tag (i.e. name) of this type of links",14,N],[12,"package_creator","","Callback that returns a validation package definition that Holochain reads in order to create the right validation package to pass in to the validator callback on validation.",14,N],[12,"validator","","This is the validation callback that is used to determine if a link is valid.",14,N],[6,"PackageCreator","","",N,N],[6,"Validator","","",N,N],[6,"LinkValidator","","",N,N],[0,"error","hdk","",N,N],[4,"ZomeApiError","hdk::error","Error for DNA developers to use in their zome code. They do not have to send this error back to Ribosome unless its an InternalError.",N,N],[13,"Internal","","",15,N],[13,"FunctionNotImplemented","","",15,N],[13,"HashNotFound","","",15,N],[13,"ValidationFailed","","",15,N],[6,"ZomeApiResult","","",N,N],[0,"global_fns","hdk","",N,N],[3,"EntryValidationArgs","hdk::global_fns","",N,N],[12,"entry_type","","",0,N],[12,"entry","","",0,N],[12,"validation_data","","",0,N],[4,"LinkDirection","","",N,N],[13,"To","","",1,N],[13,"From","","",1,N],[3,"LinkValidationPackageArgs","","",N,N],[12,"entry_type","","",2,N],[12,"tag","","",2,N],[12,"direction","","",2,N],[3,"LinkValidationArgs","","",N,N],[12,"entry_type","","",3,N],[12,"link","","",3,N],[12,"direction","","",3,N],[12,"validation_data","","",3,N],[5,"init_global_memory","","Init global memory stack",N,[[["u32"]]]],[5,"store_and_return_output","","Serialize output as json in WASM memory",N,[[["j"]],["u32"]]],[0,"globals","hdk","Holds the internal/private globals used by the zome api library. Also contains the functions declarations of the external functions provided by the Ribosome.",N,N],[7,"G_MEM_STACK","hdk::globals","",N,N],[0,"init_globals","hdk","Holds the internal/private zome API function `init_globals` which initializes the Zome API Globals with the values it receives from the Ribosome. It is automatically called at startup of each Zome function call.",N,N],[0,"macros","","",N,N],[0,"meta","","",N,N],[3,"ZomeDefinition","hdk::meta","",N,N],[12,"entry_types","","",16,N],[5,"__hdk_get_validation_package_for_entry_type","","",N,[[["u32"]],["u32"]]],[5,"__hdk_validate_app_entry","","",N,[[["u32"]],["u32"]]],[5,"__hdk_get_validation_package_for_link","","",N,[[["u32"]],["u32"]]],[5,"__hdk_validate_link","","",N,[[["u32"]],["u32"]]],[5,"__hdk_get_json_definition","","",N,[[["u32"]],["u32"]]],[11,"define","","",16,[[["self"],["validatingentrytype"]]]],[14,"entry","hdk","The `entry` macro is a helper for creating `ValidatingEntryType` definitions for use within the define_zome macro. It has 7 component parts: 1. name: `name` is simply the descriptive name of the entry type, such as \"post\", or \"user\".      It is what must be given as the `entry_type_name` argument when calling commit_entry and the other data read/write functions. 2. description: `description` is something that is primarily for human readers of your code, just describe this entry type 3. sharing: `sharing` defines what distribution over the DHT, or not, occurs with entries of this type, possible values      are defined in the Sharing enum 4. native_type: `native_type` references a given Rust struct, which provides a clear schema for entries of this type. 5. validation_package: `validation_package` is a special identifier, which declares which data is required from peers      when attempting to validate entries of this type.      Possible values are found within ValidationPackageDefinition 6. validation: `validation` is a callback function which will be called any time that a      (DHT) node processes or stores this entry, triggered through actions such as commit_entry, update_entry, remove_entry.      It always expects two arguments, the first of which is the entry attempting to be validated,      the second is the validation `context`, which offers a variety of metadata useful for validation.      See ValidationData for more details. 7. links: `links` is a vector of link definitions represented by `ValidatingLinkDefinition`.     Links can be defined with the `link!` macro or, more concise, with either the `to!` or `from!` macro,     to define an association pointing from this entry type to another, or one that points back from     the other entry type to this one.     See link!, to! and from! for more details. # Examples The following is a standalone Rust file that exports a function which can be called to get a `ValidatingEntryType` of a \"post\". ```rust # #![feature(try_from)] # extern crate boolinator; # extern crate serde_json; # #[macro_use] # extern crate hdk; # #[macro_use] # extern crate holochain_core_types_derive; # #[macro_use] # extern crate serde_derive; # use boolinator::*; # use hdk::entry_definition::ValidatingEntryType; # use hdk::holochain_core_types::{ #   cas::content::Address, #   dna::zome::entry_types::Sharing, #   json::JsonString, #   error::HolochainError, # };",N,N],[14,"link","","The `link` macro is a helper for creating `ValidatingEntryType` definitions for use within the entry macro. It has 5 component parts: 1. direction: `direction` defines if this entry type (in which the link is defined) points     to another entry, or if it is referenced from another entry.     The latter is needed in cases where the definition of the entry to link from is not     accessible because it is a system entry type (AGENT_ADDRESS), or the other entry is     defined in library zome.     Must be of type LinkDirection, so either `hdk::LinkDirection::To`     or `hdk::LinkDirection::From`. 2. other_type: `other_type` is the entry type this link connects to. If direction is `to` this     would be the link target, if direction is `from` this defines the link's base type. 3. tag: `tag` is the name of this association and thus the handle by which it can be retrieved     if given to get_links() in conjunction with the base address. 4. validation_package: Similar to entries, links have to be validated.        `validation_package` is a special identifier, which declares which data is required from peers         when attempting to validate entries of this type.         Possible values are found within ValidationPackageDefinition 5. validation: `validation` is a callback function which will be called any time that a         (DHT) node processes or stores a link of this kind, triggered through the link actions link_entries and remove_link.         It always expects three arguments, the first being the base and the second the target of the link.         The third is the validation `context`, which offers a variety of metadata useful for validation.         See ValidationData for more details.",N,N],[14,"to","","The `to` macro is a helper for creating `ValidatingEntryType` definitions for use within the entry macro. It is a convenience wrapper around link! that has all the same properties except for the direction which gets set to `LinkDirection::To`.",N,N],[14,"from","","The `from` macro is a helper for creating `ValidatingEntryType` definitions for use within the entry macro. It is a convenience wrapper around link! that has all the same properties except for the direction which gets set to `LinkDirection::From`.",N,N],[14,"define_zome","","Every Zome must utilize the `define_zome` macro in the main library file in their Zome. The `define_zome` macro has 3 component parts: 1. entries: an array of ValidatingEntryType as returned by using the entry macro 2. genesis: `genesis` is a callback called by Holochain to every Zome implemented within a DNA.     It gets called when a new agent is initializing an instance of the DNA for the first time, and     should return `Ok` or an `Err`, depending on whether the agent can join the network or not. 3. functions: `functions` is divided up into `capabilities`, which specify who can access those functions.     `functions` must be a tree structure where the first children are `capabilities`     and the children of those `capabilities` are actual function definitions. # Examples",N,N],[11,"from","hdk::global_fns","",0,[[["t"]],["t"]]],[11,"into","","",0,[[["self"]],["u"]]],[11,"try_from","","",0,[[["u"]],["result"]]],[11,"borrow","","",0,[[["self"]],["t"]]],[11,"get_type_id","","",0,[[["self"]],["typeid"]]],[11,"try_into","","",0,[[["self"]],["result"]]],[11,"borrow_mut","","",0,[[["self"]],["t"]]],[11,"from","","",1,[[["t"]],["t"]]],[11,"into","","",1,[[["self"]],["u"]]],[11,"to_owned","","",1,[[["self"]],["t"]]],[11,"clone_into","","",1,N],[11,"try_from","","",1,[[["u"]],["result"]]],[11,"borrow","","",1,[[["self"]],["t"]]],[11,"get_type_id","","",1,[[["self"]],["typeid"]]],[11,"try_into","","",1,[[["self"]],["result"]]],[11,"borrow_mut","","",1,[[["self"]],["t"]]],[11,"clone_box","","",1,N],[11,"from","","",2,[[["t"]],["t"]]],[11,"into","","",2,[[["self"]],["u"]]],[11,"to_owned","","",2,[[["self"]],["t"]]],[11,"clone_into","","",2,N],[11,"try_from","","",2,[[["u"]],["result"]]],[11,"borrow","","",2,[[["self"]],["t"]]],[11,"get_type_id","","",2,[[["self"]],["typeid"]]],[11,"try_into","","",2,[[["self"]],["result"]]],[11,"borrow_mut","","",2,[[["self"]],["t"]]],[11,"clone_box","","",2,N],[11,"from","","",3,[[["t"]],["t"]]],[11,"into","","",3,[[["self"]],["u"]]],[11,"to_owned","","",3,[[["self"]],["t"]]],[11,"clone_into","","",3,N],[11,"try_from","","",3,[[["u"]],["result"]]],[11,"borrow","","",3,[[["self"]],["t"]]],[11,"get_type_id","","",3,[[["self"]],["typeid"]]],[11,"try_into","","",3,[[["self"]],["result"]]],[11,"borrow_mut","","",3,[[["self"]],["t"]]],[11,"clone_box","","",3,N],[11,"from","hdk","",4,[[["t"]],["t"]]],[11,"into","","",4,[[["self"]],["u"]]],[11,"to_owned","","",4,[[["self"]],["t"]]],[11,"clone_into","","",4,N],[11,"try_from","","",4,[[["u"]],["result"]]],[11,"borrow","","",4,[[["self"]],["t"]]],[11,"get_type_id","","",4,[[["self"]],["typeid"]]],[11,"try_into","","",4,[[["self"]],["result"]]],[11,"borrow_mut","","",4,[[["self"]],["t"]]],[11,"clone_box","","",4,N],[11,"from","","",5,[[["t"]],["t"]]],[11,"into","","",5,[[["self"]],["u"]]],[11,"to_owned","","",5,[[["self"]],["t"]]],[11,"clone_into","","",5,N],[11,"try_from","","",5,[[["u"]],["result"]]],[11,"borrow","","",5,[[["self"]],["t"]]],[11,"get_type_id","","",5,[[["self"]],["typeid"]]],[11,"try_into","","",5,[[["self"]],["result"]]],[11,"borrow_mut","","",5,[[["self"]],["t"]]],[11,"clone_box","","",5,N],[11,"from","","",6,[[["t"]],["t"]]],[11,"into","","",6,[[["self"]],["u"]]],[11,"to_owned","","",6,[[["self"]],["t"]]],[11,"clone_into","","",6,N],[11,"try_from","","",6,[[["u"]],["result"]]],[11,"borrow","","",6,[[["self"]],["t"]]],[11,"get_type_id","","",6,[[["self"]],["typeid"]]],[11,"try_into","","",6,[[["self"]],["result"]]],[11,"borrow_mut","","",6,[[["self"]],["t"]]],[11,"clone_box","","",6,N],[11,"from","","",7,[[["t"]],["t"]]],[11,"into","","",7,[[["self"]],["u"]]],[11,"to_owned","","",7,[[["self"]],["t"]]],[11,"clone_into","","",7,N],[11,"try_from","","",7,[[["u"]],["result"]]],[11,"borrow","","",7,[[["self"]],["t"]]],[11,"get_type_id","","",7,[[["self"]],["typeid"]]],[11,"try_into","","",7,[[["self"]],["result"]]],[11,"borrow_mut","","",7,[[["self"]],["t"]]],[11,"clone_box","","",7,N],[11,"from","","",8,[[["t"]],["t"]]],[11,"into","","",8,[[["self"]],["u"]]],[11,"to_owned","","",8,[[["self"]],["t"]]],[11,"clone_into","","",8,N],[11,"try_from","","",8,[[["u"]],["result"]]],[11,"borrow","","",8,[[["self"]],["t"]]],[11,"get_type_id","","",8,[[["self"]],["typeid"]]],[11,"try_into","","",8,[[["self"]],["result"]]],[11,"borrow_mut","","",8,[[["self"]],["t"]]],[11,"clone_box","","",8,N],[11,"from","","",9,[[["t"]],["t"]]],[11,"into","","",9,[[["self"]],["u"]]],[11,"to_owned","","",9,[[["self"]],["t"]]],[11,"clone_into","","",9,N],[11,"try_from","","",9,[[["u"]],["result"]]],[11,"borrow","","",9,[[["self"]],["t"]]],[11,"get_type_id","","",9,[[["self"]],["typeid"]]],[11,"try_into","","",9,[[["self"]],["result"]]],[11,"borrow_mut","","",9,[[["self"]],["t"]]],[11,"clone_box","","",9,N],[11,"from","hdk::api","",17,[[["t"]],["t"]]],[11,"into","","",17,[[["self"]],["u"]]],[11,"try_from","","",17,[[["u"]],["result"]]],[11,"borrow","","",17,[[["self"]],["t"]]],[11,"get_type_id","","",17,[[["self"]],["typeid"]]],[11,"try_into","","",17,[[["self"]],["result"]]],[11,"borrow_mut","","",17,[[["self"]],["t"]]],[11,"from","","",18,[[["t"]],["t"]]],[11,"into","","",18,[[["self"]],["u"]]],[11,"try_from","","",18,[[["u"]],["result"]]],[11,"borrow","","",18,[[["self"]],["t"]]],[11,"get_type_id","","",18,[[["self"]],["typeid"]]],[11,"try_into","","",18,[[["self"]],["result"]]],[11,"borrow_mut","","",18,[[["self"]],["t"]]],[11,"from","","",19,[[["t"]],["t"]]],[11,"into","","",19,[[["self"]],["u"]]],[11,"try_from","","",19,[[["u"]],["result"]]],[11,"borrow","","",19,[[["self"]],["t"]]],[11,"get_type_id","","",19,[[["self"]],["typeid"]]],[11,"try_into","","",19,[[["self"]],["result"]]],[11,"borrow_mut","","",19,[[["self"]],["t"]]],[11,"from","","",20,[[["t"]],["t"]]],[11,"into","","",20,[[["self"]],["u"]]],[11,"try_from","","",20,[[["u"]],["result"]]],[11,"borrow","","",20,[[["self"]],["t"]]],[11,"get_type_id","","",20,[[["self"]],["typeid"]]],[11,"try_into","","",20,[[["self"]],["result"]]],[11,"borrow_mut","","",20,[[["self"]],["t"]]],[11,"from","","",21,[[["t"]],["t"]]],[11,"into","","",21,[[["self"]],["u"]]],[11,"try_from","","",21,[[["u"]],["result"]]],[11,"borrow","","",21,[[["self"]],["t"]]],[11,"get_type_id","","",21,[[["self"]],["typeid"]]],[11,"try_into","","",21,[[["self"]],["result"]]],[11,"borrow_mut","","",21,[[["self"]],["t"]]],[11,"from","","",11,[[["t"]],["t"]]],[11,"into","","",11,[[["self"]],["u"]]],[11,"to_owned","","",11,[[["self"]],["t"]]],[11,"clone_into","","",11,N],[11,"try_from","","",11,[[["u"]],["result"]]],[11,"borrow","","",11,[[["self"]],["t"]]],[11,"get_type_id","","",11,[[["self"]],["typeid"]]],[11,"try_into","","",11,[[["self"]],["result"]]],[11,"borrow_mut","","",11,[[["self"]],["t"]]],[11,"equivalent","","",11,[[["self"],["k"]],["bool"]]],[11,"clone_box","","",11,N],[11,"from","","",12,[[["t"]],["t"]]],[11,"into","","",12,[[["self"]],["u"]]],[11,"to_owned","","",12,[[["self"]],["t"]]],[11,"clone_into","","",12,N],[11,"try_from","","",12,[[["u"]],["result"]]],[11,"borrow","","",12,[[["self"]],["t"]]],[11,"get_type_id","","",12,[[["self"]],["typeid"]]],[11,"try_into","","",12,[[["self"]],["result"]]],[11,"borrow_mut","","",12,[[["self"]],["t"]]],[11,"equivalent","","",12,[[["self"],["k"]],["bool"]]],[11,"clone_box","","",12,N],[11,"from","","",10,[[["t"]],["t"]]],[11,"into","","",10,[[["self"]],["u"]]],[11,"try_from","","",10,[[["u"]],["result"]]],[11,"borrow","","",10,[[["self"]],["t"]]],[11,"get_type_id","","",10,[[["self"]],["typeid"]]],[11,"try_into","","",10,[[["self"]],["result"]]],[11,"borrow_mut","","",10,[[["self"]],["t"]]],[11,"from","hdk::entry_definition","",13,[[["t"]],["t"]]],[11,"into","","",13,[[["self"]],["u"]]],[11,"try_from","","",13,[[["u"]],["result"]]],[11,"borrow","","",13,[[["self"]],["t"]]],[11,"get_type_id","","",13,[[["self"]],["typeid"]]],[11,"try_into","","",13,[[["self"]],["result"]]],[11,"borrow_mut","","",13,[[["self"]],["t"]]],[11,"from","","",14,[[["t"]],["t"]]],[11,"into","","",14,[[["self"]],["u"]]],[11,"try_from","","",14,[[["u"]],["result"]]],[11,"borrow","","",14,[[["self"]],["t"]]],[11,"get_type_id","","",14,[[["self"]],["typeid"]]],[11,"try_into","","",14,[[["self"]],["result"]]],[11,"borrow_mut","","",14,[[["self"]],["t"]]],[11,"from","hdk::error","",15,[[["t"]],["t"]]],[11,"into","","",15,[[["self"]],["u"]]],[11,"to_string","","",15,[[["self"]],["string"]]],[11,"try_from","","",15,[[["u"]],["result"]]],[11,"borrow","","",15,[[["self"]],["t"]]],[11,"get_type_id","","",15,[[["self"]],["typeid"]]],[11,"try_into","","",15,[[["self"]],["result"]]],[11,"borrow_mut","","",15,[[["self"]],["t"]]],[11,"from","hdk::meta","",16,[[["t"]],["t"]]],[11,"into","","",16,[[["self"]],["u"]]],[11,"try_from","","",16,[[["u"]],["result"]]],[11,"borrow","","",16,[[["self"]],["t"]]],[11,"get_type_id","","",16,[[["self"]],["typeid"]]],[11,"try_into","","",16,[[["self"]],["result"]]],[11,"borrow_mut","","",16,[[["self"]],["t"]]],[11,"clone","hdk","",4,[[["self"]],["validationpackage"]]],[11,"clone","","",5,[[["self"]],["validationpackagedefinition"]]],[11,"clone","","",6,[[["self"]],["validationdata"]]],[11,"clone","","",8,[[["self"]],["entryaction"]]],[11,"clone","","",7,[[["self"]],["entrylifecycle"]]],[11,"clone","","",9,[[["self"]],["linkaction"]]],[11,"serialize","","",9,[[["self"],["__s"]],["result"]]],[11,"serialize","","",6,[[["self"],["__s"]],["result"]]],[11,"serialize","","",8,[[["self"],["__s"]],["result"]]],[11,"serialize","","",4,[[["self"],["__s"]],["result"]]],[11,"serialize","","",5,[[["self"],["__s"]],["result"]]],[11,"serialize","","",7,[[["self"],["__s"]],["result"]]],[11,"deserialize","","",7,[[["__d"]],["result",["entrylifecycle"]]]],[11,"deserialize","","",4,[[["__d"]],["result",["validationpackage"]]]],[11,"deserialize","","",6,[[["__d"]],["result",["validationdata"]]]],[11,"deserialize","","",8,[[["__d"]],["result",["entryaction"]]]],[11,"deserialize","","",5,[[["__d"]],["result",["validationpackagedefinition"]]]],[11,"deserialize","","",9,[[["__d"]],["result",["linkaction"]]]],[11,"try_from","","",5,[[["jsonstring"]],["result",["validationpackagedefinition"]]]],[11,"try_from","","",4,[[["jsonstring"]],["result",["validationpackage"]]]],[11,"try_from","","",4,[[["jsonstring"]],["result",["validationpackage"]]]],[11,"try_from","","",5,[[["jsonstring"]],["result",["validationpackagedefinition"]]]],[11,"fmt","","",4,[[["self"],["formatter"]],["result",["error"]]]],[11,"fmt","","",7,[[["self"],["formatter"]],["result",["error"]]]],[11,"fmt","","",8,[[["self"],["formatter"]],["result",["error"]]]],[11,"fmt","","",5,[[["self"],["formatter"]],["result",["error"]]]],[11,"fmt","","",9,[[["self"],["formatter"]],["result",["error"]]]],[11,"fmt","","",6,[[["self"],["formatter"]],["result",["error"]]]],[11,"eq","","",4,[[["self"],["validationpackage"]],["bool"]]],[11,"ne","","",4,[[["self"],["validationpackage"]],["bool"]]],[11,"eq","","",5,[[["self"],["validationpackagedefinition"]],["bool"]]],[11,"ne","","",5,[[["self"],["validationpackagedefinition"]],["bool"]]],[11,"clone","hdk::global_fns","",1,[[["self"]],["linkdirection"]]],[11,"clone","","",2,[[["self"]],["linkvalidationpackageargs"]]],[11,"clone","","",3,[[["self"]],["linkvalidationargs"]]],[11,"serialize","","",0,[[["self"],["__s"]],["result"]]],[11,"serialize","","",3,[[["self"],["__s"]],["result"]]],[11,"serialize","","",2,[[["self"],["__s"]],["result"]]],[11,"serialize","","",1,[[["self"],["__s"]],["result"]]],[11,"deserialize","","",3,[[["__d"]],["result",["linkvalidationargs"]]]],[11,"deserialize","","",1,[[["__d"]],["result",["linkdirection"]]]],[11,"deserialize","","",0,[[["__d"]],["result",["entryvalidationargs"]]]],[11,"deserialize","","",2,[[["__d"]],["result",["linkvalidationpackageargs"]]]],[11,"try_from","","",0,[[["jsonstring"]],["result",["entryvalidationargs"]]]],[11,"try_from","","",0,[[["jsonstring"]],["result",["entryvalidationargs"]]]],[11,"try_from","","",2,[[["jsonstring"]],["result",["linkvalidationpackageargs"]]]],[11,"try_from","","",2,[[["jsonstring"]],["result",["linkvalidationpackageargs"]]]],[11,"try_from","","",3,[[["jsonstring"]],["result",["linkvalidationargs"]]]],[11,"try_from","","",1,[[["jsonstring"]],["result",["linkdirection"]]]],[11,"try_from","","",3,[[["jsonstring"]],["result",["linkvalidationargs"]]]],[11,"try_from","","",1,[[["jsonstring"]],["result",["linkdirection"]]]],[11,"fmt","","",1,[[["self"],["formatter"]],["result",["error"]]]],[11,"fmt","","",0,[[["self"],["formatter"]],["result",["error"]]]],[11,"fmt","","",3,[[["self"],["formatter"]],["result",["error"]]]],[11,"fmt","","",2,[[["self"],["formatter"]],["result",["error"]]]],[11,"eq","","",1,[[["self"],["linkdirection"]],["bool"]]],[11,"cmp","hdk::api","",11,[[["self"],["entrystatus"]],["ordering"]]],[11,"cmp","","",12,[[["self"],["getentrymask"]],["ordering"]]],[11,"eq","","",11,[[["self"],["entrystatus"]],["bool"]]],[11,"ne","","",11,[[["self"],["entrystatus"]],["bool"]]],[11,"eq","","",12,[[["self"],["getentrymask"]],["bool"]]],[11,"ne","","",12,[[["self"],["getentrymask"]],["bool"]]],[11,"eq","hdk::error","",15,[[["self"],["zomeapierror"]],["bool"]]],[11,"ne","","",15,[[["self"],["zomeapierror"]],["bool"]]],[11,"from","","",15,[[["holochainerror"]],["self"]]],[11,"from","","",15,N],[11,"from","","",15,[[["string"]],["zomeapierror"]]],[11,"from","","",15,[[["ribosomeerrorcode"]],["zomeapierror"]]],[11,"clone","hdk::api","",11,[[["self"]],["entrystatus"]]],[11,"clone","","",12,[[["self"]],["getentrymask"]]],[11,"extend","","",11,[[["self"],["t"]]]],[11,"extend","","",12,[[["self"],["t"]]]],[11,"partial_cmp","","",11,[[["self"],["entrystatus"]],["option",["ordering"]]]],[11,"lt","","",11,[[["self"],["entrystatus"]],["bool"]]],[11,"le","","",11,[[["self"],["entrystatus"]],["bool"]]],[11,"gt","","",11,[[["self"],["entrystatus"]],["bool"]]],[11,"ge","","",11,[[["self"],["entrystatus"]],["bool"]]],[11,"partial_cmp","","",12,[[["self"],["getentrymask"]],["option",["ordering"]]]],[11,"lt","","",12,[[["self"],["getentrymask"]],["bool"]]],[11,"le","","",12,[[["self"],["getentrymask"]],["bool"]]],[11,"gt","","",12,[[["self"],["getentrymask"]],["bool"]]],[11,"ge","","",12,[[["self"],["getentrymask"]],["bool"]]],[11,"default","","",12,[[],["getentrymask"]]],[11,"fmt","","",11,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",12,[[["self"],["formatter"]],["result"]]],[11,"fmt","hdk::error","",15,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",15,[[["self"],["formatter"]],["result"]]],[11,"sub","hdk::api","Returns the set difference of the two sets of flags.",11,[[["self"],["entrystatus"]],["entrystatus"]]],[11,"sub","","Returns the set difference of the two sets of flags.",12,[[["self"],["getentrymask"]],["getentrymask"]]],[11,"sub_assign","","Disables all flags enabled in the set.",11,[[["self"],["entrystatus"]]]],[11,"sub_assign","","Disables all flags enabled in the set.",12,[[["self"],["getentrymask"]]]],[11,"not","","Returns the complement of this set of flags.",11,[[["self"]],["entrystatus"]]],[11,"not","","Returns the complement of this set of flags.",12,[[["self"]],["getentrymask"]]],[11,"bitand","","Returns the intersection between the two sets of flags.",11,[[["self"],["entrystatus"]],["entrystatus"]]],[11,"bitand","","Returns the intersection between the two sets of flags.",12,[[["self"],["getentrymask"]],["getentrymask"]]],[11,"bitor","","Returns the union of the two sets of flags.",11,[[["self"],["entrystatus"]],["entrystatus"]]],[11,"bitor","","Returns the union of the two sets of flags.",12,[[["self"],["getentrymask"]],["getentrymask"]]],[11,"bitxor","","Returns the left flags, but with all the right flags toggled.",11,[[["self"],["entrystatus"]],["entrystatus"]]],[11,"bitxor","","Returns the left flags, but with all the right flags toggled.",12,[[["self"],["getentrymask"]],["getentrymask"]]],[11,"bitand_assign","","Disables all flags disabled in the set.",11,[[["self"],["entrystatus"]]]],[11,"bitand_assign","","Disables all flags disabled in the set.",12,[[["self"],["getentrymask"]]]],[11,"bitor_assign","","Adds the set of flags.",11,[[["self"],["entrystatus"]]]],[11,"bitor_assign","","Adds the set of flags.",12,[[["self"],["getentrymask"]]]],[11,"bitxor_assign","","Toggles the set of flags.",11,[[["self"],["entrystatus"]]]],[11,"bitxor_assign","","Toggles the set of flags.",12,[[["self"],["getentrymask"]]]],[11,"deref","","",17,[[["self"]],["str"]]],[11,"deref","","",18,[[["self"]],["hashstring"]]],[11,"deref","","",19,[[["self"]],["str"]]],[11,"deref","","",20,[[["self"]],["address"]]],[11,"deref","","",21,[[["self"]],["hashstring"]]],[11,"hash","","",11,N],[11,"hash","","",12,N],[11,"from_iter","","",11,[[["t"]],["entrystatus"]]],[11,"from_iter","","",12,[[["t"]],["getentrymask"]]],[11,"fmt","","",11,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",12,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",11,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",12,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",11,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",12,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",11,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",12,[[["self"],["formatter"]],["result"]]],[11,"description","hdk::error","",15,[[["self"]],["str"]]],[11,"serialize","","",15,[[["self"],["__s"]],["result"]]],[11,"deserialize","","",15,[[["__d"]],["result"]]],[11,"initialize","hdk::api","",17,[[["self"]]]],[11,"initialize","","",18,[[["self"]]]],[11,"initialize","","",19,[[["self"]]]],[11,"initialize","","",20,[[["self"]]]],[11,"initialize","","",21,[[["self"]]]],[11,"only_header","hdk","",4,[[["chainheader"]],["validationpackage"]]]],"paths":[[3,"EntryValidationArgs"],[4,"LinkDirection"],[3,"LinkValidationPackageArgs"],[3,"LinkValidationArgs"],[3,"ValidationPackage"],[4,"ValidationPackageDefinition"],[3,"ValidationData"],[4,"EntryLifecycle"],[4,"EntryAction"],[4,"LinkAction"],[4,"BundleOnClose"],[3,"EntryStatus"],[3,"GetEntryMask"],[3,"ValidatingEntryType"],[3,"ValidatingLinkDefinition"],[4,"ZomeApiError"],[3,"ZomeDefinition"],[3,"DNA_NAME"],[3,"DNA_HASH"],[3,"AGENT_ID_STR"],[3,"AGENT_ADDRESS"],[3,"AGENT_INITIAL_HASH"]]};
searchIndex["holochain_cas_implementations"]={"doc":"CAS Implementations","items":[[0,"cas","holochain_cas_implementations","",N,N],[0,"file","holochain_cas_implementations::cas","",N,N],[3,"FilesystemStorage","holochain_cas_implementations::cas::file","",N,N],[11,"new","","",0,[[["str"]],["result",["filesystemstorage","holochainerror"]]]],[0,"memory","holochain_cas_implementations::cas","",N,N],[3,"MemoryStorage","holochain_cas_implementations::cas::memory","",N,N],[11,"new","","",1,[[],["memorystorage"]]],[0,"eav","holochain_cas_implementations","",N,N],[0,"file","holochain_cas_implementations::eav","",N,N],[3,"EavFileStorage","holochain_cas_implementations::eav::file","",N,N],[5,"add_eav_to_hashset","","",N,[[["direntry"],["hashset"]]]],[11,"new","","",2,[[["string"]],["hcresult",["eavfilestorage"]]]],[0,"memory","holochain_cas_implementations::eav","",N,N],[3,"EavMemoryStorage","holochain_cas_implementations::eav::memory","",N,N],[11,"new","","",3,[[],["eavmemorystorage"]]],[0,"path","holochain_cas_implementations","",N,N],[5,"storage_path","holochain_cas_implementations::path","",N,[[["path"],["str"]],["hcresult",["string"]]]],[5,"create_path_if_not_exists","","",N,[[["str"]],["hcresult"]]],[11,"from","holochain_cas_implementations::cas::file","",0,[[["t"]],["t"]]],[11,"into","","",0,[[["self"]],["u"]]],[11,"to_owned","","",0,[[["self"]],["t"]]],[11,"clone_into","","",0,N],[11,"try_from","","",0,[[["u"]],["result"]]],[11,"borrow","","",0,[[["self"]],["t"]]],[11,"get_type_id","","",0,[[["self"]],["typeid"]]],[11,"try_into","","",0,[[["self"]],["result"]]],[11,"borrow_mut","","",0,[[["self"]],["t"]]],[11,"clone_box","","",0,N],[11,"from","holochain_cas_implementations::cas::memory","",1,[[["t"]],["t"]]],[11,"into","","",1,[[["self"]],["u"]]],[11,"to_owned","","",1,[[["self"]],["t"]]],[11,"clone_into","","",1,N],[11,"try_from","","",1,[[["u"]],["result"]]],[11,"borrow","","",1,[[["self"]],["t"]]],[11,"get_type_id","","",1,[[["self"]],["typeid"]]],[11,"try_into","","",1,[[["self"]],["result"]]],[11,"borrow_mut","","",1,[[["self"]],["t"]]],[11,"clone_box","","",1,N],[11,"from","holochain_cas_implementations::eav::file","",2,[[["t"]],["t"]]],[11,"into","","",2,[[["self"]],["u"]]],[11,"to_owned","","",2,[[["self"]],["t"]]],[11,"clone_into","","",2,N],[11,"try_from","","",2,[[["u"]],["result"]]],[11,"borrow","","",2,[[["self"]],["t"]]],[11,"get_type_id","","",2,[[["self"]],["typeid"]]],[11,"try_into","","",2,[[["self"]],["result"]]],[11,"borrow_mut","","",2,[[["self"]],["t"]]],[11,"clone_box","","",2,N],[11,"from","holochain_cas_implementations::eav::memory","",3,[[["t"]],["t"]]],[11,"into","","",3,[[["self"]],["u"]]],[11,"to_owned","","",3,[[["self"]],["t"]]],[11,"clone_into","","",3,N],[11,"try_from","","",3,[[["u"]],["result"]]],[11,"borrow","","",3,[[["self"]],["t"]]],[11,"get_type_id","","",3,[[["self"]],["typeid"]]],[11,"try_into","","",3,[[["self"]],["result"]]],[11,"borrow_mut","","",3,[[["self"]],["t"]]],[11,"clone_box","","",3,N],[11,"eq","holochain_cas_implementations::cas::file","",0,[[["self"],["filesystemstorage"]],["bool"]]],[11,"eq","holochain_cas_implementations::cas::memory","",1,[[["self"],["memorystorage"]],["bool"]]],[11,"eq","holochain_cas_implementations::eav::file","",2,[[["self"],["eavfilestorage"]],["bool"]]],[11,"eq","holochain_cas_implementations::eav::memory","",3,[[["self"],["eavmemorystorage"]],["bool"]]],[11,"clone","holochain_cas_implementations::cas::file","",0,[[["self"]],["filesystemstorage"]]],[11,"clone","holochain_cas_implementations::cas::memory","",1,[[["self"]],["memorystorage"]]],[11,"clone","holochain_cas_implementations::eav::file","",2,[[["self"]],["eavfilestorage"]]],[11,"clone","holochain_cas_implementations::eav::memory","",3,[[["self"]],["eavmemorystorage"]]],[11,"fmt","holochain_cas_implementations::cas::file","",0,[[["self"],["formatter"]],["result"]]],[11,"fmt","holochain_cas_implementations::cas::memory","",1,[[["self"],["formatter"]],["result"]]],[11,"fmt","holochain_cas_implementations::eav::file","",2,[[["self"],["formatter"]],["result"]]],[11,"fmt","holochain_cas_implementations::eav::memory","",3,[[["self"],["formatter"]],["result"]]],[11,"add","holochain_cas_implementations::cas::file","",0,[[["self"],["addressablecontent"]],["result",["holochainerror"]]]],[11,"contains","","",0,[[["self"],["address"]],["result",["bool","holochainerror"]]]],[11,"fetch","","",0,[[["self"],["address"]],["result",["option","holochainerror"]]]],[11,"get_id","","",0,[[["self"]],["uuid"]]],[11,"add","holochain_cas_implementations::cas::memory","",1,[[["self"],["addressablecontent"]],["result",["holochainerror"]]]],[11,"contains","","",1,[[["self"],["address"]],["result",["bool","holochainerror"]]]],[11,"fetch","","",1,[[["self"],["address"]],["result",["option","holochainerror"]]]],[11,"get_id","","",1,[[["self"]],["uuid"]]],[11,"add_eav","holochain_cas_implementations::eav::file","",2,[[["self"],["entityattributevalue"]],["result",["holochainerror"]]]],[11,"fetch_eav","","",2,[[["self"],["option",["entity"]],["option",["attribute"]],["option",["value"]]],["result",["hashset","holochainerror"]]]],[11,"add_eav","holochain_cas_implementations::eav::memory","",3,[[["self"],["entityattributevalue"]],["result",["holochainerror"]]]],[11,"fetch_eav","","",3,[[["self"],["option",["entity"]],["option",["attribute"]],["option",["value"]]],["result",["hashset","holochainerror"]]]]],"paths":[[3,"FilesystemStorage"],[3,"MemoryStorage"],[3,"EavFileStorage"],[3,"EavMemoryStorage"]]};
searchIndex["holochain_container"]={"doc":"","items":[],"paths":[]};
searchIndex["holochain_container_api"]={"doc":"let file_system = Arc::new(RwLock::new(FilesystemStorage::new(tempdir().unwrap().path().to_str().unwrap()).unwrap())); Arc::new(Mutex::new(SimplePersister::new(file_system.clone()))), file_system.clone(),","items":[[0,"config","holochain_container_api","",N,N],[3,"Configuration","holochain_container_api::config","Main container configuration struct This is the root of the configuration tree / aggregates all other configuration aspects.",N,N],[12,"agents","","List of Agents, this mainly means identities and their keys. Required.",0,N],[12,"dnas","","List of DNAs, for each a path to the DNA file. Required.",0,N],[12,"instances","","List of instances, includes references to an agent and a DNA. Required.",0,N],[12,"interfaces","","List of interfaces any UI can use to access zome functions. Optional.",0,N],[12,"bridges","","List of bridges between instances. Optional.",0,N],[3,"AgentConfiguration","","An agent has a name/ID and is defined by a private key that resides in a file",N,N],[12,"id","","",1,N],[12,"key_file","","",1,N],[3,"DNAConfiguration","","A DNA is represented by a DNA file. A hash has to be provided for sanity check.",N,N],[12,"id","","",2,N],[12,"file","","",2,N],[12,"hash","","",2,N],[3,"InstanceConfiguration","","An instance combines a DNA with an agent. Each instance has its own storage and logger configuration.",N,N],[12,"id","","",3,N],[12,"dna","","",3,N],[12,"agent","","",3,N],[12,"logger","","",3,N],[12,"storage","","",3,N],[3,"LoggerConfiguration","","There might be different kinds of loggers in the future. Currently there is no logger at all. TODO: make this an enum when it's actually in use",N,N],[12,"logger_type","","",4,N],[12,"file","","",4,N],[3,"InterfaceConfiguration","","Here, interfaces are user facing and make available zome functions to GUIs, browser based web UIs, local native UIs, other local applications and scripts. None is implemented yet, but we will have: * websockets * HTTP REST * Unix domain sockets very soon.",N,N],[12,"id","","",5,N],[12,"driver","","",5,N],[12,"admin","","",5,N],[12,"instances","","",5,N],[3,"InstanceReferenceConfiguration","","",N,N],[12,"id","","",6,N],[3,"Bridge","","A bridge enables an instance to call zome functions of another instance. It is basically an internal interface.",N,N],[12,"caller_id","","",7,N],[12,"callee_id","","",7,N],[4,"StorageConfiguration","","This configures the Content Addressable Storage (CAS) that the instance uses to store source chain and DHT shard in. There are two storage implementations in cas_implementations so far: * memory * file",N,N],[13,"Memory","","",8,N],[13,"File","","",8,N],[12,"path","holochain_container_api::config::StorageConfiguration","",8,N],[4,"InterfaceDriver","holochain_container_api::config","",N,N],[13,"Websocket","","",9,N],[12,"port","holochain_container_api::config::InterfaceDriver","",9,N],[13,"Http","holochain_container_api::config","",9,N],[12,"port","holochain_container_api::config::InterfaceDriver","",9,N],[13,"DomainSocket","holochain_container_api::config","",9,N],[12,"file","holochain_container_api::config::InterfaceDriver","",9,N],[13,"Custom","holochain_container_api::config","",9,N],[5,"load_configuration","","Use this function to load a `Configuration` from a string.",N,[[["str"]],["hcresult"]]],[11,"check_consistency","","This function basically checks if self is a semantically valid configuration. This mainly means checking for consistency between config structs that reference others.",0,[[["self"]],["result",["string"]]]],[11,"agent_by_id","","Returns the agent configuration with the given ID if present",0,[[["self"],["str"]],["option",["agentconfiguration"]]]],[11,"dna_by_id","","Returns the DNA configuration with the given ID if present",0,[[["self"],["str"]],["option",["dnaconfiguration"]]]],[11,"instance_by_id","","Returns the instance configuration with the given ID if present",0,[[["self"],["str"]],["option",["instanceconfiguration"]]]],[11,"interface_by_id","","Returns the interface configuration with the given ID if present",0,[[["self"],["str"]],["option",["interfaceconfiguration"]]]],[11,"instance_ids","","Returns all defined instance IDs",0,[[["self"]],["vec",["string"]]]],[0,"container","holochain_container_api","",N,N],[3,"Container","holochain_container_api::container","Main representation of the container. Holds a `HashMap` of Holochain instances referenced by ID. A primary point in this struct is `load_config(&mut self, config: &Configuration) -> Result<(), String>` which takes a `config::Configuration` struct and tries to instantiate all configured instances. While doing so it has to load DNA files referenced in the configuration. In order to not bind this code to the assumption that there is a filesystem and also enable easier testing, a DnaLoader has to be injected on creation. This is a closure that returns a Dna object for a given path string.",N,N],[12,"instances","","",10,N],[12,"dna_loader","","",10,N],[11,"with_config","","Creates a new instance with the default DnaLoader that actually loads files.",10,[[["configuration"]],["self"]]],[11,"start_all_interfaces","","",10,[[["self"]]]],[11,"start_interface_by_id","","",10,[[["self"],["string"]],["result",["string"]]]],[11,"start_all_instances","","Starts all instances",10,[[["self"]],["result",["holochaininstanceerror"]]]],[11,"stop_all_instances","","Stops all instances",10,[[["self"]],["result",["holochaininstanceerror"]]]],[11,"shutdown","","Stop and clear all instances",10,[[["self"]],["result",["holochaininstanceerror"]]]],[11,"load_config","","Tries to create all instances configured in the given Configuration object. Calls `Configuration::check_consistency()` first and clears `self.instances`.",10,[[["self"],["configuration"]],["result",["string"]]]],[0,"error","holochain_container_api","",N,N],[4,"HolochainInstanceError","holochain_container_api::error","",N,N],[13,"InternalFailure","","",11,N],[13,"InstanceNotActiveYet","","",11,N],[13,"InstanceAlreadyActive","","",11,N],[6,"HolochainResult","","",N,N],[0,"holochain","holochain_container_api","`holochain_core_api` is a library for instantiating and using a holochain instance that  runs a holochain DNA, DHT and source chain.",N,N],[3,"Holochain","holochain_container_api::holochain","contains a Holochain application instance",N,N],[11,"new","","create a new Holochain instance",12,[[["dna"],["arc",["context"]]],["holochainresult"]]],[11,"load","","",12,[[["string"],["arc",["context"]]],["result",["holochainerror"]]]],[11,"start","","activate the Holochain instance",12,[[["self"]],["result",["holochaininstanceerror"]]]],[11,"stop","","deactivate the Holochain instance",12,[[["self"]],["result",["holochaininstanceerror"]]]],[11,"call","","call a function in a zome",12,[[["self"],["str"],["str"],["str"],["str"]],["holochainresult",["jsonstring"]]]],[11,"active","","checks to see if an instance is active",12,[[["self"]],["bool"]]],[11,"state","","return",12,[[["self"]],["result",["state","holochaininstanceerror"]]]],[0,"interface","holochain_container_api","",N,N],[3,"ContainerApiDispatcher","holochain_container_api::interface","ContainerApiDispatcher exposes some subset of the Container API, including zome function calls as well as admin functionality. Each interface has their own dispatcher, and each may be configured differently.",N,N],[12,"io","","",13,N],[6,"InterfaceError","","",N,N],[6,"InstanceMap","","",N,N],[8,"DispatchRpc","","",N,N],[10,"handler","","",14,[[["self"]],["iohandler"]]],[8,"Interface","","",N,N],[10,"run","","",15,[[["self"],["d"]],["result",["string"]]]],[11,"new","","",13,[[["configuration"],["instancemap"]],["self"]]],[0,"interface_impls","holochain_container_api","",N,N],[0,"websocket","holochain_container_api::interface_impls","",N,N],[3,"WebsocketInterface","holochain_container_api::interface_impls::websocket","",N,N],[11,"new","","",16,[[["u16"]],["self"]]],[11,"from","holochain_container_api::config","",0,[[["t"]],["t"]]],[11,"into","","",0,[[["self"]],["u"]]],[11,"to_owned","","",0,[[["self"]],["t"]]],[11,"clone_into","","",0,N],[11,"try_from","","",0,[[["u"]],["result"]]],[11,"borrow","","",0,[[["self"]],["t"]]],[11,"get_type_id","","",0,[[["self"]],["typeid"]]],[11,"try_into","","",0,[[["self"]],["result"]]],[11,"borrow_mut","","",0,[[["self"]],["t"]]],[11,"clone_box","","",0,N],[11,"from","","",1,[[["t"]],["t"]]],[11,"into","","",1,[[["self"]],["u"]]],[11,"to_owned","","",1,[[["self"]],["t"]]],[11,"clone_into","","",1,N],[11,"try_from","","",1,[[["u"]],["result"]]],[11,"borrow","","",1,[[["self"]],["t"]]],[11,"get_type_id","","",1,[[["self"]],["typeid"]]],[11,"try_into","","",1,[[["self"]],["result"]]],[11,"borrow_mut","","",1,[[["self"]],["t"]]],[11,"clone_box","","",1,N],[11,"from","","",2,[[["t"]],["t"]]],[11,"into","","",2,[[["self"]],["u"]]],[11,"to_owned","","",2,[[["self"]],["t"]]],[11,"clone_into","","",2,N],[11,"try_from","","",2,[[["u"]],["result"]]],[11,"borrow","","",2,[[["self"]],["t"]]],[11,"get_type_id","","",2,[[["self"]],["typeid"]]],[11,"try_into","","",2,[[["self"]],["result"]]],[11,"borrow_mut","","",2,[[["self"]],["t"]]],[11,"clone_box","","",2,N],[11,"from","","",3,[[["t"]],["t"]]],[11,"into","","",3,[[["self"]],["u"]]],[11,"to_owned","","",3,[[["self"]],["t"]]],[11,"clone_into","","",3,N],[11,"try_from","","",3,[[["u"]],["result"]]],[11,"borrow","","",3,[[["self"]],["t"]]],[11,"get_type_id","","",3,[[["self"]],["typeid"]]],[11,"try_into","","",3,[[["self"]],["result"]]],[11,"borrow_mut","","",3,[[["self"]],["t"]]],[11,"clone_box","","",3,N],[11,"from","","",4,[[["t"]],["t"]]],[11,"into","","",4,[[["self"]],["u"]]],[11,"to_owned","","",4,[[["self"]],["t"]]],[11,"clone_into","","",4,N],[11,"try_from","","",4,[[["u"]],["result"]]],[11,"borrow","","",4,[[["self"]],["t"]]],[11,"get_type_id","","",4,[[["self"]],["typeid"]]],[11,"try_into","","",4,[[["self"]],["result"]]],[11,"borrow_mut","","",4,[[["self"]],["t"]]],[11,"clone_box","","",4,N],[11,"from","","",5,[[["t"]],["t"]]],[11,"into","","",5,[[["self"]],["u"]]],[11,"to_owned","","",5,[[["self"]],["t"]]],[11,"clone_into","","",5,N],[11,"try_from","","",5,[[["u"]],["result"]]],[11,"borrow","","",5,[[["self"]],["t"]]],[11,"get_type_id","","",5,[[["self"]],["typeid"]]],[11,"try_into","","",5,[[["self"]],["result"]]],[11,"borrow_mut","","",5,[[["self"]],["t"]]],[11,"clone_box","","",5,N],[11,"from","","",6,[[["t"]],["t"]]],[11,"into","","",6,[[["self"]],["u"]]],[11,"to_owned","","",6,[[["self"]],["t"]]],[11,"clone_into","","",6,N],[11,"try_from","","",6,[[["u"]],["result"]]],[11,"borrow","","",6,[[["self"]],["t"]]],[11,"get_type_id","","",6,[[["self"]],["typeid"]]],[11,"try_into","","",6,[[["self"]],["result"]]],[11,"borrow_mut","","",6,[[["self"]],["t"]]],[11,"clone_box","","",6,N],[11,"from","","",7,[[["t"]],["t"]]],[11,"into","","",7,[[["self"]],["u"]]],[11,"to_owned","","",7,[[["self"]],["t"]]],[11,"clone_into","","",7,N],[11,"try_from","","",7,[[["u"]],["result"]]],[11,"borrow","","",7,[[["self"]],["t"]]],[11,"get_type_id","","",7,[[["self"]],["typeid"]]],[11,"try_into","","",7,[[["self"]],["result"]]],[11,"borrow_mut","","",7,[[["self"]],["t"]]],[11,"clone_box","","",7,N],[11,"from","","",8,[[["t"]],["t"]]],[11,"into","","",8,[[["self"]],["u"]]],[11,"to_owned","","",8,[[["self"]],["t"]]],[11,"clone_into","","",8,N],[11,"try_from","","",8,[[["u"]],["result"]]],[11,"borrow","","",8,[[["self"]],["t"]]],[11,"get_type_id","","",8,[[["self"]],["typeid"]]],[11,"try_into","","",8,[[["self"]],["result"]]],[11,"borrow_mut","","",8,[[["self"]],["t"]]],[11,"clone_box","","",8,N],[11,"from","","",9,[[["t"]],["t"]]],[11,"into","","",9,[[["self"]],["u"]]],[11,"to_owned","","",9,[[["self"]],["t"]]],[11,"clone_into","","",9,N],[11,"try_from","","",9,[[["u"]],["result"]]],[11,"borrow","","",9,[[["self"]],["t"]]],[11,"get_type_id","","",9,[[["self"]],["typeid"]]],[11,"try_into","","",9,[[["self"]],["result"]]],[11,"borrow_mut","","",9,[[["self"]],["t"]]],[11,"clone_box","","",9,N],[11,"from","holochain_container_api::container","",10,[[["t"]],["t"]]],[11,"into","","",10,[[["self"]],["u"]]],[11,"try_from","","",10,[[["u"]],["result"]]],[11,"borrow","","",10,[[["self"]],["t"]]],[11,"get_type_id","","",10,[[["self"]],["typeid"]]],[11,"try_into","","",10,[[["self"]],["result"]]],[11,"borrow_mut","","",10,[[["self"]],["t"]]],[11,"from","holochain_container_api::error","",11,[[["t"]],["t"]]],[11,"into","","",11,[[["self"]],["u"]]],[11,"to_owned","","",11,[[["self"]],["t"]]],[11,"clone_into","","",11,N],[11,"to_string","","",11,[[["self"]],["string"]]],[11,"try_from","","",11,[[["u"]],["result"]]],[11,"borrow","","",11,[[["self"]],["t"]]],[11,"get_type_id","","",11,[[["self"]],["typeid"]]],[11,"try_into","","",11,[[["self"]],["result"]]],[11,"borrow_mut","","",11,[[["self"]],["t"]]],[11,"clone_box","","",11,N],[11,"as_fail","","",11,[[["self"]],["fail"]]],[11,"from","holochain_container_api::holochain","",12,[[["t"]],["t"]]],[11,"into","","",12,[[["self"]],["u"]]],[11,"try_from","","",12,[[["u"]],["result"]]],[11,"borrow","","",12,[[["self"]],["t"]]],[11,"get_type_id","","",12,[[["self"]],["typeid"]]],[11,"try_into","","",12,[[["self"]],["result"]]],[11,"borrow_mut","","",12,[[["self"]],["t"]]],[11,"from","holochain_container_api::interface","",13,[[["t"]],["t"]]],[11,"into","","",13,[[["self"]],["u"]]],[11,"try_from","","",13,[[["u"]],["result"]]],[11,"borrow","","",13,[[["self"]],["t"]]],[11,"get_type_id","","",13,[[["self"]],["typeid"]]],[11,"try_into","","",13,[[["self"]],["result"]]],[11,"borrow_mut","","",13,[[["self"]],["t"]]],[11,"from","holochain_container_api::interface_impls::websocket","",16,[[["t"]],["t"]]],[11,"into","","",16,[[["self"]],["u"]]],[11,"try_from","","",16,[[["u"]],["result"]]],[11,"borrow","","",16,[[["self"]],["t"]]],[11,"get_type_id","","",16,[[["self"]],["typeid"]]],[11,"try_into","","",16,[[["self"]],["result"]]],[11,"borrow_mut","","",16,[[["self"]],["t"]]],[11,"handler","holochain_container_api::interface","",13,[[["self"]],["iohandler"]]],[11,"run","holochain_container_api::interface_impls::websocket","",16,[[["self"],["containerapidispatcher"]],["result",["string"]]]],[11,"eq","holochain_container_api::config","",7,[[["self"],["bridge"]],["bool"]]],[11,"ne","","",7,[[["self"],["bridge"]],["bool"]]],[11,"eq","holochain_container_api::error","",11,[[["self"],["holochaininstanceerror"]],["bool"]]],[11,"ne","","",11,[[["self"],["holochaininstanceerror"]],["bool"]]],[11,"from","","",11,[[["holochainerror"]],["self"]]],[11,"clone","holochain_container_api::config","",0,[[["self"]],["configuration"]]],[11,"clone","","",1,[[["self"]],["agentconfiguration"]]],[11,"clone","","",2,[[["self"]],["dnaconfiguration"]]],[11,"clone","","",3,[[["self"]],["instanceconfiguration"]]],[11,"clone","","",4,[[["self"]],["loggerconfiguration"]]],[11,"clone","","",8,[[["self"]],["storageconfiguration"]]],[11,"clone","","",5,[[["self"]],["interfaceconfiguration"]]],[11,"clone","","",9,[[["self"]],["interfacedriver"]]],[11,"clone","","",6,[[["self"]],["instancereferenceconfiguration"]]],[11,"clone","","",7,[[["self"]],["bridge"]]],[11,"clone","holochain_container_api::error","",11,[[["self"]],["holochaininstanceerror"]]],[11,"default","holochain_container_api::config","",0,[[],["configuration"]]],[11,"default","","",4,[[],["loggerconfiguration"]]],[11,"fmt","","",7,[[["self"],["formatter"]],["result"]]],[11,"fmt","holochain_container_api::error","",11,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",11,[[["self"],["formatter"]],["result"]]],[11,"try_from","holochain_container_api::container","",10,[[["configuration"]],["result"]]],[11,"description","holochain_container_api::error","",11,[[["self"]],["str"]]],[11,"cause","","",11,[[["self"]],["option",["error"]]]],[11,"serialize","holochain_container_api::config","",0,[[["self"],["__s"]],["result"]]],[11,"serialize","","",1,[[["self"],["__s"]],["result"]]],[11,"serialize","","",2,[[["self"],["__s"]],["result"]]],[11,"serialize","","",3,[[["self"],["__s"]],["result"]]],[11,"serialize","","",4,[[["self"],["__s"]],["result"]]],[11,"serialize","","",8,[[["self"],["__s"]],["result"]]],[11,"serialize","","",5,[[["self"],["__s"]],["result"]]],[11,"serialize","","",9,[[["self"],["__s"]],["result"]]],[11,"serialize","","",6,[[["self"],["__s"]],["result"]]],[11,"serialize","","",7,[[["self"],["__s"]],["result"]]],[11,"deserialize","","",0,[[["__d"]],["result"]]],[11,"deserialize","","",1,[[["__d"]],["result"]]],[11,"deserialize","","",2,[[["__d"]],["result"]]],[11,"deserialize","","",3,[[["__d"]],["result"]]],[11,"deserialize","","",4,[[["__d"]],["result"]]],[11,"deserialize","","",8,[[["__d"]],["result"]]],[11,"deserialize","","",5,[[["__d"]],["result"]]],[11,"deserialize","","",9,[[["__d"]],["result"]]],[11,"deserialize","","",6,[[["__d"]],["result"]]],[11,"deserialize","","",7,[[["__d"]],["result"]]]],"paths":[[3,"Configuration"],[3,"AgentConfiguration"],[3,"DNAConfiguration"],[3,"InstanceConfiguration"],[3,"LoggerConfiguration"],[3,"InterfaceConfiguration"],[3,"InstanceReferenceConfiguration"],[3,"Bridge"],[4,"StorageConfiguration"],[4,"InterfaceDriver"],[3,"Container"],[4,"HolochainInstanceError"],[3,"Holochain"],[3,"ContainerApiDispatcher"],[8,"DispatchRpc"],[8,"Interface"],[3,"WebsocketInterface"]]};
searchIndex["holochain_core"]={"doc":"The library implementing the holochain pattern of validation rules + local source chain + DHT","items":[[0,"action","holochain_core","",N,N],[3,"ActionWrapper","holochain_core::action","Wrapper for actions that provides a unique ID The unique ID is needed for state tracking to ensure that we can differentiate between two Action dispatches containing the same value when doing \"time travel debug\". The standard approach is to drop the ActionWrapper into the key of a state history HashMap and use the convenience unwrap_to! macro to extract the action data in a reducer. All reducer functions must accept an ActionWrapper so all dispatchers take an ActionWrapper.",N,N],[4,"Action","","All Actions for the Holochain Instance Store, according to Redux pattern.",N,N],[13,"Commit","","entry to Commit MUST already have passed all callback checks",0,N],[13,"GetEntry","","GetEntry by address",0,N],[13,"GetEntryTimeout","","",0,N],[13,"AddLink","","link to add",0,N],[13,"ExecuteZomeFunction","","get links from entry address and attribute-name execute a function in a zome WASM",0,N],[13,"ReturnZomeFunctionResult","","return the result of a zome WASM function call",0,N],[13,"InitApplication","","initialize an application from a Dna not the same as genesis may call genesis internally",0,N],[13,"ReturnInitializationResult","","return the result of an InitApplication action the result is Some arbitrary string",0,N],[13,"Call","","Execute a zome function call called by another zome function",0,N],[13,"ReturnValidationResult","","A validation result that should be stored Key is an unique id of the calling context and the hash of the entry that was validated",0,N],[13,"ReturnValidationPackage","","",0,N],[13,"InitNetwork","","",0,N],[13,"Publish","","",0,N],[13,"Hold","","",0,N],[13,"RespondGet","","",0,N],[13,"HandleGetResult","","",0,N],[6,"AgentReduceFn","","function signature for action handler functions",N,N],[6,"NetworkReduceFn","","",N,N],[6,"NucleusReduceFn","","",N,N],[6,"ReduceFn","","",N,N],[11,"new","","constructor from &Action internal snowflake ID is automatically set",1,[[["action"]],["self"]]],[11,"action","","read only access to action",1,[[["self"]],["action"]]],[11,"id","","read only access to id",1,[[["self"]],["processuniqueid"]]],[0,"agent","holochain_core","",N,N],[5,"chain_header","holochain_core::agent","",N,[[["entry"],["arc"]],["option",["chainheader"]]]],[0,"actions","","Agent is the module that handles the users identity and source chain for every Phenotype.",N,N],[0,"commit","holochain_core::agent::actions","",N,N],[3,"CommitFuture","holochain_core::agent::actions::commit","CommitFuture resolves to ActionResponse Tracks the state for a response to its ActionWrapper",N,N],[5,"commit_entry","","Commit Action Creator This is the high-level commit function that wraps the whole commit process and is what should be called from zome api functions and other contexts that don't care about implementation details.",N,N],[0,"chain_store","holochain_core::agent","",N,N],[3,"ChainStore","holochain_core::agent::chain_store","",N,N],[3,"ChainStoreIterator","","",N,N],[3,"ChainStoreTypeIterator","","",N,N],[11,"new","","",2,[[["arc",["rwlock"]]],["self"]]],[11,"content_storage","","",2,[[["self"]],["arc",["rwlock"]]]],[11,"iter","","",2,[[["self"],["option"]],["chainstoreiterator"]]],[11,"iter_type","","",2,[[["self"],["option"],["entrytype"]],["chainstoretypeiterator"]]],[11,"query","","",2,[[["self"],["option"],["entrytype"],["u32"],["u32"]],["vec",["address"]]]],[11,"new","","",3,[[["arc",["rwlock"]],["option",["chainheader"]]],["chainstoreiterator"]]],[11,"new","","",4,[[["arc",["rwlock"]],["option",["chainheader"]]],["chainstoretypeiterator"]]],[0,"state","holochain_core::agent","",N,N],[3,"AgentState","holochain_core::agent::state","The state-slice for the Agent. Holds the agent's source chain and keys.",N,N],[3,"AgentStateSnapshot","","",N,N],[4,"ActionResponse","","the agent's response to an action stored alongside the action in AgentState::actions to provide a state history that observers poll and retrieve",N,N],[13,"Commit","","",5,N],[13,"GetEntry","","",5,N],[13,"GetLinks","","",5,N],[13,"LinkEntries","","",5,N],[5,"create_new_chain_header","","",N,[[["entry"],["agentstate"]],["chainheader"]]],[5,"reduce","","Reduce Agent's state according to provided Action",N,[[["arc",["context"]],["arc",["agentstate"]],["actionwrapper"]],["arc",["agentstate"]]]],[7,"AGENT_SNAPSHOT_ADDRESS","","",N,N],[11,"new","","builds a new, empty AgentState",6,[[["chainstore"]],["agentstate"]]],[11,"new_with_top_chain_header","","",6,[[["chainstore"],["chainheader"]],["agentstate"]]],[11,"actions","","getter for a copy of self.actions uniquely maps action executions to the result of the action",6,[[["self"]],["hashmap",["actionwrapper","actionresponse"]]]],[11,"chain","","",6,[[["self"]],["chainstore"]]],[11,"top_chain_header","","",6,[[["self"]],["option",["chainheader"]]]],[11,"get_agent","","",6,N],[11,"new","","",7,[[["chainheader"]],["agentstatesnapshot"]]],[11,"from_json_str","","",7,[[["str"]],["result"]]],[11,"top_chain_header","","",7,[[["self"]],["chainheader"]]],[0,"context","holochain_core","",N,N],[3,"Context","holochain_core::context","Context holds the components that parts of a Holochain instance need in order to operate. This includes components that are injected from the outside like logger and persister but also the store of the instance that gets injected before passing on the context to inner components/reducers.",N,N],[12,"agent_id","","",8,N],[12,"logger","","",8,N],[12,"persister","","",8,N],[12,"action_channel","","",8,N],[12,"observer_channel","","",8,N],[12,"file_storage","","",8,N],[12,"eav_storage","","",8,N],[12,"network_config","","",8,N],[5,"mock_network_config","","create a test network",N,[[],["jsonstring"]]],[11,"default_channel_buffer_size","","",8,[[],["usize"]]],[11,"new","","",8,[[["agentid"],["arc",["mutex"]],["arc",["mutex"]],["arc",["rwlock"]],["arc",["rwlock"]],["jsonstring"]],["result",["context","holochainerror"]]]],[11,"new_with_channels","","",8,[[["agentid"],["arc",["mutex"]],["arc",["mutex"]],["syncsender",["actionwrapper"]],["syncsender",["observer"]],["arc",["rwlock"]],["arc",["rwlock"]],["jsonstring"]],["result",["context","holochainerror"]]]],[11,"log","","",8,[[["self"],["str"]],["result",["holochainerror"]]]],[11,"set_state","","",8,[[["self"],["arc",["rwlock"]]]]],[11,"state","","",8,[[["self"]],["option",["rwlockreadguard"]]]],[11,"get_dna","","",8,[[["self"]],["option",["dna"]]]],[11,"get_wasm","","",8,[[["self"],["str"]],["option",["dnawasm"]]]],[0,"dht","holochain_core","DHT is the module that handles the agent's local shard of data and p2p communications",N,N],[0,"actions","holochain_core::dht","",N,N],[0,"add_link","holochain_core::dht::actions","",N,N],[3,"AddLinkFuture","holochain_core::dht::actions::add_link","",N,N],[5,"add_link","","AddLink Action Creator This action creator dispatches an AddLink action which is consumed by the DHT reducer. Note that this function does not include any validation checks for the link. The DHT reducer does make sure that it only adds links to a base that it has in its local storage and will return an error that the AddLinkFuture resolves to if that is not the case.",N,[[["link"],["arc"]],["addlinkfuture"]]],[0,"hold","holochain_core::dht::actions","",N,N],[3,"HoldEntryFuture","holochain_core::dht::actions::hold","",N,N],[5,"hold_entry","","",N,N],[0,"dht_reducers","holochain_core::dht","all DHT reducers",N,N],[5,"reduce","holochain_core::dht::dht_reducers","DHT state-slice Reduce entry point. Note: Can't block when dispatching action here because we are inside the reduce's mutex",N,[[["arc",["context"]],["arc",["dhtstore"]],["actionwrapper"]],["arc",["dhtstore"]]]],[0,"dht_store","holochain_core::dht","",N,N],[3,"DhtStore","holochain_core::dht::dht_store","The state-slice for the DHT. Holds the agent's local shard and interacts with the network module",N,N],[11,"new","","",9,[[["arc",["rwlock"]],["arc",["rwlock"]]],["self"]]],[11,"add_link","","",9,[[["self"],["link"]],["result",["holochainerror"]]]],[11,"remove_link","","",9,[[["self"]]]],[11,"get_links","","",9,[[["self"],["address"],["string"]],["result",["hashset","holochainerror"]]]],[11,"add_link_actions","","",9,[[["self"]],["hashmap"]]],[0,"instance","holochain_core","",N,N],[3,"Instance","holochain_core::instance","Object representing a Holochain instance, i.e. a running holochain (DNA + DHT + source-chain) Holds the Event loop and processes it with the redux pattern.",N,N],[3,"Observer","","State Observer that executes a closure everytime the State changes.",N,N],[12,"sensor","","",10,N],[5,"dispatch_action_and_wait","","Send Action to Instance's Event Queue and block until is has been processed.",N,[[["syncsender"],["syncsender"],["actionwrapper"]]]],[5,"dispatch_action_with_observer","","Send Action to the Event Queue and create an Observer for it with the specified closure",N,[[["syncsender"],["syncsender"],["actionwrapper"],["f"]]]],[5,"dispatch_action","","Send Action to the Event Queue",N,[[["syncsender"],["actionwrapper"]]]],[7,"DISPATCH_WITHOUT_CHANNELS","","",N,N],[17,"RECV_DEFAULT_TIMEOUT_MS","","",N,N],[11,"default_channel_buffer_size","","",11,[[],["usize"]]],[11,"action_channel","","get a clone of the action channel",11,[[["self"]],["syncsender",["actionwrapper"]]]],[11,"observer_channel","","get a clone of the observer channel",11,[[["self"]],["syncsender",["observer"]]]],[11,"dispatch","","Stack an Action in the Event Queue",11,[[["self"],["actionwrapper"]]]],[11,"dispatch_and_wait","","Stack an Action in the Event Queue and block until is has been processed.",11,[[["self"],["actionwrapper"]]]],[11,"dispatch_with_observer","","Stack an action in the Event Queue and create an Observer on it with the specified closure",11,[[["self"],["actionwrapper"],["f"]]]],[11,"initialize_context","","",11,[[["self"],["arc",["context"]]],["arc",["context"]]]],[11,"start_action_loop","","Start the Event Loop on a seperate thread",11,[[["self"],["arc",["context"]]]]],[11,"new","","Creates a new Instance with disconnected channels.",11,[[["arc",["context"]]],["self"]]],[11,"from_state","","",11,[[["state"]],["self"]]],[11,"state","","",11,[[["self"]],["rwlockreadguard",["state"]]]],[0,"logger","holochain_core","This logger is the logger that's attached to each Holochain application which is separate from standard logging via the log crate warn! info! debug! logging that gets emitted globaly from the container.",N,N],[3,"SimpleLogger","holochain_core::logger","",N,N],[8,"Logger","","trait that defines the logging functionality that holochain_core requires",N,N],[10,"log","","",12,[[["self"],["string"]]]],[11,"dump","","",12,[[["self"]],["string"]]],[0,"network","holochain_core","",N,N],[0,"actions","holochain_core::network","",N,N],[4,"ActionResponse","holochain_core::network::actions","",N,N],[13,"Publish","","",13,N],[13,"RespondGet","","",13,N],[0,"get_entry","","",N,N],[3,"GetEntryFuture","holochain_core::network::actions::get_entry","GetEntryFuture resolves to a HcResult. Tracks the state of the network module",N,N],[5,"get_entry","","GetEntry Action Creator This is the network version of get_entry that makes the network module start a look-up process.",N,N],[0,"initialize_network","holochain_core::network::actions","",N,N],[3,"InitNetworkFuture","holochain_core::network::actions::initialize_network","",N,N],[5,"initialize_network","","InitNetwork Action Creator",N,N],[0,"publish","holochain_core::network::actions","",N,N],[3,"PublishFuture","holochain_core::network::actions::publish","PublishFuture resolves to ActionResponse Tracks the state for a response to its ActionWrapper",N,N],[5,"publish_entry","","Publish Action Creator This is the high-level publish function that wraps the whole publish process and is what should be called from zome api functions and other contexts that don't care about implementation details.",N,N],[0,"handler","holochain_core::network","",N,N],[5,"create_handler","holochain_core::network::handler","",N,[[["arc"]],["nethandler"]]],[0,"reducers","holochain_core::network","",N,N],[5,"reduce","holochain_core::network::reducers","",N,[[["arc",["context"]],["arc",["networkstate"]],["actionwrapper"]],["arc",["networkstate"]]]],[0,"get_entry","","",N,N],[5,"reduce_get_entry","holochain_core::network::reducers::get_entry","",N,[[["arc",["context"]],["networkstate"],["actionwrapper"]]]],[5,"reduce_get_entry_timeout","","",N,[[["arc",["context"]],["networkstate"],["actionwrapper"]]]],[0,"handle_get_result","holochain_core::network::reducers","",N,N],[5,"reduce_handle_get_result","holochain_core::network::reducers::handle_get_result","",N,[[["arc",["context"]],["networkstate"],["actionwrapper"]]]],[0,"init","holochain_core::network::reducers","",N,N],[5,"reduce_init","holochain_core::network::reducers::init","",N,[[["arc",["context"]],["networkstate"],["actionwrapper"]]]],[0,"publish","holochain_core::network::reducers","",N,N],[5,"reduce_publish","holochain_core::network::reducers::publish","",N,[[["arc",["context"]],["networkstate"],["actionwrapper"]]]],[0,"respond_get","holochain_core::network::reducers","",N,N],[5,"reduce_respond_get","holochain_core::network::reducers::respond_get","",N,[[["arc",["context"]],["networkstate"],["actionwrapper"]]]],[0,"state","holochain_core::network","",N,N],[3,"NetworkState","holochain_core::network::state","",N,N],[12,"actions","","every action and the result of that action",14,N],[12,"network","","",14,N],[12,"dna_hash","","",14,N],[12,"agent_id","","",14,N],[12,"get_entry_results","","",14,N],[11,"new","","",14,[[],["self"]]],[11,"actions","","",14,[[["self"]],["hashmap",["actionwrapper","actionresponse"]]]],[0,"nucleus","holochain_core","",N,N],[3,"ZomeFnCall","holochain_core::nucleus","Struct holding data for requesting the execution of a Zome function (ExecutionZomeFunction Action)",N,N],[12,"zome_name","","",15,N],[12,"cap_name","","",15,N],[12,"fn_name","","",15,N],[12,"parameters","","",15,N],[3,"EntrySubmission","","WIP - Struct for holding data when requesting an Entry Validation (ValidateEntry Action)",N,N],[12,"zome_name","","",16,N],[12,"type_name","","",16,N],[12,"entry_content","","",16,N],[3,"ExecuteZomeFnResponse","","",N,N],[5,"call_zome_and_wait_for_result","","Dispatch ExecuteZoneFunction to and block until call has finished.",N,[[["zomefncall"],["syncsender"],["syncsender"]],["result",["jsonstring","holochainerror"]]]],[5,"call_and_wait_for_result","","Dispatch ExecuteZoneFunction to Instance and block until call has finished. for test only??",N,[[["zomefncall"],["instance"]],["result",["jsonstring","holochainerror"]]]],[5,"reduce","","Reduce state of Nucleus according to action. Note: Can't block when dispatching action here because we are inside the reduce's mutex",N,[[["arc",["context"]],["arc",["nucleusstate"]],["actionwrapper"]],["arc",["nucleusstate"]]]],[0,"actions","","Nucleus is the module that handles DNA, including the Ribosome.",N,N],[0,"build_validation_package","holochain_core::nucleus::actions","",N,N],[3,"ValidationPackageFuture","holochain_core::nucleus::actions::build_validation_package","ValidationPackageFuture resolves to the ValidationPackage or a HolochainError.",N,N],[5,"build_validation_package","","",N,[[["entry"],["arc"]],["validationpackagefuture"]]],[0,"get_entry","holochain_core::nucleus::actions","",N,N],[5,"get_entry","holochain_core::nucleus::actions::get_entry","GetEntry Action Creator",N,[[["arc"],["address"]],["futureobj",["result"]]]],[0,"initialize","holochain_core::nucleus::actions","",N,N],[3,"InitializationFuture","holochain_core::nucleus::actions::initialize","InitializationFuture resolves to an Ok(NucleusStatus) or an Err(String). Tracks the nucleus status.",N,N],[5,"initialize_application","","Initialize Application, Action Creator This is the high-level initialization function that wraps the whole process of initializing an instance. It creates both InitApplication and ReturnInitializationResult actions asynchronously.",N,N],[0,"validate","holochain_core::nucleus::actions","",N,N],[3,"ValidationFuture","holochain_core::nucleus::actions::validate","ValidationFuture resolves to an Ok(ActionWrapper) or an Err(error_message:String). Tracks the state for ValidationResults.",N,N],[5,"validate_entry","","ValidateEntry Action Creator This is the high-level validate function that wraps the whole validation process and is what should be called from zome api functions and other contexts that don't care about implementation details.",N,[[["entry"],["validationdata"],["arc"]],["futureobj",["result"]]]],[0,"ribosome","holochain_core::nucleus","The virtual machine that runs DNA written in WASM",N,N],[3,"Runtime","holochain_core::nucleus::ribosome","Object holding data to pass around to invoked Zome API functions",N,N],[12,"memory_manager","","Memory state tracker between ribosome and wasm.",17,N],[12,"context","","Context of Holochain. Required for operating.",17,N],[12,"dna_name","","Name of the DNA that is being hosted.",17,N],[12,"zome_call","","The zome function call that initiated the Ribosome.",17,N],[5,"run_dna","","Executes an exposed zome function in a wasm binary. Multithreaded function panics if wasm binary isn't valid.",N,[[["str"],["arc",["context"]],["vec",["u8"]],["zomefncall"],["option",["vec"]]],["zomefnresult"]]],[0,"api","","Module for ZomeApiFunctions ZomeApiFunctions are the functions provided by the ribosome that are callable by Zomes.",N,N],[4,"ZomeApiFunction","holochain_core::nucleus::ribosome::api","Enumeration of all the Zome Functions known and usable in Zomes. Enumeration can convert to str.",N,N],[13,"MissingNo","","Error index for unimplemented functions",18,N],[13,"Abort","","Abort is a way to receive useful debug info from assemblyscript memory allocators message: mem address in the wasm memory for an error message filename: mem address in the wasm memory for a filename line: line number column: column number",18,N],[13,"Debug","","Zome API send debug information to the log debug(s: String)",18,N],[13,"CommitAppEntry","","Commit an app entry to source chain commit_entry(entry_type: String, entry_value: String) -> Address",18,N],[13,"GetAppEntry","","Get an app entry from source chain by key (header hash) get_entry(address: Address) -> Entry",18,N],[13,"InitGlobals","","Init Zome API Globals hc_init_globals() -> InitGlobalsOutput",18,N],[13,"Call","","Call a zome function in a different capability or zome hc_call(zome_name: String, cap_name: String, fn_name: String, args: String);",18,N],[13,"LinkEntries","","",18,N],[13,"GetLinks","","",18,N],[13,"Query","","",18,N],[13,"EntryAddress","","Pass an entry to retrieve its address the address algorithm is specific to the entry, typically sha256 but can differ entry_address(entry: Entry) -> Address",18,N],[0,"call","","",N,N],[5,"invoke_call","holochain_core::nucleus::ribosome::api::call","HcApiFuncIndex::CALL function code args: [0] encoded MemoryAllocation as u32 expected complex argument: {zome_name: String, cap_name: String, fn_name: String, args: String} args from API call are converted into a ZomeFnCall Launch an Action::Call with newly formed ZomeFnCall Waits for a ZomeFnResult Returns an HcApiReturnCode as I32",N,[[["runtime"],["runtimeargs"]],["zomeapiresult"]]],[0,"commit","holochain_core::nucleus::ribosome::api","",N,N],[5,"invoke_commit_app_entry","holochain_core::nucleus::ribosome::api::commit","ZomeApiFunction::CommitAppEntry function code args: [0] encoded MemoryAllocation as u32 Expected complex argument: CommitArgs Returns an HcApiReturnCode as I32",N,[[["runtime"],["runtimeargs"]],["zomeapiresult"]]],[0,"debug","holochain_core::nucleus::ribosome::api","",N,N],[5,"invoke_debug","holochain_core::nucleus::ribosome::api::debug","ZomeApiFunction::Debug function code args: [0] encoded MemoryAllocation as u32 Expecting a string as complex input argument Returns an HcApiReturnCode as I32",N,[[["runtime"],["runtimeargs"]],["zomeapiresult"]]],[0,"entry_address","holochain_core::nucleus::ribosome::api","",N,N],[5,"get_entry_type","holochain_core::nucleus::ribosome::api::entry_address","",N,[[["dna"],["str"]],["result",["entrytype","option"]]]],[5,"invoke_entry_address","","ZomeApiFunction::entry_address function code args: [0] encoded MemoryAllocation as u32 Expected complex argument: entry_type_name and entry_value as JsonString Returns an HcApiReturnCode as I32",N,[[["runtime"],["runtimeargs"]],["zomeapiresult"]]],[0,"get_entry","holochain_core::nucleus::ribosome::api","",N,N],[5,"invoke_get_entry","holochain_core::nucleus::ribosome::api::get_entry","ZomeApiFunction::GetAppEntry function code args: [0] encoded MemoryAllocation as u32 Expected complex argument: GetEntryArgs Returns an HcApiReturnCode as I32",N,[[["runtime"],["runtimeargs"]],["zomeapiresult"]]],[0,"get_links","holochain_core::nucleus::ribosome::api","",N,N],[5,"invoke_get_links","holochain_core::nucleus::ribosome::api::get_links","ZomeApiFunction::GetLinks function code args: [0] encoded MemoryAllocation as u32 Expected complex argument: GetLinksArgs Returns an HcApiReturnCode as I32",N,[[["runtime"],["runtimeargs"]],["zomeapiresult"]]],[0,"init_globals","holochain_core::nucleus::ribosome::api","",N,N],[5,"invoke_init_globals","holochain_core::nucleus::ribosome::api::init_globals","ZomeApiFunction::InitGlobals secret function code args: [0] encoded MemoryAllocation as u32 Not expecting any complex input Returns an HcApiReturnCode as I32",N,[[["runtime"],["runtimeargs"]],["zomeapiresult"]]],[0,"link_entries","holochain_core::nucleus::ribosome::api","",N,N],[5,"invoke_link_entries","holochain_core::nucleus::ribosome::api::link_entries","ZomeApiFunction::LinkEntries function code args: [0] encoded MemoryAllocation as u32 Expected complex argument: LinkEntriesArgs",N,[[["runtime"],["runtimeargs"]],["zomeapiresult"]]],[0,"query","holochain_core::nucleus::ribosome::api","",N,N],[5,"invoke_query","holochain_core::nucleus::ribosome::api::query","ZomeApiFunction::query function code args: [0] encoded MemoryAllocation as u32 Expected complex argument: ? Returns an HcApiReturnCode as I32",N,[[["runtime"],["runtimeargs"]],["zomeapiresult"]]],[6,"ZomeApiResult","holochain_core::nucleus::ribosome::api","",N,N],[11,"as_fn","","",18,N],[0,"callback","holochain_core::nucleus::ribosome","Module for ZomeCallbacks ZomeCallbacks are functions in a Zome that are callable by the ribosome.",N,N],[4,"Callback","holochain_core::nucleus::ribosome::callback","Enumeration of all Zome Callbacks known and used by Holochain Enumeration can convert to str",N,N],[13,"MissingNo","","Error index for unimplemented functions",19,N],[13,"Genesis","","MissingNo Capability LifeCycle Capability genesis() -> bool",19,N],[13,"Receive","","Communication Capability receive(from: String, message: String) -> String",19,N],[4,"CallbackParams","","",N,N],[13,"Genesis","","",20,N],[13,"ValidateCommit","","",20,N],[13,"Receive","","",20,N],[4,"CallbackResult","","",N,N],[13,"Pass","","",21,N],[13,"Fail","","",21,N],[13,"NotImplemented","","",21,N],[13,"ValidationPackageDefinition","","",21,N],[5,"call","","",N,[[["arc",["context"]],["str"],["callback"],["callbackparams"]],["callbackresult"]]],[0,"genesis","","",N,N],[5,"genesis","holochain_core::nucleus::ribosome::callback::genesis","",N,[[["arc",["context"]],["str"],["callbackparams"]],["callbackresult"]]],[0,"links_utils","holochain_core::nucleus::ribosome::callback","",N,N],[3,"LinkDefinitionPath","holochain_core::nucleus::ribosome::callback::links_utils","This is a \"path\" in the DNA tree. That uniquely identifies a link definition.",N,N],[12,"zome_name","","",22,N],[12,"entry_type_name","","",22,N],[12,"direction","","",22,N],[12,"tag","","",22,N],[5,"get_link_entries","","Retrieves the base and target entries of the link and returns both.",N,[[["link"],["arc"]],["result",["holochainerror"]]]],[5,"find_link_definition_in_dna","","This function tries to find the link definition for a link given by base type, tag and target type.",N,[[["entrytype"],["string"],["entrytype"],["arc"]],["result",["linkdefinitionpath","holochainerror"]]]],[0,"receive","holochain_core::nucleus::ribosome::callback","",N,N],[5,"receive","holochain_core::nucleus::ribosome::callback::receive","",N,[[["arc",["context"]],["str"],["callbackparams"]],["callbackresult"]]],[0,"validate_entry","holochain_core::nucleus::ribosome::callback","",N,N],[5,"validate_entry","holochain_core::nucleus::ribosome::callback::validate_entry","This function determines and runs the appropriate validation callback for the given entry with the given validation data (which includes the validation package). It returns a CallbackResult which would be * CallbackResult::Pass when the entry is valid * CallbackResult::Fail(message) when the entry is invalid, giving the fail string from the         validation callback * CallbackResult::NotImplemented if a validation callback is not implemented for the given         entry's type.",N,[[["entry"],["validationdata"],["arc",["context"]]],["result",["callbackresult","holochainerror"]]]],[0,"validation_package","holochain_core::nucleus::ribosome::callback","",N,N],[5,"get_validation_package_definition","holochain_core::nucleus::ribosome::callback::validation_package","",N,[[["entry"],["arc",["context"]]],["result",["callbackresult","holochainerror"]]]],[11,"as_fn","holochain_core::nucleus::ribosome::callback","",19,N],[0,"memory","holochain_core::nucleus::ribosome","",N,N],[3,"SinglePageManager","holochain_core::nucleus::ribosome::memory","Struct for managing a WASM Memory Instance as a single page memory stack",N,N],[11,"new","","",23,[[["moduleref"]],["self"]]],[11,"allocate","","Allocate on stack without writing in it",23,[[["self"],["u16"]],["result",["singlepageallocation","ribosomeerrorcode"]]]],[11,"write","","Write data on top of stack",23,N],[11,"read","","Read data somewhere in stack",23,[[["self"],["singlepageallocation"]],["vec",["u8"]]]],[11,"load_json_string_from_args","holochain_core::nucleus::ribosome","Load a JsonString stored in wasm memory. Input RuntimeArgs should only have one input which is the encoded allocation holding the complex data as an utf8 string. Returns the utf8 string.",17,[[["self"],["runtimeargs"]],["jsonstring"]]],[11,"store_as_json_string","","Store anything that implements Into in wasm memory. Note that From for JsonString automatically implements Into Input should be a a json string. Returns a Result suitable to return directly from a zome API function, i.e. an encoded allocation",17,[[["self"],["j"]],["zomeapiresult"]]],[11,"store_result","","",17,[[["self"],["result",["holochainerror"]]],["zomeapiresult"]]],[8,"Defn","","",N,N],[10,"as_str","","return the canonical name of this function definition",24,[[["self"]],["str"]]],[10,"str_to_index","","convert the canonical name of this function to an index",24,[[["str"]],["usize"]]],[10,"from_index","","convert an index to the function definition",24,[[["usize"]],["self"]]],[10,"capability","","",24,[[["self"]],["reservedcapabilitynames"]]],[0,"state","holochain_core::nucleus","",N,N],[3,"NucleusState","holochain_core::nucleus::state","The state-slice for the Nucleus. Holds the dynamic parts of the DNA, i.e. zome calls and validation requests.",N,N],[12,"dna","","",25,N],[12,"status","","",25,N],[12,"zome_calls","","",25,N],[12,"validation_results","","",25,N],[12,"validation_packages","","",25,N],[4,"NucleusStatus","","",N,N],[13,"New","","",26,N],[13,"Initializing","","",26,N],[13,"Initialized","","",26,N],[13,"InitializationFailed","","",26,N],[6,"ValidationResult","","",N,N],[11,"new","","",25,[[],["self"]]],[11,"zome_call_result","","",25,[[["self"],["zomefncall"]],["option",["result"]]]],[11,"has_initialized","","",25,[[["self"]],["bool"]]],[11,"has_initialization_failed","","",25,[[["self"]],["bool"]]],[11,"dna","","",25,[[["self"]],["option",["dna"]]]],[11,"status","","",25,[[["self"]],["nucleusstatus"]]],[6,"ZomeFnResult","holochain_core::nucleus","",N,N],[11,"new","","",15,[[["str"],["str"],["str"],["j"]],["self"]]],[11,"same_fn_as","","",15,[[["self"],["zomefncall"]],["bool"]]],[11,"new","","",16,[[["s"],["s"],["s"]],["self"]]],[11,"call","","read only access to call",27,[[["self"]],["zomefncall"]]],[11,"result","","read only access to result",27,[[["self"]],["result",["jsonstring","holochainerror"]]]],[0,"persister","holochain_core","",N,N],[3,"SimplePersister","holochain_core::persister","",N,N],[8,"Persister","","trait that defines the persistence functionality that holochain_core requires",N,N],[10,"save","","",28,[[["self"],["state"]],["result",["holochainerror"]]]],[10,"load","","",28,[[["self"],["arc",["context"]]],["result",["option","holochainerror"]]]],[11,"new","","",29,[[["arc",["rwlock"]]],["self"]]],[0,"state","holochain_core","",N,N],[3,"State","holochain_core::state","The Store of the Holochain instance Object, according to Redux pattern. It's composed of all sub-module's state slices. To plug in a new module, its state slice needs to be added here.",N,N],[12,"history","","",30,N],[5,"test_store","","",N,[[["arc",["context"]]],["state"]]],[11,"new","","",30,[[["arc",["context"]]],["self"]]],[11,"new_with_agent","","",30,[[["arc",["context"]],["arc",["agentstate"]]],["self"]]],[11,"reduce","","",30,[[["self"],["arc",["context"]],["actionwrapper"]],["self"]]],[11,"nucleus","","",30,[[["self"]],["arc",["nucleusstate"]]]],[11,"agent","","",30,[[["self"]],["arc",["agentstate"]]]],[11,"dht","","",30,[[["self"]],["arc",["dhtstore"]]]],[11,"network","","",30,[[["self"]],["arc",["networkstate"]]]],[11,"try_from_agent_snapshot","","",30,[[["arc",["context"]],["agentstatesnapshot"]],["hcresult",["state"]]]],[0,"workflows","holochain_core","",N,N],[0,"author_entry","holochain_core::workflows","",N,N],[5,"author_entry","holochain_core::workflows::author_entry","",N,N],[0,"get_entry","holochain_core::workflows","",N,N],[5,"get_entry","holochain_core::workflows::get_entry","",N,N],[11,"from","holochain_core::action","",1,[[["t"]],["t"]]],[11,"into","","",1,[[["self"]],["u"]]],[11,"to_owned","","",1,[[["self"]],["t"]]],[11,"clone_into","","",1,N],[11,"try_from","","",1,[[["u"]],["result"]]],[11,"borrow","","",1,[[["self"]],["t"]]],[11,"get_type_id","","",1,[[["self"]],["typeid"]]],[11,"try_into","","",1,[[["self"]],["result"]]],[11,"borrow_mut","","",1,[[["self"]],["t"]]],[11,"equivalent","","",1,[[["self"],["k"]],["bool"]]],[11,"clone_box","","",1,N],[11,"from","","",0,[[["t"]],["t"]]],[11,"into","","",0,[[["self"]],["u"]]],[11,"to_owned","","",0,[[["self"]],["t"]]],[11,"clone_into","","",0,N],[11,"try_from","","",0,[[["u"]],["result"]]],[11,"borrow","","",0,[[["self"]],["t"]]],[11,"get_type_id","","",0,[[["self"]],["typeid"]]],[11,"try_into","","",0,[[["self"]],["result"]]],[11,"borrow_mut","","",0,[[["self"]],["t"]]],[11,"clone_box","","",0,N],[11,"from","holochain_core::agent::actions::commit","",31,[[["t"]],["t"]]],[11,"into","","",31,[[["self"]],["u"]]],[11,"try_from","","",31,[[["u"]],["result"]]],[11,"borrow","","",31,[[["self"]],["t"]]],[11,"get_type_id","","",31,[[["self"]],["typeid"]]],[11,"try_into","","",31,[[["self"]],["result"]]],[11,"borrow_mut","","",31,[[["self"]],["t"]]],[11,"try_poll","","",31,[[["pin"],["localwaker"]],["poll"]]],[11,"from","holochain_core::agent::chain_store","",2,[[["t"]],["t"]]],[11,"into","","",2,[[["self"]],["u"]]],[11,"to_owned","","",2,[[["self"]],["t"]]],[11,"clone_into","","",2,N],[11,"try_from","","",2,[[["u"]],["result"]]],[11,"borrow","","",2,[[["self"]],["t"]]],[11,"get_type_id","","",2,[[["self"]],["typeid"]]],[11,"try_into","","",2,[[["self"]],["result"]]],[11,"borrow_mut","","",2,[[["self"]],["t"]]],[11,"clone_box","","",2,N],[11,"from","","",3,[[["t"]],["t"]]],[11,"into_iter","","",3,[[["self"]],["i"]]],[11,"into","","",3,[[["self"]],["u"]]],[11,"try_from","","",3,[[["u"]],["result"]]],[11,"borrow","","",3,[[["self"]],["t"]]],[11,"get_type_id","","",3,[[["self"]],["typeid"]]],[11,"try_into","","",3,[[["self"]],["result"]]],[11,"borrow_mut","","",3,[[["self"]],["t"]]],[11,"from","","",4,[[["t"]],["t"]]],[11,"into_iter","","",4,[[["self"]],["i"]]],[11,"into","","",4,[[["self"]],["u"]]],[11,"try_from","","",4,[[["u"]],["result"]]],[11,"borrow","","",4,[[["self"]],["t"]]],[11,"get_type_id","","",4,[[["self"]],["typeid"]]],[11,"try_into","","",4,[[["self"]],["result"]]],[11,"borrow_mut","","",4,[[["self"]],["t"]]],[11,"from","holochain_core::agent::state","",6,[[["t"]],["t"]]],[11,"into","","",6,[[["self"]],["u"]]],[11,"to_owned","","",6,[[["self"]],["t"]]],[11,"clone_into","","",6,N],[11,"try_from","","",6,[[["u"]],["result"]]],[11,"borrow","","",6,[[["self"]],["t"]]],[11,"get_type_id","","",6,[[["self"]],["typeid"]]],[11,"try_into","","",6,[[["self"]],["result"]]],[11,"borrow_mut","","",6,[[["self"]],["t"]]],[11,"clone_box","","",6,N],[11,"from","","",7,[[["t"]],["t"]]],[11,"into","","",7,[[["self"]],["u"]]],[11,"to_owned","","",7,[[["self"]],["t"]]],[11,"clone_into","","",7,N],[11,"try_from","","",7,[[["u"]],["result"]]],[11,"borrow","","",7,[[["self"]],["t"]]],[11,"get_type_id","","",7,[[["self"]],["typeid"]]],[11,"try_into","","",7,[[["self"]],["result"]]],[11,"borrow_mut","","",7,[[["self"]],["t"]]],[11,"clone_box","","",7,N],[11,"from","","",5,[[["t"]],["t"]]],[11,"into","","",5,[[["self"]],["u"]]],[11,"to_owned","","",5,[[["self"]],["t"]]],[11,"clone_into","","",5,N],[11,"try_from","","",5,[[["u"]],["result"]]],[11,"borrow","","",5,[[["self"]],["t"]]],[11,"get_type_id","","",5,[[["self"]],["typeid"]]],[11,"try_into","","",5,[[["self"]],["result"]]],[11,"borrow_mut","","",5,[[["self"]],["t"]]],[11,"clone_box","","",5,N],[11,"from","holochain_core::context","",8,[[["t"]],["t"]]],[11,"into","","",8,[[["self"]],["u"]]],[11,"to_owned","","",8,[[["self"]],["t"]]],[11,"clone_into","","",8,N],[11,"try_from","","",8,[[["u"]],["result"]]],[11,"borrow","","",8,[[["self"]],["t"]]],[11,"get_type_id","","",8,[[["self"]],["typeid"]]],[11,"try_into","","",8,[[["self"]],["result"]]],[11,"borrow_mut","","",8,[[["self"]],["t"]]],[11,"clone_box","","",8,N],[11,"from","holochain_core::dht::actions::add_link","",32,[[["t"]],["t"]]],[11,"into","","",32,[[["self"]],["u"]]],[11,"try_from","","",32,[[["u"]],["result"]]],[11,"borrow","","",32,[[["self"]],["t"]]],[11,"get_type_id","","",32,[[["self"]],["typeid"]]],[11,"try_into","","",32,[[["self"]],["result"]]],[11,"borrow_mut","","",32,[[["self"]],["t"]]],[11,"try_poll","","",32,[[["pin"],["localwaker"]],["poll"]]],[11,"from","holochain_core::dht::actions::hold","",33,[[["t"]],["t"]]],[11,"into","","",33,[[["self"]],["u"]]],[11,"try_from","","",33,[[["u"]],["result"]]],[11,"borrow","","",33,[[["self"]],["t"]]],[11,"get_type_id","","",33,[[["self"]],["typeid"]]],[11,"try_into","","",33,[[["self"]],["result"]]],[11,"borrow_mut","","",33,[[["self"]],["t"]]],[11,"try_poll","","",33,[[["pin"],["localwaker"]],["poll"]]],[11,"from","holochain_core::dht::dht_store","",9,[[["t"]],["t"]]],[11,"into","","",9,[[["self"]],["u"]]],[11,"to_owned","","",9,[[["self"]],["t"]]],[11,"clone_into","","",9,N],[11,"try_from","","",9,[[["u"]],["result"]]],[11,"borrow","","",9,[[["self"]],["t"]]],[11,"get_type_id","","",9,[[["self"]],["typeid"]]],[11,"try_into","","",9,[[["self"]],["result"]]],[11,"borrow_mut","","",9,[[["self"]],["t"]]],[11,"clone_box","","",9,N],[11,"from","holochain_core::instance","",11,[[["t"]],["t"]]],[11,"into","","",11,[[["self"]],["u"]]],[11,"to_owned","","",11,[[["self"]],["t"]]],[11,"clone_into","","",11,N],[11,"try_from","","",11,[[["u"]],["result"]]],[11,"borrow","","",11,[[["self"]],["t"]]],[11,"get_type_id","","",11,[[["self"]],["typeid"]]],[11,"try_into","","",11,[[["self"]],["result"]]],[11,"borrow_mut","","",11,[[["self"]],["t"]]],[11,"clone_box","","",11,N],[11,"from","","",10,[[["t"]],["t"]]],[11,"into","","",10,[[["self"]],["u"]]],[11,"try_from","","",10,[[["u"]],["result"]]],[11,"borrow","","",10,[[["self"]],["t"]]],[11,"get_type_id","","",10,[[["self"]],["typeid"]]],[11,"try_into","","",10,[[["self"]],["result"]]],[11,"borrow_mut","","",10,[[["self"]],["t"]]],[11,"from","holochain_core::logger","",34,[[["t"]],["t"]]],[11,"into","","",34,[[["self"]],["u"]]],[11,"to_owned","","",34,[[["self"]],["t"]]],[11,"clone_into","","",34,N],[11,"try_from","","",34,[[["u"]],["result"]]],[11,"borrow","","",34,[[["self"]],["t"]]],[11,"get_type_id","","",34,[[["self"]],["typeid"]]],[11,"try_into","","",34,[[["self"]],["result"]]],[11,"borrow_mut","","",34,[[["self"]],["t"]]],[11,"clone_box","","",34,N],[11,"from","holochain_core::network::actions","",13,[[["t"]],["t"]]],[11,"into","","",13,[[["self"]],["u"]]],[11,"to_owned","","",13,[[["self"]],["t"]]],[11,"clone_into","","",13,N],[11,"try_from","","",13,[[["u"]],["result"]]],[11,"borrow","","",13,[[["self"]],["t"]]],[11,"get_type_id","","",13,[[["self"]],["typeid"]]],[11,"try_into","","",13,[[["self"]],["result"]]],[11,"borrow_mut","","",13,[[["self"]],["t"]]],[11,"clone_box","","",13,N],[11,"from","holochain_core::network::actions::get_entry","",35,[[["t"]],["t"]]],[11,"into","","",35,[[["self"]],["u"]]],[11,"try_from","","",35,[[["u"]],["result"]]],[11,"borrow","","",35,[[["self"]],["t"]]],[11,"get_type_id","","",35,[[["self"]],["typeid"]]],[11,"try_into","","",35,[[["self"]],["result"]]],[11,"borrow_mut","","",35,[[["self"]],["t"]]],[11,"try_poll","","",35,[[["pin"],["localwaker"]],["poll"]]],[11,"from","holochain_core::network::actions::initialize_network","",36,[[["t"]],["t"]]],[11,"into","","",36,[[["self"]],["u"]]],[11,"try_from","","",36,[[["u"]],["result"]]],[11,"borrow","","",36,[[["self"]],["t"]]],[11,"get_type_id","","",36,[[["self"]],["typeid"]]],[11,"try_into","","",36,[[["self"]],["result"]]],[11,"borrow_mut","","",36,[[["self"]],["t"]]],[11,"try_poll","","",36,[[["pin"],["localwaker"]],["poll"]]],[11,"from","holochain_core::network::actions::publish","",37,[[["t"]],["t"]]],[11,"into","","",37,[[["self"]],["u"]]],[11,"try_from","","",37,[[["u"]],["result"]]],[11,"borrow","","",37,[[["self"]],["t"]]],[11,"get_type_id","","",37,[[["self"]],["typeid"]]],[11,"try_into","","",37,[[["self"]],["result"]]],[11,"borrow_mut","","",37,[[["self"]],["t"]]],[11,"try_poll","","",37,[[["pin"],["localwaker"]],["poll"]]],[11,"from","holochain_core::network::state","",14,[[["t"]],["t"]]],[11,"into","","",14,[[["self"]],["u"]]],[11,"to_owned","","",14,[[["self"]],["t"]]],[11,"clone_into","","",14,N],[11,"try_from","","",14,[[["u"]],["result"]]],[11,"borrow","","",14,[[["self"]],["t"]]],[11,"get_type_id","","",14,[[["self"]],["typeid"]]],[11,"try_into","","",14,[[["self"]],["result"]]],[11,"borrow_mut","","",14,[[["self"]],["t"]]],[11,"clone_box","","",14,N],[11,"from","holochain_core::nucleus","",15,[[["t"]],["t"]]],[11,"into","","",15,[[["self"]],["u"]]],[11,"to_owned","","",15,[[["self"]],["t"]]],[11,"clone_into","","",15,N],[11,"try_from","","",15,[[["u"]],["result"]]],[11,"borrow","","",15,[[["self"]],["t"]]],[11,"get_type_id","","",15,[[["self"]],["typeid"]]],[11,"try_into","","",15,[[["self"]],["result"]]],[11,"borrow_mut","","",15,[[["self"]],["t"]]],[11,"equivalent","","",15,[[["self"],["k"]],["bool"]]],[11,"clone_box","","",15,N],[11,"from","","",16,[[["t"]],["t"]]],[11,"into","","",16,[[["self"]],["u"]]],[11,"to_owned","","",16,[[["self"]],["t"]]],[11,"clone_into","","",16,N],[11,"try_from","","",16,[[["u"]],["result"]]],[11,"borrow","","",16,[[["self"]],["t"]]],[11,"get_type_id","","",16,[[["self"]],["typeid"]]],[11,"try_into","","",16,[[["self"]],["result"]]],[11,"borrow_mut","","",16,[[["self"]],["t"]]],[11,"equivalent","","",16,[[["self"],["k"]],["bool"]]],[11,"clone_box","","",16,N],[11,"from","","",27,[[["t"]],["t"]]],[11,"into","","",27,[[["self"]],["u"]]],[11,"to_owned","","",27,[[["self"]],["t"]]],[11,"clone_into","","",27,N],[11,"try_from","","",27,[[["u"]],["result"]]],[11,"borrow","","",27,[[["self"]],["t"]]],[11,"get_type_id","","",27,[[["self"]],["typeid"]]],[11,"try_into","","",27,[[["self"]],["result"]]],[11,"borrow_mut","","",27,[[["self"]],["t"]]],[11,"clone_box","","",27,N],[11,"from","holochain_core::nucleus::actions::build_validation_package","",38,[[["t"]],["t"]]],[11,"into","","",38,[[["self"]],["u"]]],[11,"try_from","","",38,[[["u"]],["result"]]],[11,"borrow","","",38,[[["self"]],["t"]]],[11,"get_type_id","","",38,[[["self"]],["typeid"]]],[11,"try_into","","",38,[[["self"]],["result"]]],[11,"borrow_mut","","",38,[[["self"]],["t"]]],[11,"try_poll","","",38,[[["pin"],["localwaker"]],["poll"]]],[11,"from","holochain_core::nucleus::actions::initialize","",39,[[["t"]],["t"]]],[11,"into","","",39,[[["self"]],["u"]]],[11,"try_from","","",39,[[["u"]],["result"]]],[11,"borrow","","",39,[[["self"]],["t"]]],[11,"get_type_id","","",39,[[["self"]],["typeid"]]],[11,"try_into","","",39,[[["self"]],["result"]]],[11,"borrow_mut","","",39,[[["self"]],["t"]]],[11,"try_poll","","",39,[[["pin"],["localwaker"]],["poll"]]],[11,"from","holochain_core::nucleus::actions::validate","",40,[[["t"]],["t"]]],[11,"into","","",40,[[["self"]],["u"]]],[11,"try_from","","",40,[[["u"]],["result"]]],[11,"borrow","","",40,[[["self"]],["t"]]],[11,"get_type_id","","",40,[[["self"]],["typeid"]]],[11,"try_into","","",40,[[["self"]],["result"]]],[11,"borrow_mut","","",40,[[["self"]],["t"]]],[11,"try_poll","","",40,[[["pin"],["localwaker"]],["poll"]]],[11,"from","holochain_core::nucleus::ribosome","",17,[[["t"]],["t"]]],[11,"into","","",17,[[["self"]],["u"]]],[11,"to_owned","","",17,[[["self"]],["t"]]],[11,"clone_into","","",17,N],[11,"try_from","","",17,[[["u"]],["result"]]],[11,"borrow","","",17,[[["self"]],["t"]]],[11,"get_type_id","","",17,[[["self"]],["typeid"]]],[11,"try_into","","",17,[[["self"]],["result"]]],[11,"borrow_mut","","",17,[[["self"]],["t"]]],[11,"clone_box","","",17,N],[11,"from","holochain_core::nucleus::ribosome::api","",18,[[["t"]],["t"]]],[11,"into","","",18,[[["self"]],["u"]]],[11,"try_from","","",18,[[["u"]],["result"]]],[11,"borrow","","",18,[[["self"]],["t"]]],[11,"get_type_id","","",18,[[["self"]],["typeid"]]],[11,"try_into","","",18,[[["self"]],["result"]]],[11,"borrow_mut","","",18,[[["self"]],["t"]]],[11,"equivalent","","",18,[[["self"],["k"]],["bool"]]],[11,"from","holochain_core::nucleus::ribosome::callback","",19,[[["t"]],["t"]]],[11,"into","","",19,[[["self"]],["u"]]],[11,"try_from","","",19,[[["u"]],["result"]]],[11,"borrow","","",19,[[["self"]],["t"]]],[11,"get_type_id","","",19,[[["self"]],["typeid"]]],[11,"try_into","","",19,[[["self"]],["result"]]],[11,"borrow_mut","","",19,[[["self"]],["t"]]],[11,"from","","",20,[[["t"]],["t"]]],[11,"into","","",20,[[["self"]],["u"]]],[11,"to_string","","",20,[[["self"]],["string"]]],[11,"try_from","","",20,[[["u"]],["result"]]],[11,"borrow","","",20,[[["self"]],["t"]]],[11,"get_type_id","","",20,[[["self"]],["typeid"]]],[11,"try_into","","",20,[[["self"]],["result"]]],[11,"borrow_mut","","",20,[[["self"]],["t"]]],[11,"from","","",21,[[["t"]],["t"]]],[11,"into","","",21,[[["self"]],["u"]]],[11,"to_owned","","",21,[[["self"]],["t"]]],[11,"clone_into","","",21,N],[11,"try_from","","",21,[[["u"]],["result"]]],[11,"borrow","","",21,[[["self"]],["t"]]],[11,"get_type_id","","",21,[[["self"]],["typeid"]]],[11,"try_into","","",21,[[["self"]],["result"]]],[11,"borrow_mut","","",21,[[["self"]],["t"]]],[11,"clone_box","","",21,N],[11,"from","holochain_core::nucleus::ribosome::callback::links_utils","",22,[[["t"]],["t"]]],[11,"into","","",22,[[["self"]],["u"]]],[11,"try_from","","",22,[[["u"]],["result"]]],[11,"borrow","","",22,[[["self"]],["t"]]],[11,"get_type_id","","",22,[[["self"]],["typeid"]]],[11,"try_into","","",22,[[["self"]],["result"]]],[11,"borrow_mut","","",22,[[["self"]],["t"]]],[11,"from","holochain_core::nucleus::ribosome::memory","",23,[[["t"]],["t"]]],[11,"into","","",23,[[["self"]],["u"]]],[11,"to_owned","","",23,[[["self"]],["t"]]],[11,"clone_into","","",23,N],[11,"try_from","","",23,[[["u"]],["result"]]],[11,"borrow","","",23,[[["self"]],["t"]]],[11,"get_type_id","","",23,[[["self"]],["typeid"]]],[11,"try_into","","",23,[[["self"]],["result"]]],[11,"borrow_mut","","",23,[[["self"]],["t"]]],[11,"clone_box","","",23,N],[11,"from","holochain_core::nucleus::state","",25,[[["t"]],["t"]]],[11,"into","","",25,[[["self"]],["u"]]],[11,"to_owned","","",25,[[["self"]],["t"]]],[11,"clone_into","","",25,N],[11,"try_from","","",25,[[["u"]],["result"]]],[11,"borrow","","",25,[[["self"]],["t"]]],[11,"get_type_id","","",25,[[["self"]],["typeid"]]],[11,"try_into","","",25,[[["self"]],["result"]]],[11,"borrow_mut","","",25,[[["self"]],["t"]]],[11,"clone_box","","",25,N],[11,"from","","",26,[[["t"]],["t"]]],[11,"into","","",26,[[["self"]],["u"]]],[11,"to_owned","","",26,[[["self"]],["t"]]],[11,"clone_into","","",26,N],[11,"try_from","","",26,[[["u"]],["result"]]],[11,"borrow","","",26,[[["self"]],["t"]]],[11,"get_type_id","","",26,[[["self"]],["typeid"]]],[11,"try_into","","",26,[[["self"]],["result"]]],[11,"borrow_mut","","",26,[[["self"]],["t"]]],[11,"clone_box","","",26,N],[11,"from","holochain_core::persister","",29,[[["t"]],["t"]]],[11,"into","","",29,[[["self"]],["u"]]],[11,"to_owned","","",29,[[["self"]],["t"]]],[11,"clone_into","","",29,N],[11,"try_from","","",29,[[["u"]],["result"]]],[11,"borrow","","",29,[[["self"]],["t"]]],[11,"get_type_id","","",29,[[["self"]],["typeid"]]],[11,"try_into","","",29,[[["self"]],["result"]]],[11,"borrow_mut","","",29,[[["self"]],["t"]]],[11,"clone_box","","",29,N],[11,"from","holochain_core::state","",30,[[["t"]],["t"]]],[11,"into","","",30,[[["self"]],["u"]]],[11,"to_owned","","",30,[[["self"]],["t"]]],[11,"clone_into","","",30,N],[11,"try_from","","",30,[[["u"]],["result"]]],[11,"borrow","","",30,[[["self"]],["t"]]],[11,"get_type_id","","",30,[[["self"]],["typeid"]]],[11,"try_into","","",30,[[["self"]],["result"]]],[11,"borrow_mut","","",30,[[["self"]],["t"]]],[11,"clone_box","","",30,N],[11,"log","holochain_core::logger","",34,[[["self"],["string"]]]],[11,"as_str","holochain_core::nucleus::ribosome::api","",18,[[["self"]],["str"]]],[11,"str_to_index","","",18,[[["str"]],["usize"]]],[11,"from_index","","",18,[[["usize"]],["self"]]],[11,"capability","","",18,[[["self"]],["reservedcapabilitynames"]]],[11,"as_str","holochain_core::nucleus::ribosome::callback","",19,[[["self"]],["str"]]],[11,"str_to_index","","",19,[[["str"]],["usize"]]],[11,"from_index","","",19,[[["usize"]],["self"]]],[11,"capability","","",19,[[["self"]],["reservedcapabilitynames"]]],[11,"save","holochain_core::persister","",29,[[["self"],["state"]],["result",["holochainerror"]]]],[11,"load","","",29,[[["self"],["arc",["context"]]],["result",["option","holochainerror"]]]],[11,"eq","holochain_core::action","",1,[[["self"],["actionwrapper"]],["bool"]]],[11,"eq","","",0,[[["self"],["action"]],["bool"]]],[11,"ne","","",0,[[["self"],["action"]],["bool"]]],[11,"eq","holochain_core::agent::chain_store","",2,[[["self"],["chainstore"]],["bool"]]],[11,"eq","holochain_core::agent::state","",6,[[["self"],["agentstate"]],["bool"]]],[11,"ne","","",6,[[["self"],["agentstate"]],["bool"]]],[11,"eq","","",5,[[["self"],["actionresponse"]],["bool"]]],[11,"ne","","",5,[[["self"],["actionresponse"]],["bool"]]],[11,"eq","holochain_core::dht::dht_store","",9,[[["self"],["dhtstore"]],["bool"]]],[11,"eq","holochain_core::network::state","",14,[[["self"],["networkstate"]],["bool"]]],[11,"eq","holochain_core::nucleus::ribosome::api","",18,[[["self"],["zomeapifunction"]],["bool"]]],[11,"eq","holochain_core::nucleus::ribosome::callback","",19,[[["self"],["callback"]],["bool"]]],[11,"eq","","",21,[[["self"],["callbackresult"]],["bool"]]],[11,"ne","","",21,[[["self"],["callbackresult"]],["bool"]]],[11,"eq","holochain_core::nucleus::state","",26,[[["self"],["nucleusstatus"]],["bool"]]],[11,"ne","","",26,[[["self"],["nucleusstatus"]],["bool"]]],[11,"eq","","",25,[[["self"],["nucleusstate"]],["bool"]]],[11,"ne","","",25,[[["self"],["nucleusstate"]],["bool"]]],[11,"eq","holochain_core::nucleus","",15,[[["self"],["zomefncall"]],["bool"]]],[11,"ne","","",15,[[["self"],["zomefncall"]],["bool"]]],[11,"eq","","",16,[[["self"],["entrysubmission"]],["bool"]]],[11,"ne","","",16,[[["self"],["entrysubmission"]],["bool"]]],[11,"eq","","",27,[[["self"],["executezomefnresponse"]],["bool"]]],[11,"ne","","",27,[[["self"],["executezomefnresponse"]],["bool"]]],[11,"eq","holochain_core::persister","",29,[[["self"],["simplepersister"]],["bool"]]],[11,"eq","holochain_core::state","",30,[[["self"],["state"]],["bool"]]],[11,"ne","","",30,[[["self"],["state"]],["bool"]]],[11,"from","holochain_core::nucleus::ribosome::callback","",21,[[["jsonstring"]],["callbackresult"]]],[11,"from","","",21,[[["ribosomereturncode"]],["callbackresult"]]],[11,"clone","holochain_core::action","",1,[[["self"]],["actionwrapper"]]],[11,"clone","","",0,[[["self"]],["action"]]],[11,"clone","holochain_core::agent::chain_store","",2,[[["self"]],["chainstore"]]],[11,"clone","holochain_core::agent::state","",6,[[["self"]],["agentstate"]]],[11,"clone","","",7,[[["self"]],["agentstatesnapshot"]]],[11,"clone","","",5,[[["self"]],["actionresponse"]]],[11,"clone","holochain_core::context","",8,[[["self"]],["context"]]],[11,"clone","holochain_core::dht::dht_store","",9,[[["self"]],["dhtstore"]]],[11,"clone","holochain_core::instance","",11,[[["self"]],["instance"]]],[11,"clone","holochain_core::logger","",34,[[["self"]],["simplelogger"]]],[11,"clone","holochain_core::network::actions","",13,[[["self"]],["actionresponse"]]],[11,"clone","holochain_core::network::state","",14,[[["self"]],["networkstate"]]],[11,"clone","holochain_core::nucleus::ribosome::callback","",21,[[["self"]],["callbackresult"]]],[11,"clone","holochain_core::nucleus::ribosome::memory","",23,[[["self"]],["singlepagemanager"]]],[11,"clone","holochain_core::nucleus::ribosome","",17,[[["self"]],["runtime"]]],[11,"clone","holochain_core::nucleus::state","",26,[[["self"]],["nucleusstatus"]]],[11,"clone","","",25,[[["self"]],["nucleusstate"]]],[11,"clone","holochain_core::nucleus","",15,[[["self"]],["zomefncall"]]],[11,"clone","","",16,[[["self"]],["entrysubmission"]]],[11,"clone","","",27,[[["self"]],["executezomefnresponse"]]],[11,"clone","holochain_core::persister","",29,[[["self"]],["simplepersister"]]],[11,"clone","holochain_core::state","",30,[[["self"]],["state"]]],[11,"next","holochain_core::agent::chain_store","May panic if there is an underlying error in the table",3,[[["self"]],["option",["chainheader"]]]],[11,"next","","May panic if there is an underlying error in the table",4,[[["self"]],["option",["chainheader"]]]],[11,"to_string","holochain_core::nucleus::ribosome::callback","",20,[[["self"]],["string"]]],[11,"default","holochain_core::nucleus::state","",26,[[],["self"]]],[11,"default","","",25,[[],["nucleusstate"]]],[11,"fmt","holochain_core::action","",1,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",0,[[["self"],["formatter"]],["result"]]],[11,"fmt","holochain_core::agent::chain_store","",2,[[["self"],["formatter"]],["result"]]],[11,"fmt","holochain_core::agent::state","",6,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",7,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",5,[[["self"],["formatter"]],["result"]]],[11,"fmt","holochain_core::dht::dht_store","",9,[[["self"],["formatter"]],["result"]]],[11,"fmt","holochain_core::network::actions","",13,[[["self"],["formatter"]],["result"]]],[11,"fmt","holochain_core::network::state","",14,[[["self"],["formatter"]],["result"]]],[11,"fmt","holochain_core::nucleus::ribosome::api","",18,[[["self"],["formatter"]],["result"]]],[11,"fmt","holochain_core::nucleus::ribosome::callback","",19,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",20,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",21,[[["self"],["formatter"]],["result"]]],[11,"fmt","holochain_core::nucleus::ribosome::memory","",23,[[["self"],["formatter"]],["result"]]],[11,"fmt","holochain_core::nucleus::state","",26,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",25,[[["self"],["formatter"]],["result"]]],[11,"fmt","holochain_core::nucleus","",15,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",16,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",27,[[["self"],["formatter"]],["result"]]],[11,"fmt","holochain_core::state","",30,[[["self"],["formatter"]],["result"]]],[11,"try_from","holochain_core::agent::state","",7,[[["jsonstring"]],["result"]]],[11,"try_from","","",7,[[["jsonstring"]],["result"]]],[11,"try_from","","",7,[[["state"]],["result"]]],[11,"try_from","","",5,[[["jsonstring"]],["result"]]],[11,"try_from","","",5,[[["jsonstring"]],["result"]]],[11,"try_from","holochain_core::nucleus::ribosome::callback","",20,[[["jsonstring"]],["result"]]],[11,"try_from","","",20,[[["jsonstring"]],["result"]]],[11,"from_str","holochain_core::nucleus::ribosome::api","",18,[[["str"]],["result"]]],[11,"from_str","holochain_core::nucleus::ribosome::callback","",19,[[["str"]],["result"]]],[11,"hash","holochain_core::action","@TODO dangerous when persisted! snowflake only guarantees uniqueness per process @see https://github.com/holochain/holochain-rust/issues/203",1,[[["self"],["h"]]]],[11,"hash","holochain_core::nucleus","",15,N],[11,"hash","","",16,N],[11,"hash","","",27,N],[11,"poll","holochain_core::agent::actions::commit","",31,[[["pin"],["localwaker"]],["poll"]]],[11,"poll","holochain_core::dht::actions::add_link","",32,[[["pin"],["localwaker"]],["poll"]]],[11,"poll","holochain_core::dht::actions::hold","",33,[[["pin"],["localwaker"]],["poll"]]],[11,"poll","holochain_core::network::actions::get_entry","",35,[[["pin"],["localwaker"]],["poll"]]],[11,"poll","holochain_core::network::actions::initialize_network","",36,[[["pin"],["localwaker"]],["poll"]]],[11,"poll","holochain_core::network::actions::publish","",37,[[["pin"],["localwaker"]],["poll"]]],[11,"poll","holochain_core::nucleus::actions::build_validation_package","",38,[[["pin"],["localwaker"]],["poll"]]],[11,"poll","holochain_core::nucleus::actions::initialize","",39,[[["pin"],["localwaker"]],["poll"]]],[11,"poll","holochain_core::nucleus::actions::validate","",40,[[["pin"],["localwaker"]],["poll"]]],[11,"from_i64","holochain_core::nucleus::ribosome::api","",18,[[["i64"]],["option"]]],[11,"from_u64","","",18,[[["u64"]],["option"]]],[11,"from_i64","holochain_core::nucleus::ribosome::callback","",19,[[["i64"]],["option"]]],[11,"from_u64","","",19,[[["u64"]],["option"]]],[11,"serialize","holochain_core::agent::state","",7,[[["self"],["__s"]],["result"]]],[11,"serialize","","",5,[[["self"],["__s"]],["result"]]],[11,"serialize","holochain_core::nucleus::ribosome::callback","",20,[[["self"],["__s"]],["result"]]],[11,"serialize","","",21,[[["self"],["__s"]],["result"]]],[11,"deserialize","holochain_core::agent::state","",7,[[["__d"]],["result"]]],[11,"deserialize","","",5,[[["__d"]],["result"]]],[11,"deserialize","holochain_core::nucleus::ribosome::callback","",20,[[["__d"]],["result"]]],[11,"deserialize","","",21,[[["__d"]],["result"]]],[11,"invoke_index","holochain_core::nucleus::ribosome","",17,[[["self"],["usize"],["runtimeargs"]],["zomeapiresult"]]],[11,"content","holochain_core::agent::state","",7,[[["self"]],["content"]]],[11,"try_from_content","","",7,[[["content"]],["result",["holochainerror"]]]],[11,"address","","",7,[[["self"]],["address"]]]],"paths":[[4,"Action"],[3,"ActionWrapper"],[3,"ChainStore"],[3,"ChainStoreIterator"],[3,"ChainStoreTypeIterator"],[4,"ActionResponse"],[3,"AgentState"],[3,"AgentStateSnapshot"],[3,"Context"],[3,"DhtStore"],[3,"Observer"],[3,"Instance"],[8,"Logger"],[4,"ActionResponse"],[3,"NetworkState"],[3,"ZomeFnCall"],[3,"EntrySubmission"],[3,"Runtime"],[4,"ZomeApiFunction"],[4,"Callback"],[4,"CallbackParams"],[4,"CallbackResult"],[3,"LinkDefinitionPath"],[3,"SinglePageManager"],[8,"Defn"],[3,"NucleusState"],[4,"NucleusStatus"],[3,"ExecuteZomeFnResponse"],[8,"Persister"],[3,"SimplePersister"],[3,"State"],[3,"CommitFuture"],[3,"AddLinkFuture"],[3,"HoldEntryFuture"],[3,"SimpleLogger"],[3,"GetEntryFuture"],[3,"InitNetworkFuture"],[3,"PublishFuture"],[3,"ValidationPackageFuture"],[3,"InitializationFuture"],[3,"ValidationFuture"]]};
searchIndex["holochain_core_api_c_binding"]={"doc":"","items":[[5,"holochain_new","holochain_core_api_c_binding","",N,N],[5,"holochain_load","","",N,N],[5,"holochain_start","","",N,N],[5,"holochain_stop","","",N,N],[5,"holochain_call","","",N,N]],"paths":[]};
searchIndex["holochain_core_types"]={"doc":"Holochain Core Types","items":[[0,"cas","holochain_core_types","",N,N],[0,"content","holochain_core_types::cas","",N,N],[3,"ExampleAddressableContent","holochain_core_types::cas::content","some struct that can be content addressed imagine an Entry, ChainHeader, Meta Value, etc.",N,N],[3,"OtherExampleAddressableContent","","another struct that can be content addressed used to show ExampleCas storing multiple types",N,N],[3,"AddressableContentTestSuite","","",N,N],[6,"Address","","an Address for some Content ideally would be the Content but pragmatically must be Address consider what would happen if we had multi GB addresses...",N,N],[6,"Content","","the Content is a JsonString this is the only way to be confident in persisting all Rust types across all backends",N,N],[8,"AddressableContent","","can be stored as serialized content the content is the address, there is no \"location\" like a file system or URL @see https://en.wikipedia.org/wiki/Content-addressable_storage",N,N],[11,"address","","the Address the Content would be available at once stored in a ContentAddressableStorage default implementation is provided as hashing Content with sha256 the default implementation should cover most use-cases it is critical that there are no hash collisions across all stored AddressableContent it is recommended to implement an \"address space\" prefix for address algorithms that don't offer strong cryptographic guarantees like sha et. al.",0,[[["self"]],["address"]]],[10,"content","","the Content that would be stored in a ContentAddressableStorage the default implementation covers anything that implements From for JsonString",0,[[["self"]],["content"]]],[10,"try_from_content","","restore/deserialize the original struct/type from serialized Content the default implementation covers anything that implements From for Foo",0,[[["content"]],["result",["holochainerror"]]]],[11,"addressable_content_trait_test","","test that trait gives the write content",1,[[["content"],["t"],["address"]]]],[11,"addressable_contents_are_the_same_test","","test that two different addressable contents would give them same thing",1,[[["content"]]]],[11,"addressable_content_round_trip","","",1,[[["vec"],["k"]]]],[0,"storage","holochain_core_types::cas","",N,N],[3,"ExampleContentAddressableStorage","holochain_core_types::cas::storage","some struct to show an example ContentAddressableStorage implementation this is a thread-safe wrapper around the non-thread-safe implementation below @see ExampleContentAddressableStorageActor",N,N],[3,"ExampleContentAddressableStorageContent","","Not thread-safe CAS implementation with a HashMap",N,N],[3,"StorageTestSuite","","",N,N],[12,"cas","","",2,N],[12,"cas_clone","","it is important that every cloned copy of any CAS has a consistent view to data",2,N],[3,"EavTestSuite","","",N,N],[5,"test_content_addressable_storage","","",N,[[],["examplecontentaddressablestorage"]]],[8,"ContentAddressableStorage","","content addressable store (CAS) implements storage in memory or persistently anything implementing AddressableContent can be added and fetched by address CAS is append only",N,N],[10,"add","","adds AddressableContent to the ContentAddressableStorage by its Address as Content",3,[[["self"],["addressablecontent"]],["result",["holochainerror"]]]],[10,"contains","","true if the Address is in the Store, false otherwise. may be more efficient than retrieve depending on the implementation.",3,[[["self"],["address"]],["result",["bool","holochainerror"]]]],[10,"fetch","","returns Some AddressableContent if it is in the Store, else None AddressableContent::from_content() can be used to allow the compiler to infer the type @see the fetch implementation for ExampleCas in the cas module tests",3,[[["self"],["address"]],["result",["option","holochainerror"]]]],[10,"get_id","","",3,[[["self"]],["uuid"]]],[11,"new","","",4,[[],["result",["examplecontentaddressablestorage","holochainerror"]]]],[11,"new","","",5,[[],["examplecontentaddressablestoragecontent"]]],[11,"new","","",2,[[["t"]],["storagetestsuite"]]],[11,"round_trip_test","","",2,[[["self"],["content"],["content"]]]],[11,"test_round_trip","","",6,N],[11,"test_one_to_many","","",6,[[["s"]]]],[11,"test_many_to_one","","",6,[[["s"]]]],[0,"chain_header","holochain_core_types","",N,N],[3,"ChainHeader","holochain_core_types::chain_header","ChainHeader of a source chain \"Item\" The address of the ChainHeader is used as the Item's key in the source chain hash table ChainHeaders are linked to next header in chain and next header of same type in chain",N,N],[5,"test_chain_header","","returns a dummy header for use in tests",N,[[],["chainheader"]]],[11,"new","","build a new ChainHeader from a chain, entry type and entry. a ChainHeader is immutable, but the chain is mutable if chain.push() is used. this means that a header becomes invalid and useless as soon as the chain is mutated the only valid usage of a header is to immediately push it onto a chain in a Pair. normally (outside unit tests) the generation of valid headers is internal to the chain::SourceChain trait and should not need to be handled manually",7,[[["entrytype"],["address"],["signature"],["option"],["option"],["iso8601"]],["self"]]],[11,"entry_type","","entry_type getter",7,[[["self"]],["entrytype"]]],[11,"timestamp","","timestamp getter",7,[[["self"]],["iso8601"]]],[11,"link","","link getter",7,[[["self"]],["option",["address"]]]],[11,"entry_address","","entry_address getter",7,[[["self"]],["address"]]],[11,"link_same_type","","link_same_type getter",7,[[["self"]],["option",["address"]]]],[11,"entry_signature","","entry_signature getter",7,[[["self"]],["signature"]]],[0,"crud_status","holochain_core_types","",N,N],[3,"CrudStatus","holochain_core_types::crud_status","the CRUD status of a Pair is stored as EntryMeta in the hash table, NOT in the entry itself statuses are represented as bitflags so we can easily build masks for filtering lookups",N,N],[17,"STATUS_NAME","","",N,N],[17,"LINK_NAME","","",N,N],[18,"LIVE","","",8,N],[18,"REJECTED","","",8,N],[18,"DELETED","","",8,N],[18,"MODIFIED","","",8,N],[18,"LOCKED","","CRDT resolution in progress",8,N],[11,"empty","","Returns an empty set of flags.",8,[[],["crudstatus"]]],[11,"all","","Returns the set containing all flags.",8,[[],["crudstatus"]]],[11,"bits","","Returns the raw value of the flags currently stored.",8,[[["self"]],["u8"]]],[11,"from_bits","","Convert from underlying bit representation, unless that representation contains bits that do not correspond to a flag.",8,[[["u8"]],["option",["crudstatus"]]]],[11,"from_bits_truncate","","Convert from underlying bit representation, dropping any bits that do not correspond to flags.",8,[[["u8"]],["crudstatus"]]],[11,"is_empty","","Returns `true` if no flags are currently stored.",8,[[["self"]],["bool"]]],[11,"is_all","","Returns `true` if all flags are currently set.",8,[[["self"]],["bool"]]],[11,"intersects","","Returns `true` if there are flags common to both `self` and `other`.",8,[[["self"],["crudstatus"]],["bool"]]],[11,"contains","","Returns `true` all of the flags in `other` are contained within `self`.",8,[[["self"],["crudstatus"]],["bool"]]],[11,"insert","","Inserts the specified flags in-place.",8,[[["self"],["crudstatus"]]]],[11,"remove","","Removes the specified flags in-place.",8,[[["self"],["crudstatus"]]]],[11,"toggle","","Toggles the specified flags in-place.",8,[[["self"],["crudstatus"]]]],[11,"set","","Inserts or removes the specified flags depending on the passed value.",8,[[["self"],["crudstatus"],["bool"]]]],[0,"eav","holochain_core_types","",N,N],[3,"EntityAttributeValue","holochain_core_types::eav","",N,N],[3,"ExampleEntityAttributeValueStorageNonSync","","",N,N],[3,"ExampleEntityAttributeValueStorage","","",N,N],[5,"test_eav_entity","","",N,[[],["entry"]]],[5,"test_eav_attribute","","",N,[[],["string"]]],[5,"test_eav_value","","",N,[[],["entry"]]],[5,"test_eav","","",N,[[],["entityattributevalue"]]],[5,"test_eav_content","","",N,[[],["content"]]],[5,"test_eav_address","","",N,[[],["address"]]],[5,"eav_round_trip_test_runner","","",N,N],[6,"Entity","","EAV (entity-attribute-value) data ostensibly for metadata about entries in the DHT defines relationships between AddressableContent values implemented on top of cas::storage::ContentAddressableStorage @see https://en.wikipedia.org/wiki/Entity%E2%80%93attribute%E2%80%93value_model Address of AddressableContent representing the EAV entity",N,N],[6,"Attribute","","using String for EAV attributes (not e.g. an enum) keeps it simple and open",N,N],[6,"Value","","Address of AddressableContent representing the EAV value",N,N],[8,"EntityAttributeValueStorage","","eav storage does NOT provide storage for AddressableContent use cas::storage::ContentAddressableStorage to store AddressableContent provides a simple and flexible interface to define relationships between AddressableContent",N,N],[10,"add_eav","","adds the given EntityAttributeValue to the EntityAttributeValueStorage append only storage eavs are retrieved through constraint based lookups @see fetch_eav",9,[[["self"],["entityattributevalue"]],["result",["holochainerror"]]]],[10,"fetch_eav","","fetches the set of EntityAttributeValues that match constraints None = no constraint Some(Entity) = requires the given entity (e.g. all a/v pairs for the entity) Some(Attribute) = requires the given attribute (e.g. all links) Some(Value) = requires the given value (e.g. all entities referencing an Address)",9,[[["self"],["option",["entity"]],["option",["attribute"]],["option",["value"]]],["result",["hashset","holochainerror"]]]],[11,"new","","",10,[[["entity"],["attribute"],["value"]],["entityattributevalue"]]],[11,"entity","","",10,[[["self"]],["entity"]]],[11,"attribute","","",10,[[["self"]],["attribute"]]],[11,"value","","",10,[[["self"]],["value"]]],[11,"filter_on_eav","","this is a predicate for matching on eav values. Useful for reducing duplicated filtered code.",10,[[["t"],["option"]],["bool"]]],[11,"new","","",11,[[],["exampleentityattributevaluestoragenonsync"]]],[11,"new","","",12,[[],["hcresult",["exampleentityattributevaluestorage"]]]],[0,"entry","holochain_core_types","",N,N],[4,"Entry","holochain_core_types::entry","Structure holding actual data in a source chain \"Item\" data is stored as a JsonString",N,N],[13,"App","","",13,N],[13,"Dna","","",13,N],[13,"AgentId","","",13,N],[13,"Delete","","",13,N],[13,"LinkAdd","","",13,N],[13,"LinkRemove","","",13,N],[13,"LinkList","","",13,N],[13,"ChainHeader","","",13,N],[13,"ChainMigrate","","",13,N],[5,"test_entry_value","","dummy entry value",N,[[],["jsonstring"]]],[5,"test_entry_content","","",N,[[],["content"]]],[5,"test_entry_value_a","","dummy entry content, same as test_entry_value()",N,[[],["jsonstring"]]],[5,"test_entry_value_b","","dummy entry content, differs from test_entry_value()",N,[[],["jsonstring"]]],[5,"test_entry_value_c","","",N,[[],["jsonstring"]]],[5,"test_sys_entry_value","","",N,[[],["agentid"]]],[5,"test_entry","","dummy entry",N,[[],["entry"]]],[5,"expected_serialized_entry_content","","",N,[[],["jsonstring"]]],[5,"expected_entry_address","","the correct address for test_entry()",N,[[],["address"]]],[5,"test_entry_a","","dummy entry, same as test_entry()",N,[[],["entry"]]],[5,"test_entry_b","","dummy entry, differs from test_entry()",N,[[],["entry"]]],[5,"test_entry_c","","",N,[[],["entry"]]],[5,"test_entry_unique","","dummy entry with unique string content",N,[[],["entry"]]],[5,"test_sys_entry","","",N,[[],["entry"]]],[5,"test_sys_entry_address","","",N,[[],["address"]]],[5,"test_unpublishable_entry","","",N,[[],["entry"]]],[0,"entry_type","","",N,N],[3,"AppEntryType","holochain_core_types::entry::entry_type","",N,N],[4,"EntryType","","",N,N],[13,"App","","",14,N],[13,"Dna","","",14,N],[13,"AgentId","","",14,N],[13,"Delete","","",14,N],[13,"LinkAdd","","",14,N],[13,"LinkRemove","","",14,N],[13,"LinkList","","",14,N],[13,"ChainHeader","","",14,N],[13,"ChainMigrate","","",14,N],[5,"test_app_entry_type","","dummy entry type",N,[[],["appentrytype"]]],[5,"test_entry_type","","",N,[[],["entrytype"]]],[5,"test_app_entry_type_a","","dummy entry type, same as test_type()",N,[[],["appentrytype"]]],[5,"test_entry_type_a","","",N,[[],["entrytype"]]],[5,"test_app_entry_type_b","","dummy entry type, differs from test_type()",N,[[],["appentrytype"]]],[5,"test_entry_type_b","","",N,[[],["entrytype"]]],[11,"is_app","","",14,[[["self"]],["bool"]]],[11,"is_sys","","",14,[[["self"]],["bool"]]],[11,"can_publish","","",14,[[["self"]],["bool"]]],[11,"has_valid_app_name","","Checks entry_type_name is valid",14,[[["str"]],["bool"]]],[6,"AppEntryValue","holochain_core_types::entry","",N,N],[11,"entry_type","","",13,[[["self"]],["entrytype"]]],[0,"error","holochain_core_types","",N,N],[4,"DnaError","holochain_core_types::error","",N,N],[13,"ZomeNotFound","","",15,N],[13,"CapabilityNotFound","","",15,N],[13,"ZomeFunctionNotFound","","",15,N],[4,"RibosomeReturnCode","","Enum of all possible RETURN codes that a Zome API Function could return. Represents an encoded allocation of zero length with the return code as offset. @see SinglePageAllocation",N,N],[13,"Success","","",16,N],[13,"Failure","","",16,N],[4,"RibosomeErrorCode","","Enum of all possible ERROR codes that a Zome API Function could return.",N,N],[13,"Unspecified","","",17,N],[13,"ArgumentDeserializationFailed","","",17,N],[13,"OutOfMemory","","",17,N],[13,"ReceivedWrongActionResult","","",17,N],[13,"CallbackFailed","","",17,N],[13,"RecursiveCallForbidden","","",17,N],[13,"ResponseSerializationFailed","","",17,N],[13,"NotAnAllocation","","",17,N],[13,"ZeroSizedAllocation","","",17,N],[13,"UnknownEntryType","","",17,N],[0,"error","","",N,N],[3,"CoreError","holochain_core_types::error::error","Holochain Core Error struct Any Error in Core should be wrapped in a CoreError so it can be passed to the Zome and back to the Holochain Instance via wasm memory. Follows the Error + ErrorKind pattern Holds extra debugging info for indicating where in code ther error occured.",N,N],[12,"kind","","",18,N],[12,"file","","",18,N],[12,"line","","",18,N],[3,"ZomeApiInternalResult","","",N,N],[12,"ok","","",19,N],[12,"value","","",19,N],[12,"error","","",19,N],[4,"HolochainError","","TODO rename to CoreErrorKind Enum holding all Holochain Core errors",N,N],[13,"ErrorGeneric","","",20,N],[13,"NotImplemented","","",20,N],[13,"LoggingError","","",20,N],[13,"DnaMissing","","",20,N],[13,"Dna","","",20,N],[13,"IoError","","",20,N],[13,"SerializationError","","",20,N],[13,"InvalidOperationOnSysEntry","","",20,N],[13,"DoesNotHaveCapabilityToken","","",20,N],[13,"ValidationFailed","","",20,N],[13,"Ribosome","","",20,N],[13,"RibosomeFailed","","",20,N],[13,"ConfigError","","",20,N],[13,"Timeout","","",20,N],[6,"HcResult","","",N,N],[11,"new","","",18,[[["holochainerror"]],["self"]]],[11,"new","","",20,[[["str"]],["holochainerror"]]],[11,"success","","",19,[[["j"]],["zomeapiinternalresult"]]],[11,"failure","","",19,[[["j"]],["zomeapiinternalresult"]]],[11,"from_error","holochain_core_types::error","",16,[[["ribosomeerrorcode"]],["self"]]],[11,"from_offset","","",16,[[["u16"]],["self"]]],[11,"as_str","","",17,[[["self"]],["str"]]],[11,"from_offset","","",17,[[["u16"]],["self"]]],[11,"from_return_code","","",17,[[["ribosomereturncode"]],["self"]]],[0,"agent","holochain_core_types","Represents an agent entry in the cas",N,N],[3,"KeyBuffer","holochain_core_types::agent","A raw public key buffer Can extract the signature and encryption portions Can parse a base64url encoded user representation Can render a base64url encoded user representation",N,N],[3,"AgentId","","agent data that can be stored in the cas note thate the \"address\" of an agent entry is the base64url encoded public key identity string",N,N],[12,"nick","","a nickname for referencing this agent",21,N],[12,"key","","the base64url encoded public identity string for this agent",21,N],[5,"test_agent_id","","",N,[[],["agentid"]]],[7,"GOOD_ID","","",N,N],[7,"BAD_ID","","",N,N],[11,"with_corrected","","take a potentially user-entered base64url encoded user representation of an public key identity apply reed-solomon parity correction returns a raw byte buffer",22,[[["str"]],["result",["keybuffer","holochainerror"]]]],[11,"with_raw","","generate a key buffer from raw bytes (no correction)",22,N],[11,"render","","render a base64url encoded user identity with reed-solomon parity bytes",22,[[["self"]],["string"]]],[11,"get_sig","","get the signature public key portion of this buffer",22,N],[11,"get_enc","","get the encryption public key portion of this buffer",22,N],[11,"generate_fake","","generate a fake testing agent `s` will be used for the `nick` and included in the key string as well this agent is not cryptographically generated... it will not be able to sign / encrypt anything",21,[[["str"]],["self"]]],[11,"new","","initialize an Agent struct with `nick` and `key`",21,[[["str"],["keybuffer"]],["self"]]],[11,"to_buffer","","get a key buffer based on this agent's key (no correction)",21,[[["self"]],["keybuffer"]]],[0,"chain_migrate","holochain_core_types","",N,N],[3,"ChainMigrate","holochain_core_types::chain_migrate","",N,N],[0,"delete","holochain_core_types","",N,N],[3,"Delete","holochain_core_types::delete","",N,N],[0,"dna","holochain_core_types","dna is a library for working with holochain dna files/entries.",N,N],[3,"Dna","holochain_core_types::dna","Represents the top-level holochain dna object.",N,N],[12,"name","","The top-level \"name\" of a holochain application.",23,N],[12,"description","","The top-level \"description\" of a holochain application.",23,N],[12,"version","","The semantic version of your holochain application.",23,N],[12,"uuid","","A unique identifier to distinguish your holochain application.",23,N],[12,"dna_spec_version","","Which version of the holochain dna spec does this represent?",23,N],[12,"properties","","Any arbitrary application properties can be included in this object.",23,N],[12,"zomes","","An array of zomes associated with your holochain application.",23,N],[0,"wasm","","holochain_core_types::dna::wasm is a module for managing webassembly code - within the in-memory dna struct - and serialized to json",N,N],[3,"DnaWasm","holochain_core_types::dna::wasm","Represents web assembly code.",N,N],[12,"code","","The actual binary WebAssembly bytecode goes here.",24,N],[11,"new","","Allow sane defaults for `DnaWasm::new()`.",24,[[],["self"]]],[0,"zome","holochain_core_types::dna","holochain_core_types::dna::zome is a set of structs for working with holochain dna.",N,N],[3,"Config","holochain_core_types::dna::zome","Represents the \"config\" object on a \"zome\".",N,N],[12,"error_handling","","How errors should be handled within this zome.",25,N],[3,"Zome","","Represents an individual \"zome\".",N,N],[12,"description","","A description of this zome.",26,N],[12,"config","","Configuration associated with this zome. Note, this should perhaps be a more free-form serde_json::Value, \"throw-errors\" may not make sense for wasm, or other ribosome types.",26,N],[12,"entry_types","","An array of entry_types associated with this zome.",26,N],[12,"capabilities","","An array of capabilities associated with this zome.",26,N],[12,"code","","Validation code for this entry_type.",26,N],[4,"ErrorHandling","","Enum for \"zome\" \"config\" \"error_handling\" property.",N,N],[13,"ThrowErrors","","",27,N],[0,"capabilities","","File holding all the structs for handling capabilities defined in DNA.",N,N],[3,"CapabilityType","holochain_core_types::dna::zome::capabilities","Represents the \"capability\" sub-object on a \"zome\" \"capabilities\" object.",N,N],[12,"membrane","","How visibility should be handled for this capability.",28,N],[3,"FnParameter","","",N,N],[12,"parameter_type","","",29,N],[12,"name","","",29,N],[3,"FnDeclaration","","Represents a zome \"fn_declarations\" object.",N,N],[12,"name","","The name of this fn declaration.",30,N],[12,"inputs","","",30,N],[12,"outputs","","",30,N],[3,"Capability","","Represents an individual object in the \"zome\" \"capabilities\" array.",N,N],[12,"cap_type","","\"capability\" sub-object",31,N],[12,"functions","","\"fn_declarations\" array",31,N],[4,"ReservedCapabilityNames","","Enumeration of all Capabilities known and used by HC Core Enumeration converts to str",N,N],[13,"MissingNo","","Development placeholder, no production fn should use MissingNo",32,N],[13,"LifeCycle","","@TODO document what LifeCycle is @see https://github.com/holochain/holochain-rust/issues/204",32,N],[13,"Communication","","@TODO document what Communication is @see https://github.com/holochain/holochain-rust/issues/204",32,N],[4,"Membrane","","Enum for Zome Capability \"membrane\" property.",N,N],[13,"Public","","",33,N],[13,"Agent","","",33,N],[13,"ApiKey","","",33,N],[13,"Zome","","",33,N],[11,"as_str","","",32,[[["self"]],["str"]]],[11,"new","","Allow sane defaults for `CapabilityType::new()`.",28,[[],["self"]]],[11,"new","","",29,[[["s"],["s"]],["fnparameter"]]],[11,"new","","Allow sane defaults for `FnDecrlaration::new()`.",30,[[],["self"]]],[11,"new","","Allow sane defaults for `Capability::new()`.",31,[[],["self"]]],[0,"entry_types","holochain_core_types::dna::zome","File holding all the structs for handling entry types defined by DNA.",N,N],[3,"LinksTo","holochain_core_types::dna::zome::entry_types","An individual object in a \"links_to\" array.",N,N],[12,"target_type","","The target_type of this links_to entry",34,N],[12,"tag","","The tag of this links_to entry",34,N],[3,"LinkedFrom","","An a definition of a link from another type (including anchors and system hashes) to the entry type it is part of.",N,N],[12,"base_type","","The target_type of this links_to entry",35,N],[12,"tag","","The tag of this links_to entry",35,N],[3,"EntryTypeDef","","Represents an individual object in the \"zome\" \"entry_types\" array.",N,N],[12,"description","","A description of this entry type.",36,N],[12,"sharing","","The sharing model of this entry type (public, private, encrypted).",36,N],[12,"links_to","","An array of link definitions associated with this entry type",36,N],[12,"linked_from","","An array of link definitions for links pointing to entries of this type",36,N],[4,"Sharing","","Enum for Zome EntryType \"sharing\" property.",N,N],[13,"Public","","",37,N],[13,"Private","","",37,N],[13,"Encrypted","","",37,N],[5,"serialize_entry_types","","",N,[[["zomeentrytypes"],["s"]],["result"]]],[5,"deserialize_entry_types","","",N,[[["d"]],["result",["zomeentrytypes"]]]],[11,"can_publish","","",37,[[["self"]],["bool"]]],[11,"new","","Allow sane defaults for `LinksTo::new()`.",34,[[],["self"]]],[11,"new","","Allow sane defaults for `LinkedFrom::new()`.",35,[[],["self"]]],[11,"new","","Allow sane defaults for `EntryType::new()`.",36,[[],["self"]]],[6,"ZomeEntryTypes","holochain_core_types::dna::zome","",N,N],[6,"ZomeCapabilities","","",N,N],[11,"new","","Allow sane defaults for `Config::new()`.",25,[[],["self"]]],[11,"new","","Allow sane defaults for `Zome::new()`.",26,[[["str"],["config"],["btreemap"],["btreemap"],["dnawasm"]],["zome"]]],[11,"new","holochain_core_types::dna","Create a new in-memory dna structure with some default values.",23,[[],["self"]]],[11,"to_json_pretty","","Generate a pretty-printed json string from an in-memory dna struct.",23,[[["self"]],["result",["string"]]]],[11,"get_zome","","Return a Zome",23,[[["self"],["str"]],["option",["zome"]]]],[11,"get_capability","","Return a Zome's Capability from a Zome and a Capability name.",23,[[["self"],["zome"],["str"]],["option",["capability"]]]],[11,"get_wasm_from_zome_name","","Find a Zome and return it's WASM bytecode for a specified Capability",23,[[["self"],["t"]],["option",["dnawasm"]]]],[11,"get_capability_with_zome_name","","Return a Zome's Capability from a Zome name and Capability name.",23,[[["self"],["str"],["str"]],["result",["capability","dnaerror"]]]],[11,"get_zome_name_for_app_entry_type","","Return the name of the zome holding a specified app entry_type",23,[[["self"],["appentrytype"]],["option",["string"]]]],[11,"get_entry_type_def","","Return the entry_type definition of a specified app entry_type",23,[[["self"],["str"]],["option",["entrytypedef"]]]],[11,"multihash","","",23,[[["self"]],["result",["vec","holochainerror"]]]],[0,"file_validation","holochain_core_types","",N,N],[5,"validate_canonical_path","holochain_core_types::file_validation","",N,[[["str"]],["result",["string","holochainerror"]]]],[0,"hash","holochain_core_types","",N,N],[3,"HashString","holochain_core_types::hash","",N,N],[11,"new","","",38,[[],["hashstring"]]],[11,"encode_from_bytes","","convert bytes to a b58 hashed string",38,N],[11,"encode_from_str","","convert a string as bytes to a b58 hashed string",38,[[["str"],["hash"]],["hashstring"]]],[11,"encode_from_json_string","","magic all in one fn, take a JsonString + hash type and get a hashed b58 string back",38,[[["jsonstring"],["hash"]],["hashstring"]]],[0,"json","holochain_core_types","",N,N],[3,"JsonString","holochain_core_types::json","track json serialization with the rust type system! JsonString wraps a string containing JSON serialized data avoid accidental double-serialization or forgetting to serialize serialize any type consistently including hard-to-reach places like Option and Result JsonString must not itself be serialized/deserialized instead, implement and use the native `From` trait to move between types - moving to/from String, str, JsonString and JsonString simply (un)wraps it as raw JSON data - moving to/from any other type must offer a reliable serialization/deserialization strategy",N,N],[3,"RawString","","generic type to facilitate Jsonifying values directly JsonString simply wraps String and str as-is but will Jsonify RawString(\"foo\") as \"\"foo\"\" RawString must not implement Serialize because it should always convert to JsonString with from RawString can implement Deserialize because JsonString uses default serde to step down",N,N],[5,"default_to_json","","if all you want to do is implement the default behaviour then use #[derive(DefaultJson)] should only be used with From for JsonString i.e. when failure should be impossible so an expect is ok this is always true for serializable structs/enums standard boilerplate: impl From for JsonString {     fn from(v: MyStruct) -> Self {         default_to_json(v)     } }",N,[[["v"]],["jsonstring"]]],[5,"default_try_from_json","","if all you want to do is implement the default behaviour then use #[derive(DefaultJson)] standard boilerplate should include HolochainError as the Error: impl TryFrom for T {     type Error = HolochainError;     fn try_from(j: JsonString) -> HcResult {         default_try_from_json(j)     } }",N,[[["jsonstring"]],["result",["holochainerror"]]]],[6,"JsonResult","","",N,N],[8,"DefaultJson","","",N,N],[11,"null","","a null JSON value e.g. represents None when implementing From<Option>",39,[[],["jsonstring"]]],[11,"is_null","","",39,[[["self"]],["bool"]]],[11,"into_bytes","","achieves the same outcome as serde_json::to_vec()",39,[[["self"]],["vec",["u8"]]]],[0,"keys","holochain_core_types","",N,N],[3,"Key","holochain_core_types::keys","represents a single Key e.g. private + public keys would be two Key structs",N,N],[3,"Keys","","represents a set of Keys for an agent includes both public and private keys also includes the node id of the agent with these keys",N,N],[5,"test_key","","generates a new key suitable for testing",N,[[],["key"]]],[5,"test_public_key","","dummy public key",N,[[],["key"]]],[5,"test_private_key","","dummy private key",N,[[],["key"]]],[5,"test_node_id","","generates a new node id suitable for testing",N,[[],["string"]]],[5,"test_keys","","generates new id/pub/priv keys suitable for testing",N,[[],["keys"]]],[11,"new","","returns a new agent Key",40,[[],["key"]]],[11,"new","","returns a new set of agent Keys",41,[[["key"],["key"],["s"]],["keys"]]],[11,"public_key","","getter for the public key",41,[[["self"]],["key"]]],[11,"private_key","","getter for the private key",41,[[["self"]],["key"]]],[11,"node_id","","getter for the node id",41,[[["self"]],["string"]]],[0,"link","holochain_core_types","",N,N],[3,"Link","holochain_core_types::link","",N,N],[4,"LinkActionKind","","",N,N],[13,"ADD","","",42,N],[13,"DELETE","","",42,N],[0,"link_add","","",N,N],[3,"LinkAdd","holochain_core_types::link::link_add","",N,N],[11,"new","","",43,[[["address"],["address"],["str"]],["self"]]],[11,"action_kind","","",43,[[["self"]],["linkactionkind"]]],[11,"link","","",43,[[["self"]],["link"]]],[11,"from_link","","",43,[[["link"]],["self"]]],[0,"link_list","holochain_core_types::link","",N,N],[3,"LinkList","holochain_core_types::link::link_list","",N,N],[11,"new","","",44,N],[11,"links","","",44,[[["self"]],["vec"]]],[0,"link_remove","holochain_core_types::link","",N,N],[3,"LinkRemove","holochain_core_types::link::link_remove","",N,N],[11,"new","holochain_core_types::link","",45,[[["address"],["address"],["str"]],["self"]]],[11,"base","","",45,[[["self"]],["address"]]],[11,"target","","",45,[[["self"]],["address"]]],[11,"tag","","",45,[[["self"]],["string"]]],[0,"signature","holochain_core_types","",N,N],[3,"Signature","holochain_core_types::signature","",N,N],[5,"test_signature","","",N,[[],["signature"]]],[5,"test_signature_b","","",N,[[],["signature"]]],[5,"test_signature_c","","",N,[[],["signature"]]],[0,"time","holochain_core_types","",N,N],[3,"Iso8601","holochain_core_types::time","",N,N],[5,"test_iso_8601","","",N,[[],["iso8601"]]],[0,"validation","holochain_core_types","",N,N],[3,"ValidationPackage","holochain_core_types::validation","",N,N],[12,"chain_header","","",46,N],[12,"source_chain_entries","","",46,N],[12,"source_chain_headers","","",46,N],[12,"custom","","",46,N],[3,"ValidationData","","This structs carries information contextual for the process of validating an entry of link and is passed in to the according callbacks.",N,N],[12,"package","","The validation package is data from the entry's/link's source agent that is needed to determine the validity of a given entry. What specific data gets put into the validation package has to be defined throught the validation_package callbacks in the entry! and link! macros.",47,N],[12,"sources","","The list of authors that have signed this entry.",47,N],[12,"lifecycle","","In which lifecycle of the entry creation are we running this validation callback?",47,N],[12,"action","","Does the entry get committed, modified or deleted?",47,N],[4,"ValidationPackageDefinition","","",N,N],[13,"Entry","","",48,N],[13,"ChainEntries","","",48,N],[13,"ChainHeaders","","",48,N],[13,"ChainFull","","",48,N],[13,"Custom","","",48,N],[4,"EntryLifecycle","","",N,N],[13,"Chain","","",49,N],[13,"Dht","","",49,N],[13,"Meta","","",49,N],[4,"EntryAction","","",N,N],[13,"Commit","","",50,N],[13,"Modify","","",50,N],[13,"Delete","","",50,N],[4,"LinkAction","","",N,N],[13,"Commit","","",51,N],[13,"Delete","","",51,N],[11,"only_header","","",46,[[["chainheader"]],["validationpackage"]]],[11,"from","holochain_core_types::cas::content","",52,[[["t"]],["t"]]],[11,"into","","",52,[[["self"]],["u"]]],[11,"to_owned","","",52,[[["self"]],["t"]]],[11,"clone_into","","",52,N],[11,"try_from","","",52,[[["u"]],["result"]]],[11,"borrow","","",52,[[["self"]],["t"]]],[11,"get_type_id","","",52,[[["self"]],["typeid"]]],[11,"try_into","","",52,[[["self"]],["result"]]],[11,"borrow_mut","","",52,[[["self"]],["t"]]],[11,"equivalent","","",52,[[["self"],["k"]],["bool"]]],[11,"clone_box","","",52,N],[11,"from","","",53,[[["t"]],["t"]]],[11,"into","","",53,[[["self"]],["u"]]],[11,"to_owned","","",53,[[["self"]],["t"]]],[11,"clone_into","","",53,N],[11,"try_from","","",53,[[["u"]],["result"]]],[11,"borrow","","",53,[[["self"]],["t"]]],[11,"get_type_id","","",53,[[["self"]],["typeid"]]],[11,"try_into","","",53,[[["self"]],["result"]]],[11,"borrow_mut","","",53,[[["self"]],["t"]]],[11,"clone_box","","",53,N],[11,"from","","",1,[[["t"]],["t"]]],[11,"into","","",1,[[["self"]],["u"]]],[11,"try_from","","",1,[[["u"]],["result"]]],[11,"borrow","","",1,[[["self"]],["t"]]],[11,"get_type_id","","",1,[[["self"]],["typeid"]]],[11,"try_into","","",1,[[["self"]],["result"]]],[11,"borrow_mut","","",1,[[["self"]],["t"]]],[11,"from","holochain_core_types::cas::storage","",4,[[["t"]],["t"]]],[11,"into","","",4,[[["self"]],["u"]]],[11,"to_owned","","",4,[[["self"]],["t"]]],[11,"clone_into","","",4,N],[11,"try_from","","",4,[[["u"]],["result"]]],[11,"borrow","","",4,[[["self"]],["t"]]],[11,"get_type_id","","",4,[[["self"]],["typeid"]]],[11,"try_into","","",4,[[["self"]],["result"]]],[11,"borrow_mut","","",4,[[["self"]],["t"]]],[11,"clone_box","","",4,N],[11,"from","","",5,[[["t"]],["t"]]],[11,"into","","",5,[[["self"]],["u"]]],[11,"try_from","","",5,[[["u"]],["result"]]],[11,"borrow","","",5,[[["self"]],["t"]]],[11,"get_type_id","","",5,[[["self"]],["typeid"]]],[11,"try_into","","",5,[[["self"]],["result"]]],[11,"borrow_mut","","",5,[[["self"]],["t"]]],[11,"from","","",2,[[["t"]],["t"]]],[11,"into","","",2,[[["self"]],["u"]]],[11,"try_from","","",2,[[["u"]],["result"]]],[11,"borrow","","",2,[[["self"]],["t"]]],[11,"get_type_id","","",2,[[["self"]],["typeid"]]],[11,"try_into","","",2,[[["self"]],["result"]]],[11,"borrow_mut","","",2,[[["self"]],["t"]]],[11,"from","","",6,[[["t"]],["t"]]],[11,"into","","",6,[[["self"]],["u"]]],[11,"try_from","","",6,[[["u"]],["result"]]],[11,"borrow","","",6,[[["self"]],["t"]]],[11,"get_type_id","","",6,[[["self"]],["typeid"]]],[11,"try_into","","",6,[[["self"]],["result"]]],[11,"borrow_mut","","",6,[[["self"]],["t"]]],[11,"from","holochain_core_types::chain_header","",7,[[["t"]],["t"]]],[11,"into","","",7,[[["self"]],["u"]]],[11,"to_owned","","",7,[[["self"]],["t"]]],[11,"clone_into","","",7,N],[11,"try_from","","",7,[[["u"]],["result"]]],[11,"borrow","","",7,[[["self"]],["t"]]],[11,"get_type_id","","",7,[[["self"]],["typeid"]]],[11,"try_into","","",7,[[["self"]],["result"]]],[11,"borrow_mut","","",7,[[["self"]],["t"]]],[11,"clone_box","","",7,N],[11,"from","holochain_core_types::crud_status","",8,[[["t"]],["t"]]],[11,"into","","",8,[[["self"]],["u"]]],[11,"to_owned","","",8,[[["self"]],["t"]]],[11,"clone_into","","",8,N],[11,"try_from","","",8,[[["u"]],["result"]]],[11,"borrow","","",8,[[["self"]],["t"]]],[11,"get_type_id","","",8,[[["self"]],["typeid"]]],[11,"try_into","","",8,[[["self"]],["result"]]],[11,"borrow_mut","","",8,[[["self"]],["t"]]],[11,"equivalent","","",8,[[["self"],["k"]],["bool"]]],[11,"clone_box","","",8,N],[11,"from","holochain_core_types::eav","",10,[[["t"]],["t"]]],[11,"into","","",10,[[["self"]],["u"]]],[11,"to_owned","","",10,[[["self"]],["t"]]],[11,"clone_into","","",10,N],[11,"try_from","","",10,[[["u"]],["result"]]],[11,"borrow","","",10,[[["self"]],["t"]]],[11,"get_type_id","","",10,[[["self"]],["typeid"]]],[11,"try_into","","",10,[[["self"]],["result"]]],[11,"borrow_mut","","",10,[[["self"]],["t"]]],[11,"equivalent","","",10,[[["self"],["k"]],["bool"]]],[11,"clone_box","","",10,N],[11,"from","","",11,[[["t"]],["t"]]],[11,"into","","",11,[[["self"]],["u"]]],[11,"to_owned","","",11,[[["self"]],["t"]]],[11,"clone_into","","",11,N],[11,"try_from","","",11,[[["u"]],["result"]]],[11,"borrow","","",11,[[["self"]],["t"]]],[11,"get_type_id","","",11,[[["self"]],["typeid"]]],[11,"try_into","","",11,[[["self"]],["result"]]],[11,"borrow_mut","","",11,[[["self"]],["t"]]],[11,"clone_box","","",11,N],[11,"from","","",12,[[["t"]],["t"]]],[11,"into","","",12,[[["self"]],["u"]]],[11,"to_owned","","",12,[[["self"]],["t"]]],[11,"clone_into","","",12,N],[11,"try_from","","",12,[[["u"]],["result"]]],[11,"borrow","","",12,[[["self"]],["t"]]],[11,"get_type_id","","",12,[[["self"]],["typeid"]]],[11,"try_into","","",12,[[["self"]],["result"]]],[11,"borrow_mut","","",12,[[["self"]],["t"]]],[11,"clone_box","","",12,N],[11,"from","holochain_core_types::entry","",13,[[["t"]],["t"]]],[11,"into","","",13,[[["self"]],["u"]]],[11,"to_owned","","",13,[[["self"]],["t"]]],[11,"clone_into","","",13,N],[11,"try_from","","",13,[[["u"]],["result"]]],[11,"borrow","","",13,[[["self"]],["t"]]],[11,"get_type_id","","",13,[[["self"]],["typeid"]]],[11,"try_into","","",13,[[["self"]],["result"]]],[11,"borrow_mut","","",13,[[["self"]],["t"]]],[11,"clone_box","","",13,N],[11,"from","holochain_core_types::entry::entry_type","",54,[[["t"]],["t"]]],[11,"into","","",54,[[["self"]],["u"]]],[11,"to_owned","","",54,[[["self"]],["t"]]],[11,"clone_into","","",54,N],[11,"to_string","","",54,[[["self"]],["string"]]],[11,"try_from","","",54,[[["u"]],["result"]]],[11,"borrow","","",54,[[["self"]],["t"]]],[11,"get_type_id","","",54,[[["self"]],["typeid"]]],[11,"try_into","","",54,[[["self"]],["result"]]],[11,"borrow_mut","","",54,[[["self"]],["t"]]],[11,"equivalent","","",54,[[["self"],["k"]],["bool"]]],[11,"clone_box","","",54,N],[11,"from","","",14,[[["t"]],["t"]]],[11,"into","","",14,[[["self"]],["u"]]],[11,"to_owned","","",14,[[["self"]],["t"]]],[11,"clone_into","","",14,N],[11,"to_string","","",14,[[["self"]],["string"]]],[11,"try_from","","",14,[[["u"]],["result"]]],[11,"borrow","","",14,[[["self"]],["t"]]],[11,"get_type_id","","",14,[[["self"]],["typeid"]]],[11,"try_into","","",14,[[["self"]],["result"]]],[11,"borrow_mut","","",14,[[["self"]],["t"]]],[11,"equivalent","","",14,[[["self"],["k"]],["bool"]]],[11,"clone_box","","",14,N],[11,"from","holochain_core_types::error","",15,[[["t"]],["t"]]],[11,"into","","",15,[[["self"]],["u"]]],[11,"to_owned","","",15,[[["self"]],["t"]]],[11,"clone_into","","",15,N],[11,"to_string","","",15,[[["self"]],["string"]]],[11,"try_from","","",15,[[["u"]],["result"]]],[11,"borrow","","",15,[[["self"]],["t"]]],[11,"get_type_id","","",15,[[["self"]],["typeid"]]],[11,"try_into","","",15,[[["self"]],["result"]]],[11,"borrow_mut","","",15,[[["self"]],["t"]]],[11,"equivalent","","",15,[[["self"],["k"]],["bool"]]],[11,"clone_box","","",15,N],[11,"from","","",16,[[["t"]],["t"]]],[11,"into","","",16,[[["self"]],["u"]]],[11,"to_owned","","",16,[[["self"]],["t"]]],[11,"clone_into","","",16,N],[11,"to_string","","",16,[[["self"]],["string"]]],[11,"try_from","","",16,[[["u"]],["result"]]],[11,"borrow","","",16,[[["self"]],["t"]]],[11,"get_type_id","","",16,[[["self"]],["typeid"]]],[11,"try_into","","",16,[[["self"]],["result"]]],[11,"borrow_mut","","",16,[[["self"]],["t"]]],[11,"clone_box","","",16,N],[11,"from","","",17,[[["t"]],["t"]]],[11,"into","","",17,[[["self"]],["u"]]],[11,"to_owned","","",17,[[["self"]],["t"]]],[11,"clone_into","","",17,N],[11,"to_string","","",17,[[["self"]],["string"]]],[11,"try_from","","",17,[[["u"]],["result"]]],[11,"borrow","","",17,[[["self"]],["t"]]],[11,"get_type_id","","",17,[[["self"]],["typeid"]]],[11,"try_into","","",17,[[["self"]],["result"]]],[11,"borrow_mut","","",17,[[["self"]],["t"]]],[11,"equivalent","","",17,[[["self"],["k"]],["bool"]]],[11,"clone_box","","",17,N],[11,"from","holochain_core_types::error::error","",18,[[["t"]],["t"]]],[11,"into","","",18,[[["self"]],["u"]]],[11,"to_owned","","",18,[[["self"]],["t"]]],[11,"clone_into","","",18,N],[11,"to_string","","",18,[[["self"]],["string"]]],[11,"try_from","","",18,[[["u"]],["result"]]],[11,"borrow","","",18,[[["self"]],["t"]]],[11,"get_type_id","","",18,[[["self"]],["typeid"]]],[11,"try_into","","",18,[[["self"]],["result"]]],[11,"borrow_mut","","",18,[[["self"]],["t"]]],[11,"equivalent","","",18,[[["self"],["k"]],["bool"]]],[11,"clone_box","","",18,N],[11,"from","","",19,[[["t"]],["t"]]],[11,"into","","",19,[[["self"]],["u"]]],[11,"try_from","","",19,[[["u"]],["result"]]],[11,"borrow","","",19,[[["self"]],["t"]]],[11,"get_type_id","","",19,[[["self"]],["typeid"]]],[11,"try_into","","",19,[[["self"]],["result"]]],[11,"borrow_mut","","",19,[[["self"]],["t"]]],[11,"from","","",20,[[["t"]],["t"]]],[11,"into","","",20,[[["self"]],["u"]]],[11,"to_owned","","",20,[[["self"]],["t"]]],[11,"clone_into","","",20,N],[11,"to_string","","",20,[[["self"]],["string"]]],[11,"try_from","","",20,[[["u"]],["result"]]],[11,"borrow","","",20,[[["self"]],["t"]]],[11,"get_type_id","","",20,[[["self"]],["typeid"]]],[11,"try_into","","",20,[[["self"]],["result"]]],[11,"borrow_mut","","",20,[[["self"]],["t"]]],[11,"equivalent","","",20,[[["self"],["k"]],["bool"]]],[11,"clone_box","","",20,N],[11,"from","holochain_core_types::agent","",22,[[["t"]],["t"]]],[11,"into","","",22,[[["self"]],["u"]]],[11,"to_owned","","",22,[[["self"]],["t"]]],[11,"clone_into","","",22,N],[11,"try_from","","",22,[[["u"]],["result"]]],[11,"borrow","","",22,[[["self"]],["t"]]],[11,"get_type_id","","",22,[[["self"]],["typeid"]]],[11,"try_into","","",22,[[["self"]],["result"]]],[11,"borrow_mut","","",22,[[["self"]],["t"]]],[11,"clone_box","","",22,N],[11,"from","","",21,[[["t"]],["t"]]],[11,"into","","",21,[[["self"]],["u"]]],[11,"to_owned","","",21,[[["self"]],["t"]]],[11,"clone_into","","",21,N],[11,"try_from","","",21,[[["u"]],["result"]]],[11,"borrow","","",21,[[["self"]],["t"]]],[11,"get_type_id","","",21,[[["self"]],["typeid"]]],[11,"try_into","","",21,[[["self"]],["result"]]],[11,"borrow_mut","","",21,[[["self"]],["t"]]],[11,"clone_box","","",21,N],[11,"from","holochain_core_types::chain_migrate","",55,[[["t"]],["t"]]],[11,"into","","",55,[[["self"]],["u"]]],[11,"to_owned","","",55,[[["self"]],["t"]]],[11,"clone_into","","",55,N],[11,"try_from","","",55,[[["u"]],["result"]]],[11,"borrow","","",55,[[["self"]],["t"]]],[11,"get_type_id","","",55,[[["self"]],["typeid"]]],[11,"try_into","","",55,[[["self"]],["result"]]],[11,"borrow_mut","","",55,[[["self"]],["t"]]],[11,"clone_box","","",55,N],[11,"from","holochain_core_types::delete","",56,[[["t"]],["t"]]],[11,"into","","",56,[[["self"]],["u"]]],[11,"to_owned","","",56,[[["self"]],["t"]]],[11,"clone_into","","",56,N],[11,"try_from","","",56,[[["u"]],["result"]]],[11,"borrow","","",56,[[["self"]],["t"]]],[11,"get_type_id","","",56,[[["self"]],["typeid"]]],[11,"try_into","","",56,[[["self"]],["result"]]],[11,"borrow_mut","","",56,[[["self"]],["t"]]],[11,"clone_box","","",56,N],[11,"from","holochain_core_types::dna","",23,[[["t"]],["t"]]],[11,"into","","",23,[[["self"]],["u"]]],[11,"to_owned","","",23,[[["self"]],["t"]]],[11,"clone_into","","",23,N],[11,"try_from","","",23,[[["u"]],["result"]]],[11,"borrow","","",23,[[["self"]],["t"]]],[11,"get_type_id","","",23,[[["self"]],["typeid"]]],[11,"try_into","","",23,[[["self"]],["result"]]],[11,"borrow_mut","","",23,[[["self"]],["t"]]],[11,"clone_box","","",23,N],[11,"from","holochain_core_types::dna::wasm","",24,[[["t"]],["t"]]],[11,"into","","",24,[[["self"]],["u"]]],[11,"to_owned","","",24,[[["self"]],["t"]]],[11,"clone_into","","",24,N],[11,"try_from","","",24,[[["u"]],["result"]]],[11,"borrow","","",24,[[["self"]],["t"]]],[11,"get_type_id","","",24,[[["self"]],["typeid"]]],[11,"try_into","","",24,[[["self"]],["result"]]],[11,"borrow_mut","","",24,[[["self"]],["t"]]],[11,"clone_box","","",24,N],[11,"from","holochain_core_types::dna::zome","",25,[[["t"]],["t"]]],[11,"into","","",25,[[["self"]],["u"]]],[11,"to_owned","","",25,[[["self"]],["t"]]],[11,"clone_into","","",25,N],[11,"try_from","","",25,[[["u"]],["result"]]],[11,"borrow","","",25,[[["self"]],["t"]]],[11,"get_type_id","","",25,[[["self"]],["typeid"]]],[11,"try_into","","",25,[[["self"]],["result"]]],[11,"borrow_mut","","",25,[[["self"]],["t"]]],[11,"clone_box","","",25,N],[11,"from","","",26,[[["t"]],["t"]]],[11,"into","","",26,[[["self"]],["u"]]],[11,"to_owned","","",26,[[["self"]],["t"]]],[11,"clone_into","","",26,N],[11,"try_from","","",26,[[["u"]],["result"]]],[11,"borrow","","",26,[[["self"]],["t"]]],[11,"get_type_id","","",26,[[["self"]],["typeid"]]],[11,"try_into","","",26,[[["self"]],["result"]]],[11,"borrow_mut","","",26,[[["self"]],["t"]]],[11,"equivalent","","",26,[[["self"],["k"]],["bool"]]],[11,"clone_box","","",26,N],[11,"from","","",27,[[["t"]],["t"]]],[11,"into","","",27,[[["self"]],["u"]]],[11,"to_owned","","",27,[[["self"]],["t"]]],[11,"clone_into","","",27,N],[11,"try_from","","",27,[[["u"]],["result"]]],[11,"borrow","","",27,[[["self"]],["t"]]],[11,"get_type_id","","",27,[[["self"]],["typeid"]]],[11,"try_into","","",27,[[["self"]],["result"]]],[11,"borrow_mut","","",27,[[["self"]],["t"]]],[11,"clone_box","","",27,N],[11,"from","holochain_core_types::dna::zome::capabilities","",28,[[["t"]],["t"]]],[11,"into","","",28,[[["self"]],["u"]]],[11,"to_owned","","",28,[[["self"]],["t"]]],[11,"clone_into","","",28,N],[11,"try_from","","",28,[[["u"]],["result"]]],[11,"borrow","","",28,[[["self"]],["t"]]],[11,"get_type_id","","",28,[[["self"]],["typeid"]]],[11,"try_into","","",28,[[["self"]],["result"]]],[11,"borrow_mut","","",28,[[["self"]],["t"]]],[11,"clone_box","","",28,N],[11,"from","","",29,[[["t"]],["t"]]],[11,"into","","",29,[[["self"]],["u"]]],[11,"to_owned","","",29,[[["self"]],["t"]]],[11,"clone_into","","",29,N],[11,"try_from","","",29,[[["u"]],["result"]]],[11,"borrow","","",29,[[["self"]],["t"]]],[11,"get_type_id","","",29,[[["self"]],["typeid"]]],[11,"try_into","","",29,[[["self"]],["result"]]],[11,"borrow_mut","","",29,[[["self"]],["t"]]],[11,"clone_box","","",29,N],[11,"from","","",30,[[["t"]],["t"]]],[11,"into","","",30,[[["self"]],["u"]]],[11,"to_owned","","",30,[[["self"]],["t"]]],[11,"clone_into","","",30,N],[11,"try_from","","",30,[[["u"]],["result"]]],[11,"borrow","","",30,[[["self"]],["t"]]],[11,"get_type_id","","",30,[[["self"]],["typeid"]]],[11,"try_into","","",30,[[["self"]],["result"]]],[11,"borrow_mut","","",30,[[["self"]],["t"]]],[11,"clone_box","","",30,N],[11,"from","","",31,[[["t"]],["t"]]],[11,"into","","",31,[[["self"]],["u"]]],[11,"to_owned","","",31,[[["self"]],["t"]]],[11,"clone_into","","",31,N],[11,"try_from","","",31,[[["u"]],["result"]]],[11,"borrow","","",31,[[["self"]],["t"]]],[11,"get_type_id","","",31,[[["self"]],["typeid"]]],[11,"try_into","","",31,[[["self"]],["result"]]],[11,"borrow_mut","","",31,[[["self"]],["t"]]],[11,"clone_box","","",31,N],[11,"from","","",32,[[["t"]],["t"]]],[11,"into","","",32,[[["self"]],["u"]]],[11,"try_from","","",32,[[["u"]],["result"]]],[11,"borrow","","",32,[[["self"]],["t"]]],[11,"get_type_id","","",32,[[["self"]],["typeid"]]],[11,"try_into","","",32,[[["self"]],["result"]]],[11,"borrow_mut","","",32,[[["self"]],["t"]]],[11,"from","","",33,[[["t"]],["t"]]],[11,"into","","",33,[[["self"]],["u"]]],[11,"to_owned","","",33,[[["self"]],["t"]]],[11,"clone_into","","",33,N],[11,"try_from","","",33,[[["u"]],["result"]]],[11,"borrow","","",33,[[["self"]],["t"]]],[11,"get_type_id","","",33,[[["self"]],["typeid"]]],[11,"try_into","","",33,[[["self"]],["result"]]],[11,"borrow_mut","","",33,[[["self"]],["t"]]],[11,"clone_box","","",33,N],[11,"from","holochain_core_types::dna::zome::entry_types","",34,[[["t"]],["t"]]],[11,"into","","",34,[[["self"]],["u"]]],[11,"to_owned","","",34,[[["self"]],["t"]]],[11,"clone_into","","",34,N],[11,"try_from","","",34,[[["u"]],["result"]]],[11,"borrow","","",34,[[["self"]],["t"]]],[11,"get_type_id","","",34,[[["self"]],["typeid"]]],[11,"try_into","","",34,[[["self"]],["result"]]],[11,"borrow_mut","","",34,[[["self"]],["t"]]],[11,"clone_box","","",34,N],[11,"from","","",35,[[["t"]],["t"]]],[11,"into","","",35,[[["self"]],["u"]]],[11,"to_owned","","",35,[[["self"]],["t"]]],[11,"clone_into","","",35,N],[11,"try_from","","",35,[[["u"]],["result"]]],[11,"borrow","","",35,[[["self"]],["t"]]],[11,"get_type_id","","",35,[[["self"]],["typeid"]]],[11,"try_into","","",35,[[["self"]],["result"]]],[11,"borrow_mut","","",35,[[["self"]],["t"]]],[11,"clone_box","","",35,N],[11,"from","","",36,[[["t"]],["t"]]],[11,"into","","",36,[[["self"]],["u"]]],[11,"to_owned","","",36,[[["self"]],["t"]]],[11,"clone_into","","",36,N],[11,"try_from","","",36,[[["u"]],["result"]]],[11,"borrow","","",36,[[["self"]],["t"]]],[11,"get_type_id","","",36,[[["self"]],["typeid"]]],[11,"try_into","","",36,[[["self"]],["result"]]],[11,"borrow_mut","","",36,[[["self"]],["t"]]],[11,"clone_box","","",36,N],[11,"from","","",37,[[["t"]],["t"]]],[11,"into","","",37,[[["self"]],["u"]]],[11,"to_owned","","",37,[[["self"]],["t"]]],[11,"clone_into","","",37,N],[11,"try_from","","",37,[[["u"]],["result"]]],[11,"borrow","","",37,[[["self"]],["t"]]],[11,"get_type_id","","",37,[[["self"]],["typeid"]]],[11,"try_into","","",37,[[["self"]],["result"]]],[11,"borrow_mut","","",37,[[["self"]],["t"]]],[11,"clone_box","","",37,N],[11,"from","holochain_core_types::hash","",38,[[["t"]],["t"]]],[11,"into","","",38,[[["self"]],["u"]]],[11,"to_owned","","",38,[[["self"]],["t"]]],[11,"clone_into","","",38,N],[11,"to_string","","",38,[[["self"]],["string"]]],[11,"try_from","","",38,[[["u"]],["result"]]],[11,"borrow","","",38,[[["self"]],["t"]]],[11,"get_type_id","","",38,[[["self"]],["typeid"]]],[11,"try_into","","",38,[[["self"]],["result"]]],[11,"borrow_mut","","",38,[[["self"]],["t"]]],[11,"equivalent","","",38,[[["self"],["k"]],["bool"]]],[11,"clone_box","","",38,N],[11,"from","holochain_core_types::json","",39,[[["t"]],["t"]]],[11,"into","","",39,[[["self"]],["u"]]],[11,"to_owned","","",39,[[["self"]],["t"]]],[11,"clone_into","","",39,N],[11,"to_string","","",39,[[["self"]],["string"]]],[11,"try_from","","",39,[[["u"]],["result"]]],[11,"borrow","","",39,[[["self"]],["t"]]],[11,"get_type_id","","",39,[[["self"]],["typeid"]]],[11,"try_into","","",39,[[["self"]],["result"]]],[11,"borrow_mut","","",39,[[["self"]],["t"]]],[11,"equivalent","","",39,[[["self"],["k"]],["bool"]]],[11,"clone_box","","",39,N],[11,"from","","",57,[[["t"]],["t"]]],[11,"into","","",57,[[["self"]],["u"]]],[11,"to_owned","","",57,[[["self"]],["t"]]],[11,"clone_into","","",57,N],[11,"try_from","","",57,[[["u"]],["result"]]],[11,"borrow","","",57,[[["self"]],["t"]]],[11,"get_type_id","","",57,[[["self"]],["typeid"]]],[11,"try_into","","",57,[[["self"]],["result"]]],[11,"borrow_mut","","",57,[[["self"]],["t"]]],[11,"clone_box","","",57,N],[11,"from","holochain_core_types::keys","",40,[[["t"]],["t"]]],[11,"into","","",40,[[["self"]],["u"]]],[11,"to_owned","","",40,[[["self"]],["t"]]],[11,"clone_into","","",40,N],[11,"try_from","","",40,[[["u"]],["result"]]],[11,"borrow","","",40,[[["self"]],["t"]]],[11,"get_type_id","","",40,[[["self"]],["typeid"]]],[11,"try_into","","",40,[[["self"]],["result"]]],[11,"borrow_mut","","",40,[[["self"]],["t"]]],[11,"clone_box","","",40,N],[11,"from","","",41,[[["t"]],["t"]]],[11,"into","","",41,[[["self"]],["u"]]],[11,"to_owned","","",41,[[["self"]],["t"]]],[11,"clone_into","","",41,N],[11,"try_from","","",41,[[["u"]],["result"]]],[11,"borrow","","",41,[[["self"]],["t"]]],[11,"get_type_id","","",41,[[["self"]],["typeid"]]],[11,"try_into","","",41,[[["self"]],["result"]]],[11,"borrow_mut","","",41,[[["self"]],["t"]]],[11,"clone_box","","",41,N],[11,"from","holochain_core_types::link","",45,[[["t"]],["t"]]],[11,"into","","",45,[[["self"]],["u"]]],[11,"to_owned","","",45,[[["self"]],["t"]]],[11,"clone_into","","",45,N],[11,"try_from","","",45,[[["u"]],["result"]]],[11,"borrow","","",45,[[["self"]],["t"]]],[11,"get_type_id","","",45,[[["self"]],["typeid"]]],[11,"try_into","","",45,[[["self"]],["result"]]],[11,"borrow_mut","","",45,[[["self"]],["t"]]],[11,"equivalent","","",45,[[["self"],["k"]],["bool"]]],[11,"clone_box","","",45,N],[11,"from","","",42,[[["t"]],["t"]]],[11,"into","","",42,[[["self"]],["u"]]],[11,"to_owned","","",42,[[["self"]],["t"]]],[11,"clone_into","","",42,N],[11,"try_from","","",42,[[["u"]],["result"]]],[11,"borrow","","",42,[[["self"]],["t"]]],[11,"get_type_id","","",42,[[["self"]],["typeid"]]],[11,"try_into","","",42,[[["self"]],["result"]]],[11,"borrow_mut","","",42,[[["self"]],["t"]]],[11,"clone_box","","",42,N],[11,"from","holochain_core_types::link::link_add","",43,[[["t"]],["t"]]],[11,"into","","",43,[[["self"]],["u"]]],[11,"to_owned","","",43,[[["self"]],["t"]]],[11,"clone_into","","",43,N],[11,"try_from","","",43,[[["u"]],["result"]]],[11,"borrow","","",43,[[["self"]],["t"]]],[11,"get_type_id","","",43,[[["self"]],["typeid"]]],[11,"try_into","","",43,[[["self"]],["result"]]],[11,"borrow_mut","","",43,[[["self"]],["t"]]],[11,"clone_box","","",43,N],[11,"from","holochain_core_types::link::link_list","",44,[[["t"]],["t"]]],[11,"into","","",44,[[["self"]],["u"]]],[11,"to_owned","","",44,[[["self"]],["t"]]],[11,"clone_into","","",44,N],[11,"try_from","","",44,[[["u"]],["result"]]],[11,"borrow","","",44,[[["self"]],["t"]]],[11,"get_type_id","","",44,[[["self"]],["typeid"]]],[11,"try_into","","",44,[[["self"]],["result"]]],[11,"borrow_mut","","",44,[[["self"]],["t"]]],[11,"clone_box","","",44,N],[11,"from","holochain_core_types::link::link_remove","",58,[[["t"]],["t"]]],[11,"into","","",58,[[["self"]],["u"]]],[11,"to_owned","","",58,[[["self"]],["t"]]],[11,"clone_into","","",58,N],[11,"try_from","","",58,[[["u"]],["result"]]],[11,"borrow","","",58,[[["self"]],["t"]]],[11,"get_type_id","","",58,[[["self"]],["typeid"]]],[11,"try_into","","",58,[[["self"]],["result"]]],[11,"borrow_mut","","",58,[[["self"]],["t"]]],[11,"clone_box","","",58,N],[11,"from","holochain_core_types::signature","",59,[[["t"]],["t"]]],[11,"into","","",59,[[["self"]],["u"]]],[11,"to_owned","","",59,[[["self"]],["t"]]],[11,"clone_into","","",59,N],[11,"try_from","","",59,[[["u"]],["result"]]],[11,"borrow","","",59,[[["self"]],["t"]]],[11,"get_type_id","","",59,[[["self"]],["typeid"]]],[11,"try_into","","",59,[[["self"]],["result"]]],[11,"borrow_mut","","",59,[[["self"]],["t"]]],[11,"clone_box","","",59,N],[11,"from","holochain_core_types::time","",60,[[["t"]],["t"]]],[11,"into","","",60,[[["self"]],["u"]]],[11,"to_owned","","",60,[[["self"]],["t"]]],[11,"clone_into","","",60,N],[11,"try_from","","",60,[[["u"]],["result"]]],[11,"borrow","","",60,[[["self"]],["t"]]],[11,"get_type_id","","",60,[[["self"]],["typeid"]]],[11,"try_into","","",60,[[["self"]],["result"]]],[11,"borrow_mut","","",60,[[["self"]],["t"]]],[11,"clone_box","","",60,N],[11,"from","holochain_core_types::validation","",46,[[["t"]],["t"]]],[11,"into","","",46,[[["self"]],["u"]]],[11,"to_owned","","",46,[[["self"]],["t"]]],[11,"clone_into","","",46,N],[11,"try_from","","",46,[[["u"]],["result"]]],[11,"borrow","","",46,[[["self"]],["t"]]],[11,"get_type_id","","",46,[[["self"]],["typeid"]]],[11,"try_into","","",46,[[["self"]],["result"]]],[11,"borrow_mut","","",46,[[["self"]],["t"]]],[11,"clone_box","","",46,N],[11,"from","","",47,[[["t"]],["t"]]],[11,"into","","",47,[[["self"]],["u"]]],[11,"to_owned","","",47,[[["self"]],["t"]]],[11,"clone_into","","",47,N],[11,"try_from","","",47,[[["u"]],["result"]]],[11,"borrow","","",47,[[["self"]],["t"]]],[11,"get_type_id","","",47,[[["self"]],["typeid"]]],[11,"try_into","","",47,[[["self"]],["result"]]],[11,"borrow_mut","","",47,[[["self"]],["t"]]],[11,"clone_box","","",47,N],[11,"from","","",48,[[["t"]],["t"]]],[11,"into","","",48,[[["self"]],["u"]]],[11,"to_owned","","",48,[[["self"]],["t"]]],[11,"clone_into","","",48,N],[11,"try_from","","",48,[[["u"]],["result"]]],[11,"borrow","","",48,[[["self"]],["t"]]],[11,"get_type_id","","",48,[[["self"]],["typeid"]]],[11,"try_into","","",48,[[["self"]],["result"]]],[11,"borrow_mut","","",48,[[["self"]],["t"]]],[11,"clone_box","","",48,N],[11,"from","","",49,[[["t"]],["t"]]],[11,"into","","",49,[[["self"]],["u"]]],[11,"to_owned","","",49,[[["self"]],["t"]]],[11,"clone_into","","",49,N],[11,"try_from","","",49,[[["u"]],["result"]]],[11,"borrow","","",49,[[["self"]],["t"]]],[11,"get_type_id","","",49,[[["self"]],["typeid"]]],[11,"try_into","","",49,[[["self"]],["result"]]],[11,"borrow_mut","","",49,[[["self"]],["t"]]],[11,"clone_box","","",49,N],[11,"from","","",50,[[["t"]],["t"]]],[11,"into","","",50,[[["self"]],["u"]]],[11,"to_owned","","",50,[[["self"]],["t"]]],[11,"clone_into","","",50,N],[11,"try_from","","",50,[[["u"]],["result"]]],[11,"borrow","","",50,[[["self"]],["t"]]],[11,"get_type_id","","",50,[[["self"]],["typeid"]]],[11,"try_into","","",50,[[["self"]],["result"]]],[11,"borrow_mut","","",50,[[["self"]],["t"]]],[11,"clone_box","","",50,N],[11,"from","","",51,[[["t"]],["t"]]],[11,"into","","",51,[[["self"]],["u"]]],[11,"to_owned","","",51,[[["self"]],["t"]]],[11,"clone_into","","",51,N],[11,"try_from","","",51,[[["u"]],["result"]]],[11,"borrow","","",51,[[["self"]],["t"]]],[11,"get_type_id","","",51,[[["self"]],["typeid"]]],[11,"try_into","","",51,[[["self"]],["result"]]],[11,"borrow_mut","","",51,[[["self"]],["t"]]],[11,"clone_box","","",51,N],[11,"content","holochain_core_types","",61,[[["self"]],["content"]]],[11,"try_from_content","","",61,[[["content"]],["result",["holochainerror"]]]],[11,"content","holochain_core_types::cas::content","",52,[[["self"]],["content"]]],[11,"try_from_content","","",52,[[["content"]],["result",["holochainerror"]]]],[11,"address","","",53,[[["self"]],["address"]]],[11,"content","","",53,[[["self"]],["content"]]],[11,"try_from_content","","",53,[[["content"]],["result",["holochainerror"]]]],[11,"content","holochain_core_types::chain_header","",7,[[["self"]],["content"]]],[11,"try_from_content","","",7,[[["content"]],["result",["holochainerror"]]]],[11,"content","holochain_core_types::crud_status","",8,[[["self"]],["content"]]],[11,"try_from_content","","",8,[[["content"]],["result",["holochainerror"]]]],[11,"content","holochain_core_types::eav","",10,[[["self"]],["content"]]],[11,"try_from_content","","",10,[[["content"]],["result",["holochainerror"]]]],[11,"content","holochain_core_types::entry","",13,[[["self"]],["content"]]],[11,"try_from_content","","",13,[[["content"]],["hcresult",["entry"]]]],[11,"address","holochain_core_types::agent","for an Agent, the address is their public base64url encoded itentity string",21,[[["self"]],["address"]]],[11,"content","","get the entry content",21,[[["self"]],["content"]]],[11,"try_from_content","","",21,[[["content"]],["hcresult"]]],[11,"add","holochain_core_types::cas::storage","",4,[[["self"],["addressablecontent"]],["result",["holochainerror"]]]],[11,"contains","","",4,[[["self"],["address"]],["result",["bool","holochainerror"]]]],[11,"fetch","","",4,[[["self"],["address"]],["result",["option","holochainerror"]]]],[11,"get_id","","",4,[[["self"]],["uuid"]]],[11,"add_eav","holochain_core_types::eav","",12,[[["self"],["entityattributevalue"]],["hcresult"]]],[11,"fetch_eav","","",12,[[["self"],["option",["entity"]],["option",["attribute"]],["option",["value"]]],["result",["hashset","holochainerror"]]]],[11,"cmp","holochain_core_types::crud_status","",8,[[["self"],["crudstatus"]],["ordering"]]],[11,"cmp","holochain_core_types::entry::entry_type","",54,[[["self"],["appentrytype"]],["ordering"]]],[11,"cmp","","",14,[[["self"],["entrytype"]],["ordering"]]],[11,"cmp","holochain_core_types::hash","",38,[[["self"],["hashstring"]],["ordering"]]],[11,"eq","holochain_core_types::cas::content","",52,[[["self"],["exampleaddressablecontent"]],["bool"]]],[11,"ne","","",52,[[["self"],["exampleaddressablecontent"]],["bool"]]],[11,"eq","","",53,[[["self"],["otherexampleaddressablecontent"]],["bool"]]],[11,"ne","","",53,[[["self"],["otherexampleaddressablecontent"]],["bool"]]],[11,"eq","holochain_core_types::cas::storage","",3,[[["self"],["contentaddressablestorage"]],["bool"]]],[11,"eq","holochain_core_types::chain_header","",7,[[["self"],["chainheader"]],["bool"]]],[11,"eq","holochain_core_types::crud_status","",8,[[["self"],["crudstatus"]],["bool"]]],[11,"ne","","",8,[[["self"],["crudstatus"]],["bool"]]],[11,"eq","holochain_core_types::eav","",10,[[["self"],["entityattributevalue"]],["bool"]]],[11,"ne","","",10,[[["self"],["entityattributevalue"]],["bool"]]],[11,"eq","","",9,[[["self"],["entityattributevaluestorage"]],["bool"]]],[11,"eq","holochain_core_types::entry::entry_type","",54,[[["self"],["appentrytype"]],["bool"]]],[11,"ne","","",54,[[["self"],["appentrytype"]],["bool"]]],[11,"eq","","",14,[[["self"],["entrytype"]],["bool"]]],[11,"ne","","",14,[[["self"],["entrytype"]],["bool"]]],[11,"eq","holochain_core_types::entry","",13,[[["self"],["entry"]],["bool"]]],[11,"eq","holochain_core_types::error","",15,[[["self"],["dnaerror"]],["bool"]]],[11,"ne","","",15,[[["self"],["dnaerror"]],["bool"]]],[11,"eq","holochain_core_types::error::error","",18,[[["self"],["coreerror"]],["bool"]]],[11,"ne","","",18,[[["self"],["coreerror"]],["bool"]]],[11,"eq","","",20,[[["self"],["holochainerror"]],["bool"]]],[11,"ne","","",20,[[["self"],["holochainerror"]],["bool"]]],[11,"eq","holochain_core_types::error","",16,[[["self"],["ribosomereturncode"]],["bool"]]],[11,"ne","","",16,[[["self"],["ribosomereturncode"]],["bool"]]],[11,"eq","","",17,[[["self"],["ribosomeerrorcode"]],["bool"]]],[11,"eq","holochain_core_types::agent","",21,[[["self"],["agentid"]],["bool"]]],[11,"ne","","",21,[[["self"],["agentid"]],["bool"]]],[11,"eq","holochain_core_types::dna::wasm","",24,[[["self"],["dnawasm"]],["bool"]]],[11,"ne","","",24,[[["self"],["dnawasm"]],["bool"]]],[11,"eq","holochain_core_types::dna::zome::capabilities","",32,[[["self"],["reservedcapabilitynames"]],["bool"]]],[11,"eq","","",33,[[["self"],["membrane"]],["bool"]]],[11,"eq","","",28,[[["self"],["capabilitytype"]],["bool"]]],[11,"ne","","",28,[[["self"],["capabilitytype"]],["bool"]]],[11,"eq","","",29,[[["self"],["fnparameter"]],["bool"]]],[11,"ne","","",29,[[["self"],["fnparameter"]],["bool"]]],[11,"eq","","",30,[[["self"],["fndeclaration"]],["bool"]]],[11,"ne","","",30,[[["self"],["fndeclaration"]],["bool"]]],[11,"eq","","",31,[[["self"],["capability"]],["bool"]]],[11,"ne","","",31,[[["self"],["capability"]],["bool"]]],[11,"eq","holochain_core_types::dna::zome::entry_types","",37,[[["self"],["sharing"]],["bool"]]],[11,"eq","","",34,[[["self"],["linksto"]],["bool"]]],[11,"ne","","",34,[[["self"],["linksto"]],["bool"]]],[11,"eq","","",35,[[["self"],["linkedfrom"]],["bool"]]],[11,"ne","","",35,[[["self"],["linkedfrom"]],["bool"]]],[11,"eq","","",36,[[["self"],["entrytypedef"]],["bool"]]],[11,"ne","","",36,[[["self"],["entrytypedef"]],["bool"]]],[11,"eq","holochain_core_types::dna::zome","",27,[[["self"],["errorhandling"]],["bool"]]],[11,"eq","","",25,[[["self"],["config"]],["bool"]]],[11,"ne","","",25,[[["self"],["config"]],["bool"]]],[11,"eq","","",26,[[["self"],["zome"]],["bool"]]],[11,"ne","","",26,[[["self"],["zome"]],["bool"]]],[11,"eq","holochain_core_types::dna","",23,[[["self"],["dna"]],["bool"]]],[11,"eq","holochain_core_types::hash","",38,[[["self"],["hashstring"]],["bool"]]],[11,"ne","","",38,[[["self"],["hashstring"]],["bool"]]],[11,"eq","holochain_core_types::json","",39,[[["self"],["jsonstring"]],["bool"]]],[11,"ne","","",39,[[["self"],["jsonstring"]],["bool"]]],[11,"eq","","",57,[[["self"],["rawstring"]],["bool"]]],[11,"ne","","",57,[[["self"],["rawstring"]],["bool"]]],[11,"eq","holochain_core_types::keys","",40,[[["self"],["key"]],["bool"]]],[11,"eq","","",41,[[["self"],["keys"]],["bool"]]],[11,"ne","","",41,[[["self"],["keys"]],["bool"]]],[11,"eq","holochain_core_types::link::link_add","",43,[[["self"],["linkadd"]],["bool"]]],[11,"ne","","",43,[[["self"],["linkadd"]],["bool"]]],[11,"eq","holochain_core_types::link::link_list","",44,[[["self"],["linklist"]],["bool"]]],[11,"ne","","",44,[[["self"],["linklist"]],["bool"]]],[11,"eq","holochain_core_types::link","",45,[[["self"],["link"]],["bool"]]],[11,"ne","","",45,[[["self"],["link"]],["bool"]]],[11,"eq","","",42,[[["self"],["linkactionkind"]],["bool"]]],[11,"eq","holochain_core_types::signature","",59,[[["self"],["signature"]],["bool"]]],[11,"ne","","",59,[[["self"],["signature"]],["bool"]]],[11,"eq","holochain_core_types::time","",60,[[["self"],["iso8601"]],["bool"]]],[11,"ne","","",60,[[["self"],["iso8601"]],["bool"]]],[11,"eq","holochain_core_types::validation","",46,[[["self"],["validationpackage"]],["bool"]]],[11,"ne","","",46,[[["self"],["validationpackage"]],["bool"]]],[11,"eq","","",48,[[["self"],["validationpackagedefinition"]],["bool"]]],[11,"ne","","",48,[[["self"],["validationpackagedefinition"]],["bool"]]],[11,"from","holochain_core_types::json","",39,[[["chainheader"]],["jsonstring"]]],[11,"from","","",39,[[["chainheader"]],["jsonstring"]]],[11,"from","","",39,[[["crudstatus"]],["jsonstring"]]],[11,"from","","",39,[[["crudstatus"]],["jsonstring"]]],[11,"from","holochain_core_types::crud_status","",8,[[["str"]],["crudstatus"]]],[11,"from","","",8,[[["string"]],["crudstatus"]]],[11,"from","holochain_core_types::json","",39,[[["entityattributevalue"]],["jsonstring"]]],[11,"from","","",39,[[["entityattributevalue"]],["jsonstring"]]],[11,"from","holochain_core_types::entry::entry_type","",54,[[["str"]],["self"]]],[11,"from","","",54,[[["string"]],["self"]]],[11,"from","holochain_core_types::json","",39,[[["entrytype"]],["jsonstring"]]],[11,"from","","",39,[[["entrytype"]],["jsonstring"]]],[11,"from","holochain_core_types::entry::entry_type","",14,[[["string"]],["entrytype"]]],[11,"from","","",14,[[["str"]],["entrytype"]]],[11,"from","holochain_core_types::json","",39,[[["entry"]],["jsonstring"]]],[11,"from","","",39,[[["entry"]],["jsonstring"]]],[11,"from","","",39,[[["option",["entry"]]],["self"]]],[11,"from","","",39,[[["coreerror"]],["jsonstring"]]],[11,"from","","",39,[[["coreerror"]],["jsonstring"]]],[11,"from","","",39,[[["holochainerror"]],["jsonstring"]]],[11,"from","","",39,[[["holochainerror"]],["jsonstring"]]],[11,"from","holochain_core_types::error::error","",20,[[["string"]],["self"]]],[11,"from","","",20,[[["str"]],["self"]]],[11,"from","","",20,[[["poisonerror"]],["self"]]],[11,"from","","",20,[[["ioerror"]],["self"]]],[11,"from","","",20,[[["serdeerror"]],["self"]]],[11,"from","","",20,[[["decodeerror"]],["self"]]],[11,"from","","",20,[[["decodererror"]],["self"]]],[11,"from","","",20,[[["futurecanceled"]],["self"]]],[11,"from","holochain_core_types::json","",39,[[["zomeapiinternalresult"]],["jsonstring"]]],[11,"from","","",39,[[["zomeapiinternalresult"]],["jsonstring"]]],[11,"from","","",39,[[["ribosomereturncode"]],["jsonstring"]]],[11,"from","","",39,[[["ribosomeerrorcode"]],["jsonstring"]]],[11,"from","","",39,[[["ribosomeerrorcode"]],["jsonstring"]]],[11,"from","","",39,[[["agentid"]],["jsonstring"]]],[11,"from","","",39,[[["agentid"]],["jsonstring"]]],[11,"from","","",39,[[["entrytypedef"]],["jsonstring"]]],[11,"from","","",39,[[["entrytypedef"]],["jsonstring"]]],[11,"from","","",39,[[["zome"]],["jsonstring"]]],[11,"from","","",39,[[["zome"]],["jsonstring"]]],[11,"from","","",39,[[["dna"]],["jsonstring"]]],[11,"from","","",39,[[["dna"]],["jsonstring"]]],[11,"from","","",39,[[["hashstring"]],["jsonstring"]]],[11,"from","","",39,[[["hashstring"]],["jsonstring"]]],[11,"from","holochain_core_types::hash","",38,[[["string"]],["hashstring"]]],[11,"from","","",38,[[["str"]],["hashstring"]]],[11,"from","holochain_core_types::json","",39,[[["string"]],["jsonstring"]]],[11,"from","","",39,[[["value"]],["jsonstring"]]],[11,"from","","",39,[[["str"]],["jsonstring"]]],[11,"from","","",39,[[["vec"]],["jsonstring"]]],[11,"from","","",39,[[["result"]],["jsonstring"]]],[11,"from","","",39,N],[11,"from","","",57,[[["str"]],["rawstring"]]],[11,"from","","",57,[[["string"]],["rawstring"]]],[11,"from","","",57,[[["f64"]],["rawstring"]]],[11,"from","","",57,[[["i32"]],["rawstring"]]],[11,"from","","",39,[[["rawstring"]],["jsonstring"]]],[11,"from","","",39,[[["linkadd"]],["jsonstring"]]],[11,"from","","",39,[[["linkadd"]],["jsonstring"]]],[11,"from","","",39,[[["linklist"]],["jsonstring"]]],[11,"from","","",39,[[["linklist"]],["jsonstring"]]],[11,"from","","",39,[[["link"]],["jsonstring"]]],[11,"from","","",39,[[["link"]],["jsonstring"]]],[11,"from","holochain_core_types::signature","",59,[[["str"]],["signature"]]],[11,"from","holochain_core_types::time","",60,[[["str"]],["iso8601"]]],[11,"from","holochain_core_types::json","",39,[[["validationpackage"]],["jsonstring"]]],[11,"from","","",39,[[["validationpackage"]],["jsonstring"]]],[11,"from","","",39,[[["validationpackagedefinition"]],["jsonstring"]]],[11,"from","","",39,[[["validationpackagedefinition"]],["jsonstring"]]],[11,"clone","holochain_core_types::cas::content","",52,[[["self"]],["exampleaddressablecontent"]]],[11,"clone","","",53,[[["self"]],["otherexampleaddressablecontent"]]],[11,"clone","holochain_core_types::cas::storage","",4,[[["self"]],["examplecontentaddressablestorage"]]],[11,"clone","holochain_core_types::chain_header","",7,[[["self"]],["chainheader"]]],[11,"clone","holochain_core_types::crud_status","",8,[[["self"]],["crudstatus"]]],[11,"clone","holochain_core_types::eav","",10,[[["self"]],["entityattributevalue"]]],[11,"clone","","",11,[[["self"]],["exampleentityattributevaluestoragenonsync"]]],[11,"clone","","",12,[[["self"]],["exampleentityattributevaluestorage"]]],[11,"clone","holochain_core_types::entry::entry_type","",54,[[["self"]],["appentrytype"]]],[11,"clone","","",14,[[["self"]],["entrytype"]]],[11,"clone","holochain_core_types::entry","",13,[[["self"]],["entry"]]],[11,"clone","holochain_core_types::error","",15,[[["self"]],["dnaerror"]]],[11,"clone","holochain_core_types::error::error","",18,[[["self"]],["coreerror"]]],[11,"clone","","",20,[[["self"]],["holochainerror"]]],[11,"clone","holochain_core_types::error","",16,[[["self"]],["ribosomereturncode"]]],[11,"clone","","",17,[[["self"]],["ribosomeerrorcode"]]],[11,"clone","holochain_core_types::agent","",22,[[["self"]],["keybuffer"]]],[11,"clone","","",21,[[["self"]],["agentid"]]],[11,"clone","holochain_core_types::chain_migrate","",55,[[["self"]],["chainmigrate"]]],[11,"clone","holochain_core_types::delete","",56,[[["self"]],["delete"]]],[11,"clone","holochain_core_types::dna::wasm","",24,[[["self"]],["dnawasm"]]],[11,"clone","holochain_core_types::dna::zome::capabilities","",33,[[["self"]],["membrane"]]],[11,"clone","","",28,[[["self"]],["capabilitytype"]]],[11,"clone","","",29,[[["self"]],["fnparameter"]]],[11,"clone","","",30,[[["self"]],["fndeclaration"]]],[11,"clone","","",31,[[["self"]],["capability"]]],[11,"clone","holochain_core_types::dna::zome::entry_types","",37,[[["self"]],["sharing"]]],[11,"clone","","",34,[[["self"]],["linksto"]]],[11,"clone","","",35,[[["self"]],["linkedfrom"]]],[11,"clone","","",36,[[["self"]],["entrytypedef"]]],[11,"clone","holochain_core_types::dna::zome","",27,[[["self"]],["errorhandling"]]],[11,"clone","","",25,[[["self"]],["config"]]],[11,"clone","","",26,[[["self"]],["zome"]]],[11,"clone","holochain_core_types::dna","",23,[[["self"]],["dna"]]],[11,"clone","holochain_core_types::hash","",38,[[["self"]],["hashstring"]]],[11,"clone","holochain_core_types::json","",39,[[["self"]],["jsonstring"]]],[11,"clone","","",57,[[["self"]],["rawstring"]]],[11,"clone","holochain_core_types::keys","",40,[[["self"]],["key"]]],[11,"clone","","",41,[[["self"]],["keys"]]],[11,"clone","holochain_core_types::link::link_add","",43,[[["self"]],["linkadd"]]],[11,"clone","holochain_core_types::link::link_list","",44,[[["self"]],["linklist"]]],[11,"clone","holochain_core_types::link::link_remove","",58,[[["self"]],["linkremove"]]],[11,"clone","holochain_core_types::link","",45,[[["self"]],["link"]]],[11,"clone","","",42,[[["self"]],["linkactionkind"]]],[11,"clone","holochain_core_types::signature","",59,[[["self"]],["signature"]]],[11,"clone","holochain_core_types::time","",60,[[["self"]],["iso8601"]]],[11,"clone","holochain_core_types::validation","",46,[[["self"]],["validationpackage"]]],[11,"clone","","",48,[[["self"]],["validationpackagedefinition"]]],[11,"clone","","",47,[[["self"]],["validationdata"]]],[11,"clone","","",49,[[["self"]],["entrylifecycle"]]],[11,"clone","","",50,[[["self"]],["entryaction"]]],[11,"clone","","",51,[[["self"]],["linkaction"]]],[11,"extend","holochain_core_types::crud_status","",8,[[["self"],["t"]]]],[11,"partial_cmp","","",8,[[["self"],["crudstatus"]],["option",["ordering"]]]],[11,"lt","","",8,[[["self"],["crudstatus"]],["bool"]]],[11,"le","","",8,[[["self"],["crudstatus"]],["bool"]]],[11,"gt","","",8,[[["self"],["crudstatus"]],["bool"]]],[11,"ge","","",8,[[["self"],["crudstatus"]],["bool"]]],[11,"partial_cmp","holochain_core_types::entry::entry_type","",54,[[["self"],["appentrytype"]],["option",["ordering"]]]],[11,"lt","","",54,[[["self"],["appentrytype"]],["bool"]]],[11,"le","","",54,[[["self"],["appentrytype"]],["bool"]]],[11,"gt","","",54,[[["self"],["appentrytype"]],["bool"]]],[11,"ge","","",54,[[["self"],["appentrytype"]],["bool"]]],[11,"partial_cmp","","",14,[[["self"],["entrytype"]],["option",["ordering"]]]],[11,"lt","","",14,[[["self"],["entrytype"]],["bool"]]],[11,"le","","",14,[[["self"],["entrytype"]],["bool"]]],[11,"gt","","",14,[[["self"],["entrytype"]],["bool"]]],[11,"ge","","",14,[[["self"],["entrytype"]],["bool"]]],[11,"partial_cmp","holochain_core_types::hash","",38,[[["self"],["hashstring"]],["option",["ordering"]]]],[11,"lt","","",38,[[["self"],["hashstring"]],["bool"]]],[11,"le","","",38,[[["self"],["hashstring"]],["bool"]]],[11,"gt","","",38,[[["self"],["hashstring"]],["bool"]]],[11,"ge","","",38,[[["self"],["hashstring"]],["bool"]]],[11,"to_string","holochain_core_types::entry::entry_type","",54,[[["self"]],["string"]]],[11,"to_string","holochain_core_types::error","",16,[[["self"]],["string"]]],[11,"to_string","","",17,[[["self"]],["string"]]],[11,"default","holochain_core_types::crud_status","",8,[[],["crudstatus"]]],[11,"default","holochain_core_types::error::error","",19,[[],["zomeapiinternalresult"]]],[11,"default","holochain_core_types::dna::wasm","Provide defaults for wasm entries in dna structs.",24,[[],["self"]]],[11,"default","holochain_core_types::dna::zome::capabilities","Default zome capability membrane is \"agent\"",33,[[],["self"]]],[11,"default","","Defaults for a \"capability\" sub-object on a \"zome\" \"capabilities\" object.",28,[[],["self"]]],[11,"default","","Defaults for a \"fn_declarations\" object.",30,[[],["self"]]],[11,"default","","Provide defaults for a \"zome\"s \"capabilities\" object.",31,[[],["self"]]],[11,"default","holochain_core_types::dna::zome::entry_types","Default zome entry_type sharing is \"public\"",37,[[],["self"]]],[11,"default","","Provide defaults for a \"links_to\" object.",34,[[],["self"]]],[11,"default","","Provide defaults for a \"links_to\" object.",35,[[],["self"]]],[11,"default","","",36,[[],["entrytypedef"]]],[11,"default","holochain_core_types::dna::zome","Default zome config error_handling is \"throw-errors\"",27,[[],["self"]]],[11,"default","","Provide defaults for the \"zome\" \"config\" object.",25,[[],["self"]]],[11,"default","","Provide defaults for an individual \"zome\".",26,[[],["self"]]],[11,"default","holochain_core_types::dna","Provide defaults for a dna object.",23,[[],["self"]]],[11,"default","holochain_core_types::hash","",38,[[],["hashstring"]]],[11,"default","holochain_core_types::keys","",40,[[],["key"]]],[11,"default","","",41,[[],["keys"]]],[11,"fmt","holochain_core_types::cas::content","",52,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",53,[[["self"],["formatter"]],["result"]]],[11,"fmt","holochain_core_types::cas::storage","",4,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",5,[[["self"],["formatter"]],["result"]]],[11,"fmt","holochain_core_types::chain_header","",7,[[["self"],["formatter"]],["result"]]],[11,"fmt","holochain_core_types::crud_status","",8,[[["self"],["formatter"]],["result"]]],[11,"fmt","holochain_core_types::eav","",10,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",11,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",12,[[["self"],["formatter"]],["result"]]],[11,"fmt","holochain_core_types::entry::entry_type","",54,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",14,[[["self"],["formatter"]],["result"]]],[11,"fmt","holochain_core_types::entry","",13,[[["self"],["formatter"]],["result"]]],[11,"fmt","holochain_core_types::error","",15,[[["self"],["formatter"]],["result"]]],[11,"fmt","holochain_core_types::error::error","",18,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",20,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",19,[[["self"],["formatter"]],["result"]]],[11,"fmt","holochain_core_types::error","",16,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",17,[[["self"],["formatter"]],["result"]]],[11,"fmt","holochain_core_types::agent","",21,[[["self"],["formatter"]],["result"]]],[11,"fmt","holochain_core_types::chain_migrate","",55,[[["self"],["formatter"]],["result"]]],[11,"fmt","holochain_core_types::delete","",56,[[["self"],["formatter"]],["result"]]],[11,"fmt","holochain_core_types::dna::wasm","",24,[[["self"],["formatter"]],["result"]]],[11,"fmt","holochain_core_types::dna::zome::capabilities","",32,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",33,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",28,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",29,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",30,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",31,[[["self"],["formatter"]],["result"]]],[11,"fmt","holochain_core_types::dna::zome::entry_types","",37,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",34,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",35,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",36,[[["self"],["formatter"]],["result"]]],[11,"fmt","holochain_core_types::dna::zome","",27,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",25,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",26,[[["self"],["formatter"]],["result"]]],[11,"fmt","holochain_core_types::dna","",23,[[["self"],["formatter"]],["result"]]],[11,"fmt","holochain_core_types::hash","",38,[[["self"],["formatter"]],["result"]]],[11,"fmt","holochain_core_types::json","",39,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",57,[[["self"],["formatter"]],["result"]]],[11,"fmt","holochain_core_types::keys","",40,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",41,[[["self"],["formatter"]],["result"]]],[11,"fmt","holochain_core_types::link::link_add","",43,[[["self"],["formatter"]],["result"]]],[11,"fmt","holochain_core_types::link::link_list","",44,[[["self"],["formatter"]],["result"]]],[11,"fmt","holochain_core_types::link::link_remove","",58,[[["self"],["formatter"]],["result"]]],[11,"fmt","holochain_core_types::link","",45,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",42,[[["self"],["formatter"]],["result"]]],[11,"fmt","holochain_core_types::signature","",59,[[["self"],["formatter"]],["result"]]],[11,"fmt","holochain_core_types::time","",60,[[["self"],["formatter"]],["result"]]],[11,"fmt","holochain_core_types::validation","",46,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",48,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",47,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",49,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",50,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",51,[[["self"],["formatter"]],["result"]]],[11,"fmt","holochain_core_types::entry::entry_type","",14,[[["self"],["formatter"]],["fmtresult"]]],[11,"fmt","holochain_core_types::error","",15,[[["self"],["formatter"]],["result"]]],[11,"fmt","holochain_core_types::error::error","",18,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",20,[[["self"],["formatter"]],["result"]]],[11,"fmt","holochain_core_types::hash","",38,[[["self"],["formatter"]],["result"]]],[11,"fmt","holochain_core_types::json","",39,[[["self"],["formatter"]],["fmtresult"]]],[11,"try_from","holochain_core_types::chain_header","",7,[[["jsonstring"]],["result"]]],[11,"try_from","","",7,[[["jsonstring"]],["result"]]],[11,"try_from","holochain_core_types::crud_status","",8,[[["jsonstring"]],["result"]]],[11,"try_from","","",8,[[["jsonstring"]],["result"]]],[11,"try_from","holochain_core_types::eav","",10,[[["jsonstring"]],["result"]]],[11,"try_from","","",10,[[["jsonstring"]],["result"]]],[11,"try_from","holochain_core_types::entry::entry_type","",14,[[["jsonstring"]],["result"]]],[11,"try_from","","",14,[[["jsonstring"]],["result"]]],[11,"try_from","holochain_core_types::entry","",13,[[["jsonstring"]],["result"]]],[11,"try_from","","",13,[[["jsonstring"]],["result"]]],[11,"try_from","holochain_core_types::error::error","",18,[[["jsonstring"]],["result"]]],[11,"try_from","","",18,[[["jsonstring"]],["result"]]],[11,"try_from","","",18,[[["zomeapiinternalresult"]],["result"]]],[11,"try_from","","",20,[[["jsonstring"]],["result"]]],[11,"try_from","","",20,[[["jsonstring"]],["result"]]],[11,"try_from","","",19,[[["jsonstring"]],["result"]]],[11,"try_from","","",19,[[["jsonstring"]],["result"]]],[11,"try_from","holochain_core_types::error","",16,[[["jsonstring"]],["result"]]],[11,"try_from","","",17,[[["jsonstring"]],["result"]]],[11,"try_from","","",17,[[["jsonstring"]],["result"]]],[11,"try_from","holochain_core_types::agent","",21,[[["jsonstring"]],["result"]]],[11,"try_from","","",21,[[["jsonstring"]],["result"]]],[11,"try_from","holochain_core_types::dna::zome::entry_types","",36,[[["jsonstring"]],["result"]]],[11,"try_from","","",36,[[["jsonstring"]],["result"]]],[11,"try_from","holochain_core_types::dna::zome","",26,[[["jsonstring"]],["result"]]],[11,"try_from","","",26,[[["jsonstring"]],["result"]]],[11,"try_from","holochain_core_types::dna","",23,[[["jsonstring"]],["result"]]],[11,"try_from","","",23,[[["jsonstring"]],["result"]]],[11,"try_from","holochain_core_types::hash","",38,[[["jsonstring"]],["result"]]],[11,"try_from","","",38,[[["jsonstring"]],["result"]]],[11,"try_from","holochain_core_types::json","",57,[[["jsonstring"]],["hcresult"]]],[11,"try_from","holochain_core_types::link::link_add","",43,[[["jsonstring"]],["result"]]],[11,"try_from","","",43,[[["jsonstring"]],["result"]]],[11,"try_from","holochain_core_types::link::link_list","",44,[[["jsonstring"]],["result"]]],[11,"try_from","","",44,[[["jsonstring"]],["result"]]],[11,"try_from","holochain_core_types::link","",45,[[["jsonstring"]],["result"]]],[11,"try_from","","",45,[[["jsonstring"]],["result"]]],[11,"try_from","holochain_core_types::validation","",46,[[["jsonstring"]],["result"]]],[11,"try_from","","",46,[[["jsonstring"]],["result"]]],[11,"try_from","","",48,[[["jsonstring"]],["result"]]],[11,"try_from","","",48,[[["jsonstring"]],["result"]]],[11,"from_str","holochain_core_types::entry::entry_type","",14,[[["str"]],["result"]]],[11,"from_str","holochain_core_types::error","",16,[[["str"]],["result"]]],[11,"from_str","","",17,[[["str"]],["result"]]],[11,"from_str","holochain_core_types::dna::zome::capabilities","",32,[[["str"]],["result"]]],[11,"sub","holochain_core_types::crud_status","Returns the set difference of the two sets of flags.",8,[[["self"],["crudstatus"]],["crudstatus"]]],[11,"sub_assign","","Disables all flags enabled in the set.",8,[[["self"],["crudstatus"]]]],[11,"not","","Returns the complement of this set of flags.",8,[[["self"]],["crudstatus"]]],[11,"bitand","","Returns the intersection between the two sets of flags.",8,[[["self"],["crudstatus"]],["crudstatus"]]],[11,"bitor","","Returns the union of the two sets of flags.",8,[[["self"],["crudstatus"]],["crudstatus"]]],[11,"bitxor","","Returns the left flags, but with all the right flags toggled.",8,[[["self"],["crudstatus"]],["crudstatus"]]],[11,"bitand_assign","","Disables all flags disabled in the set.",8,[[["self"],["crudstatus"]]]],[11,"bitor_assign","","Adds the set of flags.",8,[[["self"],["crudstatus"]]]],[11,"bitxor_assign","","Toggles the set of flags.",8,[[["self"],["crudstatus"]]]],[11,"hash","holochain_core_types::cas::content","",52,N],[11,"hash","holochain_core_types::crud_status","",8,N],[11,"hash","holochain_core_types::eav","",10,N],[11,"hash","holochain_core_types::entry::entry_type","",54,N],[11,"hash","","",14,N],[11,"hash","holochain_core_types::error","",15,N],[11,"hash","holochain_core_types::error::error","",18,N],[11,"hash","","",20,N],[11,"hash","holochain_core_types::error","",17,N],[11,"hash","holochain_core_types::dna::wasm","",24,N],[11,"hash","holochain_core_types::dna::zome::capabilities","",33,N],[11,"hash","","",28,N],[11,"hash","","",29,N],[11,"hash","","",30,N],[11,"hash","","",31,N],[11,"hash","holochain_core_types::dna::zome::entry_types","",37,N],[11,"hash","","",34,N],[11,"hash","","",35,N],[11,"hash","","",36,N],[11,"hash","holochain_core_types::dna::zome","",27,N],[11,"hash","","",25,N],[11,"hash","holochain_core_types::dna","",23,[[["self"],["h"]]]],[11,"hash","holochain_core_types::hash","",38,N],[11,"hash","holochain_core_types::json","",39,N],[11,"hash","holochain_core_types::link","",45,N],[11,"from_iter","holochain_core_types::crud_status","",8,[[["t"]],["crudstatus"]]],[11,"fmt","","",8,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",8,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",8,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",8,[[["self"],["formatter"]],["result"]]],[11,"description","holochain_core_types::error","",15,[[["self"]],["str"]]],[11,"description","holochain_core_types::error::error","",18,[[["self"]],["str"]]],[11,"cause","","",18,[[["self"]],["option",["error"]]]],[11,"description","","",20,[[["self"]],["str"]]],[11,"serialize","holochain_core_types::chain_header","",7,[[["self"],["__s"]],["result"]]],[11,"serialize","holochain_core_types::crud_status","",8,[[["self"],["__s"]],["result"]]],[11,"serialize","holochain_core_types::eav","",10,[[["self"],["__s"]],["result"]]],[11,"serialize","holochain_core_types::entry::entry_type","",54,[[["self"],["__s"]],["result"]]],[11,"serialize","","",14,[[["self"],["__s"]],["result"]]],[11,"serialize","holochain_core_types::entry","",13,[[["self"],["__s"]],["result"]]],[11,"serialize","holochain_core_types::error","",15,[[["self"],["__s"]],["result"]]],[11,"serialize","holochain_core_types::error::error","",18,[[["self"],["__s"]],["result"]]],[11,"serialize","","",20,[[["self"],["__s"]],["result"]]],[11,"serialize","","",19,[[["self"],["__s"]],["result"]]],[11,"serialize","holochain_core_types::error","",17,[[["self"],["s"]],["result"]]],[11,"serialize","holochain_core_types::agent","",21,[[["self"],["__s"]],["result"]]],[11,"serialize","holochain_core_types::chain_migrate","",55,[[["self"],["__s"]],["result"]]],[11,"serialize","holochain_core_types::delete","",56,[[["self"],["__s"]],["result"]]],[11,"serialize","holochain_core_types::dna::wasm","",24,[[["self"],["__s"]],["result"]]],[11,"serialize","holochain_core_types::dna::zome::capabilities","",33,[[["self"],["__s"]],["result"]]],[11,"serialize","","",28,[[["self"],["__s"]],["result"]]],[11,"serialize","","",29,[[["self"],["__s"]],["result"]]],[11,"serialize","","",30,[[["self"],["__s"]],["result"]]],[11,"serialize","","",31,[[["self"],["__s"]],["result"]]],[11,"serialize","holochain_core_types::dna::zome::entry_types","",37,[[["self"],["__s"]],["result"]]],[11,"serialize","","",34,[[["self"],["__s"]],["result"]]],[11,"serialize","","",35,[[["self"],["__s"]],["result"]]],[11,"serialize","","",36,[[["self"],["__s"]],["result"]]],[11,"serialize","holochain_core_types::dna::zome","",27,[[["self"],["__s"]],["result"]]],[11,"serialize","","",25,[[["self"],["__s"]],["result"]]],[11,"serialize","","",26,[[["self"],["__s"]],["result"]]],[11,"serialize","holochain_core_types::dna","",23,[[["self"],["__s"]],["result"]]],[11,"serialize","holochain_core_types::hash","",38,[[["self"],["__s"]],["result"]]],[11,"serialize","holochain_core_types::keys","",40,[[["self"],["__s"]],["result"]]],[11,"serialize","","",41,[[["self"],["__s"]],["result"]]],[11,"serialize","holochain_core_types::link::link_add","",43,[[["self"],["__s"]],["result"]]],[11,"serialize","holochain_core_types::link::link_list","",44,[[["self"],["__s"]],["result"]]],[11,"serialize","holochain_core_types::link::link_remove","",58,[[["self"],["__s"]],["result"]]],[11,"serialize","holochain_core_types::link","",45,[[["self"],["__s"]],["result"]]],[11,"serialize","","",42,[[["self"],["__s"]],["result"]]],[11,"serialize","holochain_core_types::signature","",59,[[["self"],["__s"]],["result"]]],[11,"serialize","holochain_core_types::time","",60,[[["self"],["__s"]],["result"]]],[11,"serialize","holochain_core_types::validation","",46,[[["self"],["__s"]],["result"]]],[11,"serialize","","",48,[[["self"],["__s"]],["result"]]],[11,"serialize","","",47,[[["self"],["__s"]],["result"]]],[11,"serialize","","",49,[[["self"],["__s"]],["result"]]],[11,"serialize","","",50,[[["self"],["__s"]],["result"]]],[11,"serialize","","",51,[[["self"],["__s"]],["result"]]],[11,"deserialize","holochain_core_types::chain_header","",7,[[["__d"]],["result"]]],[11,"deserialize","holochain_core_types::crud_status","",8,[[["__d"]],["result"]]],[11,"deserialize","holochain_core_types::eav","",10,[[["__d"]],["result"]]],[11,"deserialize","holochain_core_types::entry::entry_type","",54,[[["__d"]],["result"]]],[11,"deserialize","","",14,[[["__d"]],["result"]]],[11,"deserialize","holochain_core_types::entry","",13,[[["__d"]],["result"]]],[11,"deserialize","holochain_core_types::error","",15,[[["__d"]],["result"]]],[11,"deserialize","holochain_core_types::error::error","",18,[[["__d"]],["result"]]],[11,"deserialize","","",20,[[["__d"]],["result"]]],[11,"deserialize","","",19,[[["__d"]],["result"]]],[11,"deserialize","holochain_core_types::error","",17,[[["d"]],["result"]]],[11,"deserialize","holochain_core_types::agent","",21,[[["__d"]],["result"]]],[11,"deserialize","holochain_core_types::chain_migrate","",55,[[["__d"]],["result"]]],[11,"deserialize","holochain_core_types::delete","",56,[[["__d"]],["result"]]],[11,"deserialize","holochain_core_types::dna::wasm","",24,[[["__d"]],["result"]]],[11,"deserialize","holochain_core_types::dna::zome::capabilities","",33,[[["__d"]],["result"]]],[11,"deserialize","","",28,[[["__d"]],["result"]]],[11,"deserialize","","",29,[[["__d"]],["result"]]],[11,"deserialize","","",30,[[["__d"]],["result"]]],[11,"deserialize","","",31,[[["__d"]],["result"]]],[11,"deserialize","holochain_core_types::dna::zome::entry_types","",37,[[["__d"]],["result"]]],[11,"deserialize","","",34,[[["__d"]],["result"]]],[11,"deserialize","","",35,[[["__d"]],["result"]]],[11,"deserialize","","",36,[[["__d"]],["result"]]],[11,"deserialize","holochain_core_types::dna::zome","",27,[[["__d"]],["result"]]],[11,"deserialize","","",25,[[["__d"]],["result"]]],[11,"deserialize","","",26,[[["__d"]],["result"]]],[11,"deserialize","holochain_core_types::dna","",23,[[["__d"]],["result"]]],[11,"deserialize","holochain_core_types::hash","",38,[[["__d"]],["result"]]],[11,"deserialize","holochain_core_types::json","",57,[[["__d"]],["result"]]],[11,"deserialize","holochain_core_types::keys","",40,[[["__d"]],["result"]]],[11,"deserialize","","",41,[[["__d"]],["result"]]],[11,"deserialize","holochain_core_types::link::link_add","",43,[[["__d"]],["result"]]],[11,"deserialize","holochain_core_types::link::link_list","",44,[[["__d"]],["result"]]],[11,"deserialize","holochain_core_types::link::link_remove","",58,[[["__d"]],["result"]]],[11,"deserialize","holochain_core_types::link","",45,[[["__d"]],["result"]]],[11,"deserialize","","",42,[[["__d"]],["result"]]],[11,"deserialize","holochain_core_types::signature","",59,[[["__d"]],["result"]]],[11,"deserialize","holochain_core_types::time","",60,[[["__d"]],["result"]]],[11,"deserialize","holochain_core_types::validation","",46,[[["__d"]],["result"]]],[11,"deserialize","","",48,[[["__d"]],["result"]]],[11,"deserialize","","",47,[[["__d"]],["result"]]],[11,"deserialize","","",49,[[["__d"]],["result"]]],[11,"deserialize","","",50,[[["__d"]],["result"]]],[11,"deserialize","","",51,[[["__d"]],["result"]]]],"paths":[[8,"AddressableContent"],[3,"AddressableContentTestSuite"],[3,"StorageTestSuite"],[8,"ContentAddressableStorage"],[3,"ExampleContentAddressableStorage"],[3,"ExampleContentAddressableStorageContent"],[3,"EavTestSuite"],[3,"ChainHeader"],[3,"CrudStatus"],[8,"EntityAttributeValueStorage"],[3,"EntityAttributeValue"],[3,"ExampleEntityAttributeValueStorageNonSync"],[3,"ExampleEntityAttributeValueStorage"],[4,"Entry"],[4,"EntryType"],[4,"DnaError"],[4,"RibosomeReturnCode"],[4,"RibosomeErrorCode"],[3,"CoreError"],[3,"ZomeApiInternalResult"],[4,"HolochainError"],[3,"AgentId"],[3,"KeyBuffer"],[3,"Dna"],[3,"DnaWasm"],[3,"Config"],[3,"Zome"],[4,"ErrorHandling"],[3,"CapabilityType"],[3,"FnParameter"],[3,"FnDeclaration"],[3,"Capability"],[4,"ReservedCapabilityNames"],[4,"Membrane"],[3,"LinksTo"],[3,"LinkedFrom"],[3,"EntryTypeDef"],[4,"Sharing"],[3,"HashString"],[3,"JsonString"],[3,"Key"],[3,"Keys"],[4,"LinkActionKind"],[3,"LinkAdd"],[3,"LinkList"],[3,"Link"],[3,"ValidationPackage"],[3,"ValidationData"],[4,"ValidationPackageDefinition"],[4,"EntryLifecycle"],[4,"EntryAction"],[4,"LinkAction"],[3,"ExampleAddressableContent"],[3,"OtherExampleAddressableContent"],[3,"AppEntryType"],[3,"ChainMigrate"],[3,"Delete"],[3,"RawString"],[3,"LinkRemove"],[3,"Signature"],[3,"Iso8601"],[6,"Content"]]};
searchIndex["holochain_core_types_derive"]={"doc":"","items":[[24,"DefaultJson","holochain_core_types_derive","",N,N]],"paths":[]};
searchIndex["holochain_dna_c_binding"]={"doc":"This crate is an ffi wrapper to provide a c-compatible dna library.","items":[[3,"CStringVec","holochain_dna_c_binding","",N,N],[5,"holochain_dna_create","","",N,N],[5,"holochain_dna_create_from_json","","",N,N],[5,"holochain_dna_free","","",N,N],[5,"holochain_dna_to_json","","",N,N],[5,"holochain_dna_string_free","","",N,N],[5,"holochain_dna_get_name","","",N,N],[5,"holochain_dna_set_name","","",N,N],[5,"holochain_dna_get_description","","",N,N],[5,"holochain_dna_set_description","","",N,N],[5,"holochain_dna_get_version","","",N,N],[5,"holochain_dna_set_version","","",N,N],[5,"holochain_dna_get_uuid","","",N,N],[5,"holochain_dna_set_uuid","","",N,N],[5,"holochain_dna_get_dna_spec_version","","",N,N],[5,"holochain_dna_set_dna_spec_version","","",N,N],[5,"holochain_dna_get_zome_names","","",N,N],[5,"holochain_dna_free_zome_names","","",N,N],[5,"holochain_dna_get_capabilities_names","","",N,N],[5,"holochain_dna_get_function_names","","",N,N],[5,"holochain_dna_get_function_parameters","","",N,N],[11,"from","","",0,[[["t"]],["t"]]],[11,"into","","",0,[[["self"]],["u"]]],[11,"try_from","","",0,[[["u"]],["result"]]],[11,"borrow","","",0,[[["self"]],["t"]]],[11,"get_type_id","","",0,[[["self"]],["typeid"]]],[11,"try_into","","",0,[[["self"]],["result"]]],[11,"borrow_mut","","",0,[[["self"]],["t"]]]],"paths":[[3,"CStringVec"]]};
searchIndex["holochain_net"]={"doc":"holochain_net is a library that defines an abstract networking layer for different network transports, providing a configurable interface for swapping different backends connection modules at load time","items":[[0,"error","holochain_net","",N,N],[4,"NetworkError","holochain_net::error","",N,N],[13,"GenericError","","",0,N],[12,"error","holochain_net::error::NetworkError","",0,N],[0,"ipc_net_worker","holochain_net","provides a NetWorker implementation for backend IPC p2p connections",N,N],[3,"IpcNetWorker","holochain_net::ipc_net_worker","a p2p net worker",N,N],[11,"new_test","","",1,[[["nethandler"],["teststruct"]],["netresult"]]],[11,"new","","",1,[[["nethandler"],["jsonstring"]],["netresult"]]],[0,"mock_worker","holochain_net","provides fake in-memory p2p worker for use in scenario testing",N,N],[3,"MockWorker","holochain_net::mock_worker","a p2p worker for mocking in-memory scenario tests",N,N],[11,"new","","create a new mock worker... no configuration required",2,[[["nethandler"]],["netresult"]]],[0,"p2p_network","holochain_net","This module provides the core abstraction for differing p2p backends P2pNetwork instances take a json configuration string and at load-time instantiate the configured \"backend\"",N,N],[3,"P2pNetwork","holochain_net::p2p_network","The p2p network instance",N,N],[11,"new","","create a new p2p network instance, given message handler and config json",3,[[["nethandler"],["jsonstring"]],["netresult"]]],[11,"stop","","stop the network module (disconnect any sockets, join any threads, etc)",3,[[["self"]],["netresult"]]],[11,"from","holochain_net::error","",0,[[["t"]],["t"]]],[11,"into","","",0,[[["self"]],["u"]]],[11,"to_string","","",0,[[["self"]],["string"]]],[11,"try_from","","",0,[[["u"]],["result"]]],[11,"borrow","","",0,[[["self"]],["t"]]],[11,"get_type_id","","",0,[[["self"]],["typeid"]]],[11,"try_into","","",0,[[["self"]],["result"]]],[11,"borrow_mut","","",0,[[["self"]],["t"]]],[11,"as_fail","","",0,[[["self"]],["fail"]]],[11,"from","holochain_net::ipc_net_worker","",1,[[["t"]],["t"]]],[11,"into","","",1,[[["self"]],["u"]]],[11,"try_from","","",1,[[["u"]],["result"]]],[11,"borrow","","",1,[[["self"]],["t"]]],[11,"get_type_id","","",1,[[["self"]],["typeid"]]],[11,"try_into","","",1,[[["self"]],["result"]]],[11,"borrow_mut","","",1,[[["self"]],["t"]]],[11,"from","holochain_net::mock_worker","",2,[[["t"]],["t"]]],[11,"into","","",2,[[["self"]],["u"]]],[11,"try_from","","",2,[[["u"]],["result"]]],[11,"borrow","","",2,[[["self"]],["t"]]],[11,"get_type_id","","",2,[[["self"]],["typeid"]]],[11,"try_into","","",2,[[["self"]],["result"]]],[11,"borrow_mut","","",2,[[["self"]],["t"]]],[11,"from","holochain_net::p2p_network","",3,[[["t"]],["t"]]],[11,"into","","",3,[[["self"]],["u"]]],[11,"try_from","","",3,[[["u"]],["result"]]],[11,"borrow","","",3,[[["self"]],["t"]]],[11,"get_type_id","","",3,[[["self"]],["typeid"]]],[11,"try_into","","",3,[[["self"]],["result"]]],[11,"borrow_mut","","",3,[[["self"]],["t"]]],[11,"fmt","holochain_net::error","",0,[[["self"],["formatter"]],["result"]]],[11,"fmt","holochain_net::p2p_network","",3,[[["self"],["formatter"]],["result"]]],[11,"fmt","holochain_net::error","",0,[[["self"],["formatter"]],["result"]]],[11,"cause","","",0,[[["self"]],["option",["fail"]]]],[11,"backtrace","","",0,[[["self"]],["option",["backtrace"]]]],[11,"send","holochain_net::p2p_network","send a Protocol message to the p2p network instance",3,[[["self"],["protocol"]],["netresult"]]],[11,"stop","holochain_net::ipc_net_worker","stop the net worker",1,[[["box"]],["netresult"]]],[11,"receive","","we got a message from holochain core (just forwards to the internal worker relay)",1,[[["self"],["protocol"]],["netresult"]]],[11,"tick","","do some upkeep on the internal worker",1,[[["self"]],["netresult",["bool"]]]],[11,"stop","holochain_net::mock_worker","stop the net worker",2,[[["box"]],["netresult"]]],[11,"receive","","we got a message from holochain core forward to our mock singleton",2,[[["self"],["protocol"]],["netresult"]]],[11,"tick","","check for messages from our mock singleton",2,[[["self"]],["netresult",["bool"]]]]],"paths":[[4,"NetworkError"],[3,"IpcNetWorker"],[3,"MockWorker"],[3,"P2pNetwork"]]};
searchIndex["holochain_net_connection"]={"doc":"Provides a lightweight concurrency abstraction for holochain networking / p2p layer see holochain_net_ipc for a specific implementation, and holochain_net for the crate that pulls the implementations together","items":[[0,"net_connection","holochain_net_connection","",N,N],[3,"NetConnectionRelay","holochain_net_connection::net_connection","a simple pass-through NetConnection instance this struct can be use to compose one type of NetWorker into another",N,N],[6,"NetHandler","","closure for getting Protocol messages from the p2p abstraction system",N,N],[6,"NetWorkerFactory","","closure for instantiating a NetWorker",N,N],[8,"NetConnection","","net connection - a worker manager can send Protocol messages",N,N],[10,"send","","",0,[[["self"],["protocol"]],["netresult"]]],[8,"NetWorker","","represents a worker that handles protocol messages",N,N],[11,"stop","","stop the worker",1,[[["box"]],["netresult"]]],[11,"receive","","when somebody has called `send` to send this worker a message",1,[[["self"],["protocol"]],["netresult"]]],[11,"tick","","perform any upkeep return `false` if there was no upkeep to perform",1,[[["self"]],["netresult",["bool"]]]],[11,"stop","","stop this NetConnectionRelay instance",2,[[["self"]],["netresult"]]],[11,"tick","","call tick to perform any worker upkeep",2,[[["self"]],["netresult",["bool"]]]],[11,"new","","create a new NetConnectionRelay instance with give handler / factory",2,[[["nethandler"],["networkerfactory"]],["netresult"]]],[0,"net_connection_thread","holochain_net_connection","",N,N],[3,"NetConnectionThread","holochain_net_connection::net_connection_thread","a NetConnection instance that is managed on another thread",N,N],[11,"stop","","stop (join) the worker thread",3,[[["self"]],["netresult"]]],[11,"new","","create a new NetConnectionThread instance with given handler / worker",3,[[["nethandler"],["networkerfactory"]],["netresult"]]],[0,"protocol","holochain_net_connection","This module provides the core low-level protocol enumeration for communications between holochain core and the p2p / networking process or library. See protocol_wrapper for a higher level interface.",N,N],[3,"NamedBinaryData","holochain_net_connection::protocol","send/recv binary data / i.e. encryption, signature messages",N,N],[12,"name","","",4,N],[12,"data","","",4,N],[3,"PingData","","send/recv a Ping message (ipc protocol spec)",N,N],[12,"sent","","",5,N],[3,"PongData","","send/recv a Pong message (ipc protocol spec)",N,N],[12,"orig","","",6,N],[12,"recv","","",6,N],[4,"Protocol","","Low-level interface spec for communicating with the p2p abstraction notice this is not Serializable or Deserializable rmp_serde doesn't serialize enums very well... it uses indexes and arrays which are not (easily) compatible with other endpoints we use to/from NamedBinaryData to provide our own serialization wrapper",N,N],[13,"NamedBinary","","send/recv binary data / i.e. encryption, signature messages",7,N],[13,"Json","","send/recv generic json as utf8 strings",7,N],[13,"Ping","","send/recv a Ping message (ipc protocol spec)",7,N],[13,"Pong","","send/recv a Pong message (ipc protocol spec)",7,N],[13,"P2pReady","","we have connected / configured the connection, ready for messages",7,N],[11,"is_named_binary","","",7,[[["self"]],["bool"]]],[11,"as_named_binary","","",7,[[["self"]],["namedbinarydata"]]],[11,"is_json","","",7,[[["self"]],["bool"]]],[11,"as_json","","",7,[[["self"]],["jsonstring"]]],[11,"is_ping","","",7,[[["self"]],["bool"]]],[11,"as_ping","","",7,[[["self"]],["pingdata"]]],[11,"is_pong","","",7,[[["self"]],["bool"]]],[11,"as_pong","","",7,[[["self"]],["pongdata"]]],[11,"as_json_string","","get a json string straight out of the Protocol enum",7,[[["self"]],["jsonstring"]]],[0,"protocol_wrapper","holochain_net_connection","This module provides a higher level interface to p2p / network messaging basically handles serialization / deserialization from / to the core protocol message types (NamedBinary and Json).",N,N],[3,"StateData","holochain_net_connection::protocol_wrapper","",N,N],[12,"state","","",8,N],[12,"id","","",8,N],[12,"bindings","","",8,N],[3,"ConfigData","","",N,N],[12,"config","","",9,N],[3,"ConnectData","","",N,N],[12,"address","","",10,N],[3,"PeerData","","",N,N],[12,"id","","",11,N],[3,"MessageData","","",N,N],[12,"msg_id","","",12,N],[12,"dna_hash","","",12,N],[12,"to_agent_id","","",12,N],[12,"from_agent_id","","",12,N],[12,"data","","",12,N],[3,"TrackAppData","","",N,N],[12,"dna_hash","","",13,N],[12,"agent_id","","",13,N],[3,"SuccessResultData","","",N,N],[12,"msg_id","","",14,N],[12,"dna_hash","","",14,N],[12,"to_agent_id","","",14,N],[12,"success_info","","",14,N],[3,"FailureResultData","","",N,N],[12,"msg_id","","",15,N],[12,"dna_hash","","",15,N],[12,"to_agent_id","","",15,N],[12,"error_info","","",15,N],[3,"GetDhtData","","",N,N],[12,"msg_id","","",16,N],[12,"dna_hash","","",16,N],[12,"from_agent_id","","",16,N],[12,"address","","",16,N],[3,"DhtData","","",N,N],[12,"msg_id","","",17,N],[12,"dna_hash","","",17,N],[12,"agent_id","","",17,N],[12,"address","","",17,N],[12,"content","","",17,N],[3,"GetDhtMetaData","","",N,N],[12,"msg_id","","",18,N],[12,"dna_hash","","",18,N],[12,"from_agent_id","","",18,N],[12,"address","","",18,N],[12,"attribute","","",18,N],[3,"DhtMetaData","","",N,N],[12,"msg_id","","",19,N],[12,"dna_hash","","",19,N],[12,"agent_id","","",19,N],[12,"address","","",19,N],[12,"attribute","","",19,N],[12,"content","","",19,N],[4,"ProtocolWrapper","","High level p2p / network message",N,N],[13,"RequestState","","[send] request the current state from the p2p module",20,N],[13,"State","","[recv] p2p module is telling us the current state",20,N],[13,"RequestDefaultConfig","","[send] request the default config from the p2p module",20,N],[13,"DefaultConfig","","[recv] the default config from the p2p module",20,N],[13,"SetConfig","","[send] set the p2p config",20,N],[13,"Connect","","[send] connect to the specified multiaddr",20,N],[13,"PeerConnected","","[recv] notification of a peer connected",20,N],[13,"SendMessage","","[send] send a message to another node on the network",20,N],[13,"SendResult","","[recv] recv the response back from a previous `SendMessage`",20,N],[13,"HandleSend","","[recv] another node has sent us a message",20,N],[13,"HandleSendResult","","[send] send our response to a previous `HandleSend`",20,N],[13,"TrackApp","","[send] send out a \"trackApp\" request",20,N],[13,"SuccessResult","","[send / recv] report success for a messages with _id parameter",20,N],[13,"FailureResult","","[send / recv] for any message with _id parameter to indicate failure",20,N],[13,"GetDht","","[send] request data from the dht [recv] another node, or the network module itself is requesting data        from us... send a GetDhtResult message back",20,N],[13,"GetDhtResult","","[recv] response from requesting dht data from the network [send] success response if network is requesting this data of us",20,N],[13,"PublishDht","","[send] publish content to the dht",20,N],[13,"StoreDht","","[recv] the network is requesting that we store this data",20,N],[13,"GetDhtMeta","","[send] request meta data from the dht [recv] another node, or the network module itself is requesting data        from us... send a GetDhtResult message back",20,N],[13,"GetDhtMetaResult","","[recv] response from requesting meta dht data from the network [send] success response if network is requesting this data of us",20,N],[13,"PublishDhtMeta","","[send] publish meta content to the dht",20,N],[13,"StoreDhtMeta","","[recv] the network is requesting that we store this meta data",20,N],[6,"NetResult","holochain_net_connection","",N,N],[11,"from","holochain_net_connection::net_connection","",2,[[["t"]],["t"]]],[11,"into","","",2,[[["self"]],["u"]]],[11,"try_from","","",2,[[["u"]],["result"]]],[11,"borrow","","",2,[[["self"]],["t"]]],[11,"get_type_id","","",2,[[["self"]],["typeid"]]],[11,"try_into","","",2,[[["self"]],["result"]]],[11,"borrow_mut","","",2,[[["self"]],["t"]]],[11,"from","holochain_net_connection::net_connection_thread","",3,[[["t"]],["t"]]],[11,"into","","",3,[[["self"]],["u"]]],[11,"try_from","","",3,[[["u"]],["result"]]],[11,"borrow","","",3,[[["self"]],["t"]]],[11,"get_type_id","","",3,[[["self"]],["typeid"]]],[11,"try_into","","",3,[[["self"]],["result"]]],[11,"borrow_mut","","",3,[[["self"]],["t"]]],[11,"from","holochain_net_connection::protocol","",4,[[["t"]],["t"]]],[11,"into","","",4,[[["self"]],["u"]]],[11,"to_owned","","",4,[[["self"]],["t"]]],[11,"clone_into","","",4,N],[11,"try_from","","",4,[[["u"]],["result"]]],[11,"borrow","","",4,[[["self"]],["t"]]],[11,"get_type_id","","",4,[[["self"]],["typeid"]]],[11,"try_into","","",4,[[["self"]],["result"]]],[11,"borrow_mut","","",4,[[["self"]],["t"]]],[11,"clone_box","","",4,N],[11,"from","","",5,[[["t"]],["t"]]],[11,"into","","",5,[[["self"]],["u"]]],[11,"to_owned","","",5,[[["self"]],["t"]]],[11,"clone_into","","",5,N],[11,"try_from","","",5,[[["u"]],["result"]]],[11,"borrow","","",5,[[["self"]],["t"]]],[11,"get_type_id","","",5,[[["self"]],["typeid"]]],[11,"try_into","","",5,[[["self"]],["result"]]],[11,"borrow_mut","","",5,[[["self"]],["t"]]],[11,"clone_box","","",5,N],[11,"from","","",6,[[["t"]],["t"]]],[11,"into","","",6,[[["self"]],["u"]]],[11,"to_owned","","",6,[[["self"]],["t"]]],[11,"clone_into","","",6,N],[11,"try_from","","",6,[[["u"]],["result"]]],[11,"borrow","","",6,[[["self"]],["t"]]],[11,"get_type_id","","",6,[[["self"]],["typeid"]]],[11,"try_into","","",6,[[["self"]],["result"]]],[11,"borrow_mut","","",6,[[["self"]],["t"]]],[11,"clone_box","","",6,N],[11,"from","","",7,[[["t"]],["t"]]],[11,"into","","",7,[[["self"]],["u"]]],[11,"to_owned","","",7,[[["self"]],["t"]]],[11,"clone_into","","",7,N],[11,"try_from","","",7,[[["u"]],["result"]]],[11,"borrow","","",7,[[["self"]],["t"]]],[11,"get_type_id","","",7,[[["self"]],["typeid"]]],[11,"try_into","","",7,[[["self"]],["result"]]],[11,"borrow_mut","","",7,[[["self"]],["t"]]],[11,"clone_box","","",7,N],[11,"from","holochain_net_connection::protocol_wrapper","",8,[[["t"]],["t"]]],[11,"into","","",8,[[["self"]],["u"]]],[11,"to_owned","","",8,[[["self"]],["t"]]],[11,"clone_into","","",8,N],[11,"try_from","","",8,[[["u"]],["result"]]],[11,"borrow","","",8,[[["self"]],["t"]]],[11,"get_type_id","","",8,[[["self"]],["typeid"]]],[11,"try_into","","",8,[[["self"]],["result"]]],[11,"borrow_mut","","",8,[[["self"]],["t"]]],[11,"clone_box","","",8,N],[11,"from","","",9,[[["t"]],["t"]]],[11,"into","","",9,[[["self"]],["u"]]],[11,"to_owned","","",9,[[["self"]],["t"]]],[11,"clone_into","","",9,N],[11,"try_from","","",9,[[["u"]],["result"]]],[11,"borrow","","",9,[[["self"]],["t"]]],[11,"get_type_id","","",9,[[["self"]],["typeid"]]],[11,"try_into","","",9,[[["self"]],["result"]]],[11,"borrow_mut","","",9,[[["self"]],["t"]]],[11,"clone_box","","",9,N],[11,"from","","",10,[[["t"]],["t"]]],[11,"into","","",10,[[["self"]],["u"]]],[11,"to_owned","","",10,[[["self"]],["t"]]],[11,"clone_into","","",10,N],[11,"try_from","","",10,[[["u"]],["result"]]],[11,"borrow","","",10,[[["self"]],["t"]]],[11,"get_type_id","","",10,[[["self"]],["typeid"]]],[11,"try_into","","",10,[[["self"]],["result"]]],[11,"borrow_mut","","",10,[[["self"]],["t"]]],[11,"clone_box","","",10,N],[11,"from","","",11,[[["t"]],["t"]]],[11,"into","","",11,[[["self"]],["u"]]],[11,"to_owned","","",11,[[["self"]],["t"]]],[11,"clone_into","","",11,N],[11,"try_from","","",11,[[["u"]],["result"]]],[11,"borrow","","",11,[[["self"]],["t"]]],[11,"get_type_id","","",11,[[["self"]],["typeid"]]],[11,"try_into","","",11,[[["self"]],["result"]]],[11,"borrow_mut","","",11,[[["self"]],["t"]]],[11,"clone_box","","",11,N],[11,"from","","",12,[[["t"]],["t"]]],[11,"into","","",12,[[["self"]],["u"]]],[11,"to_owned","","",12,[[["self"]],["t"]]],[11,"clone_into","","",12,N],[11,"try_from","","",12,[[["u"]],["result"]]],[11,"borrow","","",12,[[["self"]],["t"]]],[11,"get_type_id","","",12,[[["self"]],["typeid"]]],[11,"try_into","","",12,[[["self"]],["result"]]],[11,"borrow_mut","","",12,[[["self"]],["t"]]],[11,"clone_box","","",12,N],[11,"from","","",13,[[["t"]],["t"]]],[11,"into","","",13,[[["self"]],["u"]]],[11,"to_owned","","",13,[[["self"]],["t"]]],[11,"clone_into","","",13,N],[11,"try_from","","",13,[[["u"]],["result"]]],[11,"borrow","","",13,[[["self"]],["t"]]],[11,"get_type_id","","",13,[[["self"]],["typeid"]]],[11,"try_into","","",13,[[["self"]],["result"]]],[11,"borrow_mut","","",13,[[["self"]],["t"]]],[11,"clone_box","","",13,N],[11,"from","","",14,[[["t"]],["t"]]],[11,"into","","",14,[[["self"]],["u"]]],[11,"to_owned","","",14,[[["self"]],["t"]]],[11,"clone_into","","",14,N],[11,"try_from","","",14,[[["u"]],["result"]]],[11,"borrow","","",14,[[["self"]],["t"]]],[11,"get_type_id","","",14,[[["self"]],["typeid"]]],[11,"try_into","","",14,[[["self"]],["result"]]],[11,"borrow_mut","","",14,[[["self"]],["t"]]],[11,"clone_box","","",14,N],[11,"from","","",15,[[["t"]],["t"]]],[11,"into","","",15,[[["self"]],["u"]]],[11,"to_owned","","",15,[[["self"]],["t"]]],[11,"clone_into","","",15,N],[11,"try_from","","",15,[[["u"]],["result"]]],[11,"borrow","","",15,[[["self"]],["t"]]],[11,"get_type_id","","",15,[[["self"]],["typeid"]]],[11,"try_into","","",15,[[["self"]],["result"]]],[11,"borrow_mut","","",15,[[["self"]],["t"]]],[11,"clone_box","","",15,N],[11,"from","","",16,[[["t"]],["t"]]],[11,"into","","",16,[[["self"]],["u"]]],[11,"to_owned","","",16,[[["self"]],["t"]]],[11,"clone_into","","",16,N],[11,"try_from","","",16,[[["u"]],["result"]]],[11,"borrow","","",16,[[["self"]],["t"]]],[11,"get_type_id","","",16,[[["self"]],["typeid"]]],[11,"try_into","","",16,[[["self"]],["result"]]],[11,"borrow_mut","","",16,[[["self"]],["t"]]],[11,"clone_box","","",16,N],[11,"from","","",17,[[["t"]],["t"]]],[11,"into","","",17,[[["self"]],["u"]]],[11,"to_owned","","",17,[[["self"]],["t"]]],[11,"clone_into","","",17,N],[11,"try_from","","",17,[[["u"]],["result"]]],[11,"borrow","","",17,[[["self"]],["t"]]],[11,"get_type_id","","",17,[[["self"]],["typeid"]]],[11,"try_into","","",17,[[["self"]],["result"]]],[11,"borrow_mut","","",17,[[["self"]],["t"]]],[11,"clone_box","","",17,N],[11,"from","","",18,[[["t"]],["t"]]],[11,"into","","",18,[[["self"]],["u"]]],[11,"to_owned","","",18,[[["self"]],["t"]]],[11,"clone_into","","",18,N],[11,"try_from","","",18,[[["u"]],["result"]]],[11,"borrow","","",18,[[["self"]],["t"]]],[11,"get_type_id","","",18,[[["self"]],["typeid"]]],[11,"try_into","","",18,[[["self"]],["result"]]],[11,"borrow_mut","","",18,[[["self"]],["t"]]],[11,"clone_box","","",18,N],[11,"from","","",19,[[["t"]],["t"]]],[11,"into","","",19,[[["self"]],["u"]]],[11,"to_owned","","",19,[[["self"]],["t"]]],[11,"clone_into","","",19,N],[11,"try_from","","",19,[[["u"]],["result"]]],[11,"borrow","","",19,[[["self"]],["t"]]],[11,"get_type_id","","",19,[[["self"]],["typeid"]]],[11,"try_into","","",19,[[["self"]],["result"]]],[11,"borrow_mut","","",19,[[["self"]],["t"]]],[11,"clone_box","","",19,N],[11,"from","","",20,[[["t"]],["t"]]],[11,"into","","",20,[[["self"]],["u"]]],[11,"to_owned","","",20,[[["self"]],["t"]]],[11,"clone_into","","",20,N],[11,"try_from","","",20,[[["u"]],["result"]]],[11,"borrow","","",20,[[["self"]],["t"]]],[11,"get_type_id","","",20,[[["self"]],["typeid"]]],[11,"try_into","","",20,[[["self"]],["result"]]],[11,"borrow_mut","","",20,[[["self"]],["t"]]],[11,"clone_box","","",20,N],[11,"send","holochain_net_connection::net_connection","send a message to the worker within this NetConnectionRelay instance",2,[[["self"],["protocol"]],["netresult"]]],[11,"send","holochain_net_connection::net_connection_thread","send a message to the worker within this NetConnectionThread instance",3,[[["self"],["protocol"]],["netresult"]]],[11,"eq","holochain_net_connection::protocol","",7,[[["self"],["protocol"]],["bool"]]],[11,"ne","","",7,[[["self"],["protocol"]],["bool"]]],[11,"eq","","",4,[[["self"],["namedbinarydata"]],["bool"]]],[11,"ne","","",4,[[["self"],["namedbinarydata"]],["bool"]]],[11,"eq","","",5,[[["self"],["pingdata"]],["bool"]]],[11,"ne","","",5,[[["self"],["pingdata"]],["bool"]]],[11,"eq","","",6,[[["self"],["pongdata"]],["bool"]]],[11,"ne","","",6,[[["self"],["pongdata"]],["bool"]]],[11,"eq","holochain_net_connection::protocol_wrapper","",8,[[["self"],["statedata"]],["bool"]]],[11,"ne","","",8,[[["self"],["statedata"]],["bool"]]],[11,"eq","","",9,[[["self"],["configdata"]],["bool"]]],[11,"ne","","",9,[[["self"],["configdata"]],["bool"]]],[11,"eq","","",10,[[["self"],["connectdata"]],["bool"]]],[11,"ne","","",10,[[["self"],["connectdata"]],["bool"]]],[11,"eq","","",11,[[["self"],["peerdata"]],["bool"]]],[11,"ne","","",11,[[["self"],["peerdata"]],["bool"]]],[11,"eq","","",12,[[["self"],["messagedata"]],["bool"]]],[11,"ne","","",12,[[["self"],["messagedata"]],["bool"]]],[11,"eq","","",13,[[["self"],["trackappdata"]],["bool"]]],[11,"ne","","",13,[[["self"],["trackappdata"]],["bool"]]],[11,"eq","","",14,[[["self"],["successresultdata"]],["bool"]]],[11,"ne","","",14,[[["self"],["successresultdata"]],["bool"]]],[11,"eq","","",15,[[["self"],["failureresultdata"]],["bool"]]],[11,"ne","","",15,[[["self"],["failureresultdata"]],["bool"]]],[11,"eq","","",16,[[["self"],["getdhtdata"]],["bool"]]],[11,"ne","","",16,[[["self"],["getdhtdata"]],["bool"]]],[11,"eq","","",17,[[["self"],["dhtdata"]],["bool"]]],[11,"ne","","",17,[[["self"],["dhtdata"]],["bool"]]],[11,"eq","","",18,[[["self"],["getdhtmetadata"]],["bool"]]],[11,"ne","","",18,[[["self"],["getdhtmetadata"]],["bool"]]],[11,"eq","","",19,[[["self"],["dhtmetadata"]],["bool"]]],[11,"ne","","",19,[[["self"],["dhtmetadata"]],["bool"]]],[11,"eq","","",20,[[["self"],["protocolwrapper"]],["bool"]]],[11,"ne","","",20,[[["self"],["protocolwrapper"]],["bool"]]],[11,"from","holochain_net_connection::protocol","",4,[[["protocol"]],["self"]]],[11,"from","","",4,[[["protocol"]],["self"]]],[11,"from","","",7,[[["namedbinarydata"]],["self"]]],[11,"from","","",7,[[["namedbinarydata"]],["self"]]],[11,"from","","",7,[[["str"]],["self"]]],[11,"from","","",7,[[["string"]],["self"]]],[11,"from","","",7,[[["protocolwrapper"]],["self"]]],[11,"from","","",7,[[["protocolwrapper"]],["self"]]],[11,"clone","","",7,[[["self"]],["protocol"]]],[11,"clone","","",4,[[["self"]],["namedbinarydata"]]],[11,"clone","","",5,[[["self"]],["pingdata"]]],[11,"clone","","",6,[[["self"]],["pongdata"]]],[11,"clone","holochain_net_connection::protocol_wrapper","",8,[[["self"]],["statedata"]]],[11,"clone","","",9,[[["self"]],["configdata"]]],[11,"clone","","",10,[[["self"]],["connectdata"]]],[11,"clone","","",11,[[["self"]],["peerdata"]]],[11,"clone","","",12,[[["self"]],["messagedata"]]],[11,"clone","","",13,[[["self"]],["trackappdata"]]],[11,"clone","","",14,[[["self"]],["successresultdata"]]],[11,"clone","","",15,[[["self"]],["failureresultdata"]]],[11,"clone","","",16,[[["self"]],["getdhtdata"]]],[11,"clone","","",17,[[["self"]],["dhtdata"]]],[11,"clone","","",18,[[["self"]],["getdhtmetadata"]]],[11,"clone","","",19,[[["self"]],["dhtmetadata"]]],[11,"clone","","",20,[[["self"]],["protocolwrapper"]]],[11,"fmt","holochain_net_connection::net_connection_thread","",3,[[["self"],["formatter"]],["result"]]],[11,"fmt","holochain_net_connection::protocol","",7,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",4,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",5,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",6,[[["self"],["formatter"]],["result"]]],[11,"fmt","holochain_net_connection::protocol_wrapper","",8,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",9,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",10,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",11,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",12,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",13,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",14,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",15,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",16,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",17,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",18,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",19,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",20,[[["self"],["formatter"]],["result"]]],[11,"try_from","","",8,[[["jsonstring"]],["result"]]],[11,"try_from","","",8,[[["jsonstring"]],["result"]]],[11,"try_from","","",9,[[["jsonstring"]],["result"]]],[11,"try_from","","",9,[[["jsonstring"]],["result"]]],[11,"try_from","","",10,[[["jsonstring"]],["result"]]],[11,"try_from","","",10,[[["jsonstring"]],["result"]]],[11,"try_from","","",11,[[["jsonstring"]],["result"]]],[11,"try_from","","",11,[[["jsonstring"]],["result"]]],[11,"try_from","","",12,[[["jsonstring"]],["result"]]],[11,"try_from","","",12,[[["jsonstring"]],["result"]]],[11,"try_from","","",13,[[["jsonstring"]],["result"]]],[11,"try_from","","",13,[[["jsonstring"]],["result"]]],[11,"try_from","","",14,[[["jsonstring"]],["result"]]],[11,"try_from","","",14,[[["jsonstring"]],["result"]]],[11,"try_from","","",15,[[["jsonstring"]],["result"]]],[11,"try_from","","",15,[[["jsonstring"]],["result"]]],[11,"try_from","","",16,[[["jsonstring"]],["result"]]],[11,"try_from","","",16,[[["jsonstring"]],["result"]]],[11,"try_from","","",17,[[["jsonstring"]],["result"]]],[11,"try_from","","",17,[[["jsonstring"]],["result"]]],[11,"try_from","","",18,[[["jsonstring"]],["result"]]],[11,"try_from","","",18,[[["jsonstring"]],["result"]]],[11,"try_from","","",19,[[["jsonstring"]],["result"]]],[11,"try_from","","",19,[[["jsonstring"]],["result"]]],[11,"try_from","","",20,[[["jsonstring"]],["result"]]],[11,"try_from","","",20,[[["jsonstring"]],["result"]]],[11,"try_from","","",20,[[["protocol"]],["result",["error"]]]],[11,"try_from","","",20,[[["protocol"]],["result",["error"]]]],[11,"deserialize","holochain_net_connection::protocol","",4,[[["__d"]],["result"]]],[11,"deserialize","","",5,[[["__d"]],["result"]]],[11,"deserialize","","",6,[[["__d"]],["result"]]],[11,"deserialize","holochain_net_connection::protocol_wrapper","",8,[[["__d"]],["result"]]],[11,"deserialize","","",9,[[["__d"]],["result"]]],[11,"deserialize","","",10,[[["__d"]],["result"]]],[11,"deserialize","","",11,[[["__d"]],["result"]]],[11,"deserialize","","",12,[[["__d"]],["result"]]],[11,"deserialize","","",13,[[["__d"]],["result"]]],[11,"deserialize","","",14,[[["__d"]],["result"]]],[11,"deserialize","","",15,[[["__d"]],["result"]]],[11,"deserialize","","",16,[[["__d"]],["result"]]],[11,"deserialize","","",17,[[["__d"]],["result"]]],[11,"deserialize","","",18,[[["__d"]],["result"]]],[11,"deserialize","","",19,[[["__d"]],["result"]]],[11,"deserialize","","",20,[[["__d"]],["result"]]],[11,"serialize","holochain_net_connection::protocol","",4,[[["self"],["__s"]],["result"]]],[11,"serialize","","",5,[[["self"],["__s"]],["result"]]],[11,"serialize","","",6,[[["self"],["__s"]],["result"]]],[11,"serialize","holochain_net_connection::protocol_wrapper","",8,[[["self"],["__s"]],["result"]]],[11,"serialize","","",9,[[["self"],["__s"]],["result"]]],[11,"serialize","","",10,[[["self"],["__s"]],["result"]]],[11,"serialize","","",11,[[["self"],["__s"]],["result"]]],[11,"serialize","","",12,[[["self"],["__s"]],["result"]]],[11,"serialize","","",13,[[["self"],["__s"]],["result"]]],[11,"serialize","","",14,[[["self"],["__s"]],["result"]]],[11,"serialize","","",15,[[["self"],["__s"]],["result"]]],[11,"serialize","","",16,[[["self"],["__s"]],["result"]]],[11,"serialize","","",17,[[["self"],["__s"]],["result"]]],[11,"serialize","","",18,[[["self"],["__s"]],["result"]]],[11,"serialize","","",19,[[["self"],["__s"]],["result"]]],[11,"serialize","","",20,[[["self"],["__s"]],["result"]]]],"paths":[[8,"NetConnection"],[8,"NetWorker"],[3,"NetConnectionRelay"],[3,"NetConnectionThread"],[3,"NamedBinaryData"],[3,"PingData"],[3,"PongData"],[4,"Protocol"],[3,"StateData"],[3,"ConfigData"],[3,"ConnectData"],[3,"PeerData"],[3,"MessageData"],[3,"TrackAppData"],[3,"SuccessResultData"],[3,"FailureResultData"],[3,"GetDhtData"],[3,"DhtData"],[3,"GetDhtMetaData"],[3,"DhtMetaData"],[4,"ProtocolWrapper"]]};
searchIndex["holochain_net_ipc"]={"doc":"Networking / P2P IPC Abstraction","items":[[0,"errors","holochain_net_ipc","This module holds net_ipc custom error types.",N,N],[4,"IpcError","holochain_net_ipc::errors","net_ipc-specific error types",N,N],[13,"MissingDataError","","Translate an Option<_> unwrap into a Result::Err",0,N],[13,"Timeout","","Socket timeout",0,N],[13,"GenericError","","Otherwise undefined error message",0,N],[12,"error","holochain_net_ipc::errors::IpcError","",0,N],[6,"Result","holochain_net_ipc::errors","Default result type for net_ipc modules that `use errors::*`.",N,N],[0,"context","holochain_net_ipc","This module uses lazy_static! to make the zmq::Context easier to work with Just make sure to call IpcClient::destroy_context() when ready",N,N],[3,"ZMQ_CTX","holochain_net_ipc::context","pseudo global for zmq::Context",N,N],[5,"socket","","Create a new zmq socket using the lazy_static! global",N,[[["sockettype"]],["result",["socket"]]]],[5,"destroy","","Destroy the lazy_static! global",N,[[],["result"]]],[0,"socket","holochain_net_ipc","This module is a thin wrapper around a ZMQ socket It allows us to easily mock it out for unit tests as well as manage context with lazy_static!",N,N],[3,"ZmqIpcSocket","holochain_net_ipc::socket","this is the concrete ZMQ implementation of the IpcSocket trait",N,N],[3,"TestStruct","","helper for working with mock sockets",N,N],[3,"MockIpcSocket","","This is a concrete implementation of the IpcSocket trait for use in testing",N,N],[5,"make_test_channels","","helper to create mock socket channels",N,[[],["result"]]],[8,"IpcSocket","","trait that allows zmq socket abstraction",N,N],[10,"new","","create a new socket",1,[[],["result",["box"]]]],[10,"close","","close an existing socket",1,[[["box"]],["result"]]],[10,"connect","","connect the socket to a remote end",1,[[["self"],["str"]],["result"]]],[10,"poll","","see if we have any messages waiting",1,[[["self"],["i64"]],["result",["bool"]]]],[10,"recv","","if we DO have messages, fetch them",1,[[["self"]],["result",["vec"]]]],[10,"send","","send data to the remote end of the socket",1,N],[11,"new_test","","",2,[[["teststruct"]],["result",["box"]]]],[0,"util","holochain_net_ipc","",N,N],[5,"get_millis","holochain_net_ipc::util","helper to get milliseconds since the unix epoch as an f64",N,[[],["f64"]]],[0,"ipc_client","holochain_net_ipc","implements a net_connection::NetWorker for messaging with an ipc p2p node",N,N],[3,"IpcClient","holochain_net_ipc::ipc_client","NetWorker for messaging with an ipc p2p node",N,N],[11,"new","","establish a new ipc connection for now, the api simplicity is worth blocking the thread on connection",3,[[["nethandler"],["box",["ipcsocket"]],["bool"]],["netresult"]]],[14,"bail_generic","holochain_net_ipc","Macro akin to `bail!()` but returns an IpcError::GenericError.",N,N],[11,"from","holochain_net_ipc::errors","",0,[[["t"]],["t"]]],[11,"into","","",0,[[["self"]],["u"]]],[11,"to_owned","","",0,[[["self"]],["t"]]],[11,"clone_into","","",0,N],[11,"to_string","","",0,[[["self"]],["string"]]],[11,"try_from","","",0,[[["u"]],["result"]]],[11,"borrow","","",0,[[["self"]],["t"]]],[11,"get_type_id","","",0,[[["self"]],["typeid"]]],[11,"try_into","","",0,[[["self"]],["result"]]],[11,"borrow_mut","","",0,[[["self"]],["t"]]],[11,"as_fail","","",0,[[["self"]],["fail"]]],[11,"clone_box","","",0,N],[11,"from","holochain_net_ipc::context","",4,[[["t"]],["t"]]],[11,"into","","",4,[[["self"]],["u"]]],[11,"try_from","","",4,[[["u"]],["result"]]],[11,"borrow","","",4,[[["self"]],["t"]]],[11,"get_type_id","","",4,[[["self"]],["typeid"]]],[11,"try_into","","",4,[[["self"]],["result"]]],[11,"borrow_mut","","",4,[[["self"]],["t"]]],[11,"from","holochain_net_ipc::socket","",5,[[["t"]],["t"]]],[11,"into","","",5,[[["self"]],["u"]]],[11,"try_from","","",5,[[["u"]],["result"]]],[11,"borrow","","",5,[[["self"]],["t"]]],[11,"get_type_id","","",5,[[["self"]],["typeid"]]],[11,"try_into","","",5,[[["self"]],["result"]]],[11,"borrow_mut","","",5,[[["self"]],["t"]]],[11,"from","","",6,[[["t"]],["t"]]],[11,"into","","",6,[[["self"]],["u"]]],[11,"try_from","","",6,[[["u"]],["result"]]],[11,"borrow","","",6,[[["self"]],["t"]]],[11,"get_type_id","","",6,[[["self"]],["typeid"]]],[11,"try_into","","",6,[[["self"]],["result"]]],[11,"borrow_mut","","",6,[[["self"]],["t"]]],[11,"from","","",2,[[["t"]],["t"]]],[11,"into","","",2,[[["self"]],["u"]]],[11,"try_from","","",2,[[["u"]],["result"]]],[11,"borrow","","",2,[[["self"]],["t"]]],[11,"get_type_id","","",2,[[["self"]],["typeid"]]],[11,"try_into","","",2,[[["self"]],["result"]]],[11,"borrow_mut","","",2,[[["self"]],["t"]]],[11,"from","holochain_net_ipc::ipc_client","",3,[[["t"]],["t"]]],[11,"into","","",3,[[["self"]],["u"]]],[11,"try_from","","",3,[[["u"]],["result"]]],[11,"borrow","","",3,[[["self"]],["t"]]],[11,"get_type_id","","",3,[[["self"]],["typeid"]]],[11,"try_into","","",3,[[["self"]],["result"]]],[11,"borrow_mut","","",3,[[["self"]],["t"]]],[11,"new","holochain_net_ipc::socket","",5,[[],["result",["box"]]]],[11,"close","","",5,[[["box"]],["result"]]],[11,"connect","","",5,[[["self"],["str"]],["result"]]],[11,"poll","","",5,[[["self"],["i64"]],["result",["bool"]]]],[11,"recv","","",5,[[["self"]],["result",["vec"]]]],[11,"send","","",5,N],[11,"new","","",2,[[],["result",["box"]]]],[11,"close","","",2,[[["box"]],["result"]]],[11,"connect","","",2,[[["self"],["str"]],["result"]]],[11,"poll","","",2,[[["self"],["i64"]],["result",["bool"]]]],[11,"recv","","",2,[[["self"]],["result",["vec"]]]],[11,"send","","",2,N],[11,"clone","holochain_net_ipc::errors","",0,[[["self"]],["ipcerror"]]],[11,"fmt","","",0,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",0,[[["self"],["formatter"]],["result"]]],[11,"deref","holochain_net_ipc::context","",4,[[["self"]],["mutex"]]],[11,"cause","holochain_net_ipc::errors","",0,[[["self"]],["option",["fail"]]]],[11,"backtrace","","",0,[[["self"]],["option",["backtrace"]]]],[11,"stop","holochain_net_ipc::ipc_client","stop the worker",3,[[["box"]],["netresult"]]],[11,"receive","","handle messages sent to us from holochain_net",3,[[["self"],["protocol"]],["netresult"]]],[11,"tick","","perform upkeep (like ping/pong messages) on the underlying ipc socket",3,[[["self"]],["netresult",["bool"]]]],[11,"initialize","holochain_net_ipc::context","",4,[[["self"]]]]],"paths":[[4,"IpcError"],[8,"IpcSocket"],[3,"MockIpcSocket"],[3,"IpcClient"],[3,"ZMQ_CTX"],[3,"ZmqIpcSocket"],[3,"TestStruct"]]};
searchIndex["holochain_test_bin"]={"doc":"","items":[],"paths":[]};
searchIndex["holochain_wasm_utils"]={"doc":"Library holding necessary code for the Ribosome  that is also useful for hdk-rust, or more generally for making rust code that the Ribosome can run. Must not have any dependency with any other Holochain crates.","items":[[0,"api_serialization","holochain_wasm_utils","ignore api_serialization because it is nothing but structs to hold serialization",N,N],[3,"ZomeFnCallArgs","holochain_wasm_utils::api_serialization","Struct for input data received when Zome API function call() is invoked",N,N],[12,"zome_name","","",0,N],[12,"cap_name","","",0,N],[12,"fn_name","","",0,N],[12,"fn_args","","",0,N],[3,"ZomeApiGlobals","","",N,N],[12,"dna_name","","",1,N],[12,"dna_hash","","",1,N],[12,"agent_id_str","","",1,N],[12,"agent_address","","",1,N],[12,"agent_initial_hash","","",1,N],[12,"agent_latest_hash","","",1,N],[0,"get_entry","","This module holds structs for all arguments and return types that get serialized and deserialized between core native and the WASM based ribosome.",N,N],[3,"GetEntryOptions","holochain_wasm_utils::api_serialization::get_entry","",N,N],[0,"get_links","holochain_wasm_utils::api_serialization","",N,N],[3,"GetLinksArgs","holochain_wasm_utils::api_serialization::get_links","",N,N],[12,"entry_address","","",2,N],[12,"tag","","",2,N],[3,"GetLinksResult","","",N,N],[11,"new","","",3,[[["vec",["address"]]],["getlinksresult"]]],[11,"addresses","","",3,[[["self"]],["vec"]]],[0,"link_entries","holochain_wasm_utils::api_serialization","",N,N],[3,"LinkEntriesArgs","holochain_wasm_utils::api_serialization::link_entries","",N,N],[12,"base","","",4,N],[12,"target","","",4,N],[12,"tag","","",4,N],[11,"to_link","","",4,[[["self"]],["link"]]],[0,"query","holochain_wasm_utils::api_serialization","",N,N],[3,"QueryArgs","holochain_wasm_utils::api_serialization::query","",N,N],[12,"entry_type_name","","",5,N],[12,"start","","",5,N],[12,"limit","","",5,N],[6,"QueryResult","","",N,N],[0,"validation","holochain_wasm_utils::api_serialization","",N,N],[3,"EntryValidationArgs","holochain_wasm_utils::api_serialization::validation","",N,N],[12,"entry_type","","",6,N],[12,"entry","","",6,N],[12,"validation_data","","",6,N],[3,"LinkValidationPackageArgs","","",N,N],[12,"entry_type","","",7,N],[12,"tag","","",7,N],[12,"direction","","",7,N],[3,"LinkValidationArgs","","",N,N],[12,"entry_type","","",8,N],[12,"link","","",8,N],[12,"direction","","",8,N],[12,"validation_data","","",8,N],[4,"LinkDirection","","",N,N],[13,"To","","",9,N],[13,"From","","",9,N],[0,"macros","holochain_wasm_utils","",N,N],[0,"memory_allocation","","",N,N],[3,"SinglePageAllocation","holochain_wasm_utils::memory_allocation","SinglePageAllocation is a memory allocation garanteed to fit in a WASM 64KiB Memory Page",N,N],[3,"SinglePageStack","","Struct for managing a WASM 64KiB memory page as a stack",N,N],[5,"u32_high_bits","","returns the u16 high bits from a u32",N,[[["u32"]],["u16"]]],[5,"u32_low_bits","","returns the u16 low bits from a u32 by doing a lossy cast",N,[[["u32"]],["u16"]]],[5,"u32_split_bits","","splits the high and low bits of u32 into a tuple of u16, for destructuring convenience",N,N],[5,"u32_merge_bits","","merges 2x u16 into a single u32",N,[[["u16"],["u16"]],["u32"]]],[5,"decode_encoded_allocation","","",N,[[["u32"]],["result",["singlepageallocation","ribosomereturncode"]]]],[17,"U16_MAX","","",N,N],[11,"new","","",10,[[["u16"],["u16"]],["result",["ribosomeerrorcode"]]]],[11,"from_encoded_allocation","","An Encoded Allocation is a u32 where 'offset' is first 16-bits and 'length' last 16-bits A valid allocation must not have a length of zero An Encoded Allocation with an offset but no length is actually an encoding of an ErrorCode",10,[[["u32"]],["result",["ribosomeerrorcode"]]]],[11,"encode","","returns a single u32 value encoding both the u16 offset and length values",10,[[["self"]],["u32"]]],[11,"offset","","",10,[[["self"]],["u16"]]],[11,"length","","",10,[[["self"]],["u16"]]],[11,"new","","",11,[[["singlepageallocation"]],["self"]]],[11,"from_encoded_allocation","","Create a SinglePageStack from a valid encoded allocation",11,[[["u32"]],["result",["ribosomeerrorcode"]]]],[11,"allocate","","",11,[[["self"],["u16"]],["u16"]]],[11,"deallocate","","",11,[[["self"],["singlepageallocation"]],["result"]]],[11,"top","","",11,[[["self"]],["u16"]]],[0,"memory_serialization","holochain_wasm_utils","",N,N],[5,"store_string","holochain_wasm_utils::memory_serialization","Write a string in wasm memory according to stack state.",N,[[["singlepagestack"],["str"]],["result",["singlepageallocation","ribosomeerrorcode"]]]],[5,"store_string_into_encoded_allocation","","",N,[[["singlepagestack"],["str"]],["i32"]]],[5,"load_string","","Retrieve a stored string from an encoded allocation. Return error code if encoded_allocation is invalid.",N,[[["u32"]],["result",["string","ribosomeerrorcode"]]]],[5,"store_as_json","","Write a data struct as a json string in wasm memory according to stack state.",N,[[["singlepagestack"],["j"]],["result",["singlepageallocation","ribosomeerrorcode"]]]],[5,"store_as_json_into_encoded_allocation","","",N,[[["singlepagestack"],["j"]],["i32"]]],[5,"load_json","","Retrieve a stored data struct from an encoded allocation. Return error string if encoded_allocation is invalid.",N,[[["u32"]],["result",["holochainerror"]]]],[5,"load_json_from_raw","","Convert a json string stored in wasm memory into a specified struct If json deserialization of custom struct failed, tries to deserialize a CoreError struct. If that also failed, tries to load a string directly, since we are expecting an error string at this stage.",N,N],[14,"zome_assert","holochain_wasm_utils","Macro for creating a RibosomeErrorCode as a RuntimeValue Result-Option on the spot Will panic! if out or memory or other serialization error occured.",N,N],[14,"ribosome_success","","",N,N],[14,"ribosome_error_code","","Macro for creating a RibosomeErrorCode as a RuntimeValue Result-Option on the spot",N,N],[14,"core_error","","Macro for creating a CoreError from a HolochainError on the spot with file!() and line!()",N,N],[14,"core_error_generic","","Macro for creating a generic CoreError on the spot with file!() and line!()",N,N],[11,"from","holochain_wasm_utils::api_serialization","",0,[[["t"]],["t"]]],[11,"into","","",0,[[["self"]],["u"]]],[11,"to_owned","","",0,[[["self"]],["t"]]],[11,"clone_into","","",0,N],[11,"try_from","","",0,[[["u"]],["result"]]],[11,"borrow","","",0,[[["self"]],["t"]]],[11,"get_type_id","","",0,[[["self"]],["typeid"]]],[11,"try_into","","",0,[[["self"]],["result"]]],[11,"borrow_mut","","",0,[[["self"]],["t"]]],[11,"equivalent","","",0,[[["self"],["k"]],["bool"]]],[11,"clone_box","","",0,N],[11,"from","","",1,[[["t"]],["t"]]],[11,"into","","",1,[[["self"]],["u"]]],[11,"to_owned","","",1,[[["self"]],["t"]]],[11,"clone_into","","",1,N],[11,"try_from","","",1,[[["u"]],["result"]]],[11,"borrow","","",1,[[["self"]],["t"]]],[11,"get_type_id","","",1,[[["self"]],["typeid"]]],[11,"try_into","","",1,[[["self"]],["result"]]],[11,"borrow_mut","","",1,[[["self"]],["t"]]],[11,"clone_box","","",1,N],[11,"from","holochain_wasm_utils::api_serialization::get_entry","",12,[[["t"]],["t"]]],[11,"into","","",12,[[["self"]],["u"]]],[11,"try_from","","",12,[[["u"]],["result"]]],[11,"borrow","","",12,[[["self"]],["t"]]],[11,"get_type_id","","",12,[[["self"]],["typeid"]]],[11,"try_into","","",12,[[["self"]],["result"]]],[11,"borrow_mut","","",12,[[["self"]],["t"]]],[11,"from","holochain_wasm_utils::api_serialization::get_links","",2,[[["t"]],["t"]]],[11,"into","","",2,[[["self"]],["u"]]],[11,"to_owned","","",2,[[["self"]],["t"]]],[11,"clone_into","","",2,N],[11,"try_from","","",2,[[["u"]],["result"]]],[11,"borrow","","",2,[[["self"]],["t"]]],[11,"get_type_id","","",2,[[["self"]],["typeid"]]],[11,"try_into","","",2,[[["self"]],["result"]]],[11,"borrow_mut","","",2,[[["self"]],["t"]]],[11,"equivalent","","",2,[[["self"],["k"]],["bool"]]],[11,"clone_box","","",2,N],[11,"from","","",3,[[["t"]],["t"]]],[11,"into","","",3,[[["self"]],["u"]]],[11,"try_from","","",3,[[["u"]],["result"]]],[11,"borrow","","",3,[[["self"]],["t"]]],[11,"get_type_id","","",3,[[["self"]],["typeid"]]],[11,"try_into","","",3,[[["self"]],["result"]]],[11,"borrow_mut","","",3,[[["self"]],["t"]]],[11,"from","holochain_wasm_utils::api_serialization::link_entries","",4,[[["t"]],["t"]]],[11,"into","","",4,[[["self"]],["u"]]],[11,"try_from","","",4,[[["u"]],["result"]]],[11,"borrow","","",4,[[["self"]],["t"]]],[11,"get_type_id","","",4,[[["self"]],["typeid"]]],[11,"try_into","","",4,[[["self"]],["result"]]],[11,"borrow_mut","","",4,[[["self"]],["t"]]],[11,"from","holochain_wasm_utils::api_serialization::query","",5,[[["t"]],["t"]]],[11,"into","","",5,[[["self"]],["u"]]],[11,"try_from","","",5,[[["u"]],["result"]]],[11,"borrow","","",5,[[["self"]],["t"]]],[11,"get_type_id","","",5,[[["self"]],["typeid"]]],[11,"try_into","","",5,[[["self"]],["result"]]],[11,"borrow_mut","","",5,[[["self"]],["t"]]],[11,"from","holochain_wasm_utils::api_serialization::validation","",6,[[["t"]],["t"]]],[11,"into","","",6,[[["self"]],["u"]]],[11,"try_from","","",6,[[["u"]],["result"]]],[11,"borrow","","",6,[[["self"]],["t"]]],[11,"get_type_id","","",6,[[["self"]],["typeid"]]],[11,"try_into","","",6,[[["self"]],["result"]]],[11,"borrow_mut","","",6,[[["self"]],["t"]]],[11,"from","","",7,[[["t"]],["t"]]],[11,"into","","",7,[[["self"]],["u"]]],[11,"to_owned","","",7,[[["self"]],["t"]]],[11,"clone_into","","",7,N],[11,"try_from","","",7,[[["u"]],["result"]]],[11,"borrow","","",7,[[["self"]],["t"]]],[11,"get_type_id","","",7,[[["self"]],["typeid"]]],[11,"try_into","","",7,[[["self"]],["result"]]],[11,"borrow_mut","","",7,[[["self"]],["t"]]],[11,"clone_box","","",7,N],[11,"from","","",8,[[["t"]],["t"]]],[11,"into","","",8,[[["self"]],["u"]]],[11,"to_owned","","",8,[[["self"]],["t"]]],[11,"clone_into","","",8,N],[11,"try_from","","",8,[[["u"]],["result"]]],[11,"borrow","","",8,[[["self"]],["t"]]],[11,"get_type_id","","",8,[[["self"]],["typeid"]]],[11,"try_into","","",8,[[["self"]],["result"]]],[11,"borrow_mut","","",8,[[["self"]],["t"]]],[11,"clone_box","","",8,N],[11,"from","","",9,[[["t"]],["t"]]],[11,"into","","",9,[[["self"]],["u"]]],[11,"to_owned","","",9,[[["self"]],["t"]]],[11,"clone_into","","",9,N],[11,"try_from","","",9,[[["u"]],["result"]]],[11,"borrow","","",9,[[["self"]],["t"]]],[11,"get_type_id","","",9,[[["self"]],["typeid"]]],[11,"try_into","","",9,[[["self"]],["result"]]],[11,"borrow_mut","","",9,[[["self"]],["t"]]],[11,"clone_box","","",9,N],[11,"from","holochain_wasm_utils::memory_allocation","",10,[[["t"]],["t"]]],[11,"into","","",10,[[["self"]],["u"]]],[11,"to_owned","","",10,[[["self"]],["t"]]],[11,"clone_into","","",10,N],[11,"try_from","","",10,[[["u"]],["result"]]],[11,"borrow","","",10,[[["self"]],["t"]]],[11,"get_type_id","","",10,[[["self"]],["typeid"]]],[11,"try_into","","",10,[[["self"]],["result"]]],[11,"borrow_mut","","",10,[[["self"]],["t"]]],[11,"clone_box","","",10,N],[11,"from","","",11,[[["t"]],["t"]]],[11,"into","","",11,[[["self"]],["u"]]],[11,"to_owned","","",11,[[["self"]],["t"]]],[11,"clone_into","","",11,N],[11,"try_from","","",11,[[["u"]],["result"]]],[11,"borrow","","",11,[[["self"]],["t"]]],[11,"get_type_id","","",11,[[["self"]],["typeid"]]],[11,"try_into","","",11,[[["self"]],["result"]]],[11,"borrow_mut","","",11,[[["self"]],["t"]]],[11,"clone_box","","",11,N],[11,"eq","holochain_wasm_utils::api_serialization","",0,[[["self"],["zomefncallargs"]],["bool"]]],[11,"ne","","",0,[[["self"],["zomefncallargs"]],["bool"]]],[11,"eq","holochain_wasm_utils::api_serialization::get_links","",2,[[["self"],["getlinksargs"]],["bool"]]],[11,"ne","","",2,[[["self"],["getlinksargs"]],["bool"]]],[11,"eq","holochain_wasm_utils::api_serialization::validation","",9,[[["self"],["linkdirection"]],["bool"]]],[11,"clone","holochain_wasm_utils::api_serialization","",0,[[["self"]],["zomefncallargs"]]],[11,"clone","holochain_wasm_utils::api_serialization::get_links","",2,[[["self"]],["getlinksargs"]]],[11,"clone","holochain_wasm_utils::api_serialization::validation","",9,[[["self"]],["linkdirection"]]],[11,"clone","","",7,[[["self"]],["linkvalidationpackageargs"]]],[11,"clone","","",8,[[["self"]],["linkvalidationargs"]]],[11,"clone","holochain_wasm_utils::api_serialization","",1,[[["self"]],["zomeapiglobals"]]],[11,"clone","holochain_wasm_utils::memory_allocation","",10,[[["self"]],["singlepageallocation"]]],[11,"clone","","",11,[[["self"]],["singlepagestack"]]],[11,"default","holochain_wasm_utils::api_serialization","",0,[[],["zomefncallargs"]]],[11,"default","holochain_wasm_utils::api_serialization::get_links","",2,[[],["getlinksargs"]]],[11,"default","holochain_wasm_utils::api_serialization::link_entries","",4,[[],["linkentriesargs"]]],[11,"default","holochain_wasm_utils::api_serialization::query","",5,[[],["queryargs"]]],[11,"default","holochain_wasm_utils::memory_allocation","",11,[[],["singlepagestack"]]],[11,"fmt","holochain_wasm_utils::api_serialization","",0,[[["self"],["formatter"]],["result"]]],[11,"fmt","holochain_wasm_utils::api_serialization::get_entry","",12,[[["self"],["formatter"]],["result"]]],[11,"fmt","holochain_wasm_utils::api_serialization::get_links","",2,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",3,[[["self"],["formatter"]],["result"]]],[11,"fmt","holochain_wasm_utils::api_serialization::link_entries","",4,[[["self"],["formatter"]],["result"]]],[11,"fmt","holochain_wasm_utils::api_serialization::query","",5,[[["self"],["formatter"]],["result"]]],[11,"fmt","holochain_wasm_utils::api_serialization::validation","",6,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",9,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",7,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",8,[[["self"],["formatter"]],["result"]]],[11,"fmt","holochain_wasm_utils::api_serialization","",1,[[["self"],["formatter"]],["result"]]],[11,"fmt","holochain_wasm_utils::memory_allocation","",10,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",11,[[["self"],["formatter"]],["result"]]],[11,"try_from","holochain_wasm_utils::api_serialization","",0,[[["jsonstring"]],["result"]]],[11,"try_from","","",0,[[["jsonstring"]],["result"]]],[11,"try_from","holochain_wasm_utils::api_serialization::get_links","",2,[[["jsonstring"]],["result"]]],[11,"try_from","","",2,[[["jsonstring"]],["result"]]],[11,"try_from","","",3,[[["jsonstring"]],["result"]]],[11,"try_from","","",3,[[["jsonstring"]],["result"]]],[11,"try_from","holochain_wasm_utils::api_serialization::link_entries","",4,[[["jsonstring"]],["result"]]],[11,"try_from","","",4,[[["jsonstring"]],["result"]]],[11,"try_from","holochain_wasm_utils::api_serialization::query","",5,[[["jsonstring"]],["result"]]],[11,"try_from","","",5,[[["jsonstring"]],["result"]]],[11,"try_from","holochain_wasm_utils::api_serialization::validation","",6,[[["jsonstring"]],["result"]]],[11,"try_from","","",6,[[["jsonstring"]],["result"]]],[11,"try_from","","",9,[[["jsonstring"]],["result"]]],[11,"try_from","","",9,[[["jsonstring"]],["result"]]],[11,"try_from","","",7,[[["jsonstring"]],["result"]]],[11,"try_from","","",7,[[["jsonstring"]],["result"]]],[11,"try_from","","",8,[[["jsonstring"]],["result"]]],[11,"try_from","","",8,[[["jsonstring"]],["result"]]],[11,"try_from","holochain_wasm_utils::api_serialization","",1,[[["jsonstring"]],["result"]]],[11,"try_from","","",1,[[["jsonstring"]],["result"]]],[11,"hash","","",0,N],[11,"hash","holochain_wasm_utils::api_serialization::get_links","",2,N],[11,"serialize","holochain_wasm_utils::api_serialization","",0,[[["self"],["__s"]],["result"]]],[11,"serialize","holochain_wasm_utils::api_serialization::get_entry","",12,[[["self"],["__s"]],["result"]]],[11,"serialize","holochain_wasm_utils::api_serialization::get_links","",2,[[["self"],["__s"]],["result"]]],[11,"serialize","","",3,[[["self"],["__s"]],["result"]]],[11,"serialize","holochain_wasm_utils::api_serialization::link_entries","",4,[[["self"],["__s"]],["result"]]],[11,"serialize","holochain_wasm_utils::api_serialization::query","",5,[[["self"],["__s"]],["result"]]],[11,"serialize","holochain_wasm_utils::api_serialization::validation","",6,[[["self"],["__s"]],["result"]]],[11,"serialize","","",9,[[["self"],["__s"]],["result"]]],[11,"serialize","","",7,[[["self"],["__s"]],["result"]]],[11,"serialize","","",8,[[["self"],["__s"]],["result"]]],[11,"serialize","holochain_wasm_utils::api_serialization","",1,[[["self"],["__s"]],["result"]]],[11,"deserialize","","",0,[[["__d"]],["result"]]],[11,"deserialize","holochain_wasm_utils::api_serialization::get_entry","",12,[[["__d"]],["result"]]],[11,"deserialize","holochain_wasm_utils::api_serialization::get_links","",2,[[["__d"]],["result"]]],[11,"deserialize","","",3,[[["__d"]],["result"]]],[11,"deserialize","holochain_wasm_utils::api_serialization::link_entries","",4,[[["__d"]],["result"]]],[11,"deserialize","holochain_wasm_utils::api_serialization::query","",5,[[["__d"]],["result"]]],[11,"deserialize","holochain_wasm_utils::api_serialization::validation","",6,[[["__d"]],["result"]]],[11,"deserialize","","",9,[[["__d"]],["result"]]],[11,"deserialize","","",7,[[["__d"]],["result"]]],[11,"deserialize","","",8,[[["__d"]],["result"]]],[11,"deserialize","holochain_wasm_utils::api_serialization","",1,[[["__d"]],["result"]]]],"paths":[[3,"ZomeFnCallArgs"],[3,"ZomeApiGlobals"],[3,"GetLinksArgs"],[3,"GetLinksResult"],[3,"LinkEntriesArgs"],[3,"QueryArgs"],[3,"EntryValidationArgs"],[3,"LinkValidationPackageArgs"],[3,"LinkValidationArgs"],[4,"LinkDirection"],[3,"SinglePageAllocation"],[3,"SinglePageStack"],[3,"GetEntryOptions"]]};
searchIndex["test_bin_ipc"]={"doc":"","items":[],"paths":[]};
searchIndex["test_bin_mock_net"]={"doc":"","items":[],"paths":[]};
initSearch(searchIndex);
