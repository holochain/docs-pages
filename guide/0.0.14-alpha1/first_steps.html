<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Build A To-Do App! - The Holochain Guidebook</title>
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body class="light">
        <!-- Provide site root to javascript -->
        <script type="text/javascript">var path_to_root = "";</script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = 'light'; }
            document.body.className = theme;
            document.querySelector('html').className = theme + ' js';
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <ol class="chapter"><li><a href="welcome.html"><strong aria-hidden="true">1.</strong> Welcome</a></li><li><ol class="section"><li><a href="overview.html"><strong aria-hidden="true">1.1.</strong> Overview</a></li><li><a href="how_to_contribute.html"><strong aria-hidden="true">1.2.</strong> How to contribute</a></li></ol></li><li><a href="planning_a_dapp.html"><strong aria-hidden="true">2.</strong> Planning a dApp</a></li><li><a href="building_apps.html"><strong aria-hidden="true">3.</strong> Building Holochain Apps: Intro</a></li><li><ol class="section"><li><a href="intro_to_dna_config.html"><strong aria-hidden="true">3.1.</strong> Intro to DNA: Configuration</a></li><li><a href="intro_to_dna_code.html"><strong aria-hidden="true">3.2.</strong> Intro to DNA: Code</a></li><li><a href="intro_to_command_line_tools.html"><strong aria-hidden="true">3.3.</strong> Intro to Command Line Tools</a></li><li><a href="new_project.html"><strong aria-hidden="true">3.4.</strong> Create A New Project</a></li><li><a href="project_source_folders.html"><strong aria-hidden="true">3.5.</strong> Project Source Folders</a></li><li><a href="configuring_an_app.html"><strong aria-hidden="true">3.6.</strong> Configuring an App</a></li><li><a href="zome/rust.html"><strong aria-hidden="true">3.7.</strong> Writing in Rust</a></li><li><a href="zome/assemblyscript.html"><strong aria-hidden="true">3.8.</strong> Writing in Assemblyscript</a></li><li><a href="zome/intro_to_webassembly.html"><strong aria-hidden="true">3.9.</strong> Intro to WebAssembly</a></li><li><a href="alpha_migrate.html"><strong aria-hidden="true">3.10.</strong> Updating from Proto to Rust</a></li><li><a href="built_with_holochain.html"><strong aria-hidden="true">3.11.</strong> Built With Holochain</a></li><li><a href="building_for_different_platforms.html"><strong aria-hidden="true">3.12.</strong> Building for Different Platforms</a></li></ol></li><li><a href="zome/welcome.html"><strong aria-hidden="true">4.</strong> Building Holochain Apps: Zome Code</a></li><li><ol class="section"><li><a href="first_steps.html" class="active"><strong aria-hidden="true">4.1.</strong> Build A To-Do App!</a></li><li><a href="zome/adding_a_zome.html"><strong aria-hidden="true">4.2.</strong> Adding a Zome</a></li><li><a href="zome/intro_to_hdk.html"><strong aria-hidden="true">4.3.</strong> Intro to HDK</a></li><li><a href="zome/define_zome.html"><strong aria-hidden="true">4.4.</strong> Intro to Zome Definition</a></li><li><a href="zome/entry_type_definitions.html"><strong aria-hidden="true">4.5.</strong> App Entry Type Definitions</a></li><li><a href="zome/genesis.html"><strong aria-hidden="true">4.6.</strong> Genesis</a></li><li><a href="zome/zome_functions.html"><strong aria-hidden="true">4.7.</strong> Zome Functions</a></li><li><a href="zome/capabilities.html"><strong aria-hidden="true">4.8.</strong> Capabilities</a></li><li><a href="zome/read_and_write.html"><strong aria-hidden="true">4.9.</strong> (E) Read &amp; Write Data Operations</a></li><li><a href="zome/entry_validation.html"><strong aria-hidden="true">4.10.</strong> (E) Entry Validation</a></li><li><a href="zome/linking.html"><strong aria-hidden="true">4.11.</strong> (E) Linking</a></li><li><a href="zome/node_to_node_messages.html"><strong aria-hidden="true">4.12.</strong> (E) Node to Node Messaging</a></li><li><a href="zome/calling_other_zomes.html"><strong aria-hidden="true">4.13.</strong> (E) Calling Other Zomes</a></li><li><a href="zome/crypto.html"><strong aria-hidden="true">4.14.</strong> Crypto Functions</a></li><li><a href="zome/bundling.html"><strong aria-hidden="true">4.15.</strong> (E) Bundling</a></li><li><a href="zome/emitting_signals.html"><strong aria-hidden="true">4.16.</strong> (E) Emitting Signals</a></li><li><a href="zome/dna_variables.html"><strong aria-hidden="true">4.17.</strong> API DNA Variables</a></li><li><a href="zome/api_functions.html"><strong aria-hidden="true">4.18.</strong> List of API Functions</a></li></ol></li><li><a href="packaging.html"><strong aria-hidden="true">5.</strong> Building Holochain Apps: Packaging</a></li><li><ol class="section"><li><a href="build_files.html"><strong aria-hidden="true">5.1.</strong> .hcbuild Files</a></li><li><a href="hcignore_files.html"><strong aria-hidden="true">5.2.</strong> .hcignore Files</a></li></ol></li><li><a href="intro_to_testing.html"><strong aria-hidden="true">6.</strong> Building Holochain Apps: Testing</a></li><li><ol class="section"><li><a href="running_tests.html"><strong aria-hidden="true">6.1.</strong> Running Tests</a></li><li><a href="intro_to_holochain_nodejs.html"><strong aria-hidden="true">6.2.</strong> Intro to holochain-nodejs</a></li><li><a href="testing_configuration.html"><strong aria-hidden="true">6.3.</strong> Configuration</a></li><li><ol class="section"><li><a href="configuration_alternatives.html"><strong aria-hidden="true">6.3.1.</strong> Configuration Alternatives</a></li></ol></li><li><a href="scenario_testing.html"><strong aria-hidden="true">6.4.</strong> Scenario Testing</a></li><li><ol class="section"><li><a href="scenario_testing_setup.html"><strong aria-hidden="true">6.4.1.</strong> Setup</a></li><li><a href="scenario_testing_running_tape.html"><strong aria-hidden="true">6.4.2.</strong> Running With Tape</a></li><li><a href="other_test_harnesses.html"><strong aria-hidden="true">6.4.3.</strong> Other Test Harnesses</a></li></ol></li><li><a href="nodejs_dna_instances.html"><strong aria-hidden="true">6.5.</strong> DNA Instances</a></li><li><ol class="section"><li><a href="nodejs_calling_zome_functions.html"><strong aria-hidden="true">6.5.1.</strong> Calling Zome Functions</a></li><li><a href="handling_async.html"><strong aria-hidden="true">6.5.2.</strong> Handle Network Asynchronicity</a></li></ol></li><li><a href="testing_checking_results.html"><strong aria-hidden="true">6.6.</strong> (E) Checking Results</a></li><li><a href="managing_the_conductor.html"><strong aria-hidden="true">6.7.</strong> Manually Manage the Conductor</a></li><li><a href="access_instance_info.html"><strong aria-hidden="true">6.8.</strong> Access Instance Info</a></li></ol></li><li><a href="conductors.html"><strong aria-hidden="true">7.</strong> Running Holochain Apps: Conductors</a></li><li><ol class="section"><li><a href="development_conductor.html"><strong aria-hidden="true">7.1.</strong> Development Conductor</a></li><li><ol class="section"><li><a href="hc_configuring_networking.html"><strong aria-hidden="true">7.1.1.</strong> Configuring Networking</a></li></ol></li><li><a href="production_conductor.html"><strong aria-hidden="true">7.2.</strong> Production Conductor</a></li><li><ol class="section"><li><a href="intro_to_toml_config.html"><strong aria-hidden="true">7.2.1.</strong> Intro to TOML Config Files</a></li><li><a href="conductor_agents.html"><strong aria-hidden="true">7.2.2.</strong> Agents</a></li><li><a href="conductor_dnas.html"><strong aria-hidden="true">7.2.3.</strong> DNAs</a></li><li><a href="conductor_instances.html"><strong aria-hidden="true">7.2.4.</strong> Instances</a></li><li><a href="conductor_interfaces.html"><strong aria-hidden="true">7.2.5.</strong> Interfaces</a></li><li><a href="conductor_bridges.html"><strong aria-hidden="true">7.2.6.</strong> Bridges</a></li><li><a href="conductor_ui_bundles.html"><strong aria-hidden="true">7.2.7.</strong> UI Bundles</a></li><li><a href="conductor_ui_interfaces.html"><strong aria-hidden="true">7.2.8.</strong> UI Interfaces</a></li><li><a href="conductor_logging.html"><strong aria-hidden="true">7.2.9.</strong> Logging</a></li><li><a href="conductor_networking.html"><strong aria-hidden="true">7.2.10.</strong> Networking</a></li><li><a href="conductor_persistence_dir.html"><strong aria-hidden="true">7.2.11.</strong> Persistence Directory</a></li></ol></li><li><a href="json_rpc_interfaces.html"><strong aria-hidden="true">7.3.</strong> Intro to JSON-RPC Interfaces</a></li><li><a href="conductor_json_rpc_api.html"><strong aria-hidden="true">7.4.</strong> Conductor JSON-RPC API</a></li><li><ol class="section"><li><a href="json_rpc_http.html"><strong aria-hidden="true">7.4.1.</strong> HTTP</a></li><li><a href="json_rpc_websockets.html"><strong aria-hidden="true">7.4.2.</strong> WebSockets</a></li></ol></li><li><a href="conductor_admin.html"><strong aria-hidden="true">7.5.</strong> Conductor Admin</a></li></ol></li><li><a href="apps_user_interfaces.html"><strong aria-hidden="true">8.</strong> Building Holochain Apps: User Interfaces</a></li><li><a href="bridging.html"><strong aria-hidden="true">9.</strong> Building Holochain Apps: Bridging</a></li><li><a href="live_hc_apps.html"><strong aria-hidden="true">10.</strong> (E) Going Live with Holochain Apps</a></li><li><ol class="section"><li><a href="creating_versioned_releases.html"><strong aria-hidden="true">10.1.</strong> (E) Creating Versioned Releases</a></li></ol></li><li><a href="apps_advanced_topics.html"><strong aria-hidden="true">11.</strong> (E) Building Holochain Apps: Advanced Topics</a></li><li><ol class="section"><li><a href="json_string.html"><strong aria-hidden="true">11.1.</strong> Understanding JsonString</a></li><li><a href="building_for_android.html"><strong aria-hidden="true">11.2.</strong> Building For Android</a></li></ol></li><li><a href="extending_holochain.html"><strong aria-hidden="true">12.</strong> (E) Extending Holochain</a></li><li><ol class="section"><li><a href="embedding_holochain.html"><strong aria-hidden="true">12.1.</strong> (E) Embedding Holochain</a></li><li><ol class="section"><li><a href="core_api.html"><strong aria-hidden="true">12.1.1.</strong> (E) Core API</a></li></ol></li><li><a href="dpki.html"><strong aria-hidden="true">12.2.</strong> Key Management (DPKI)</a></li><li><a href="naming_conventions.html"><strong aria-hidden="true">12.3.</strong> Naming conventions</a></li><li><a href="writing_development_kit.html"><strong aria-hidden="true">12.4.</strong> Writing a Development Kit (HDK)</a></li><li><a href="zome/implementation.html"><strong aria-hidden="true">12.5.</strong> Implementing Zome API functions</a></li><li><a href="state_actions.html"><strong aria-hidden="true">12.6.</strong> Redux Architecture</a></li><li><ol class="section"><li><a href="state/actions.html"><strong aria-hidden="true">12.6.1.</strong> State actions</a></li></ol></li><li><a href="state/actors.html"><strong aria-hidden="true">12.7.</strong> State actors</a></li></ol></li><li><a href="faq.html"><strong aria-hidden="true">13.</strong> FAQ</a></li><li><a href="glossary.html"><strong aria-hidden="true">14.</strong> (E) Glossary</a></li><li><ol class="section"><li><a href="agent.html"><strong aria-hidden="true">14.1.</strong> (E) Agent</a></li><li><a href="keys.html"><strong aria-hidden="true">14.2.</strong> (E) Keys</a></li><li><a href="dna.html"><strong aria-hidden="true">14.3.</strong> (E) DNA</a></li><li><a href="zome.html"><strong aria-hidden="true">14.4.</strong> (E) Zome</a></li><li><a href="source_chain.html"><strong aria-hidden="true">14.5.</strong> (E) Source Chain</a></li><li><a href="distributed_hash_table.html"><strong aria-hidden="true">14.6.</strong> Distributed Hash Table</a></li></ol></li></ol>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar" class="menu-bar">
                    <div id="menu-bar-sticky-container">
                        <div class="left-buttons">
                            <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                                <i class="fa fa-bars"></i>
                            </button>
                            <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                                <i class="fa fa-paint-brush"></i>
                            </button>
                            <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                                <li role="none"><button role="menuitem" class="theme" id="light">Light <span class="default">(default)</span></button></li>
                                <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                            </ul>
                            
                            <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                                <i class="fa fa-search"></i>
                            </button>
                            
                            <a href="https://github.com/holochain/holochain-rust/edit/develop/doc/holochain_101/src/first_steps.md">
                                <i class="fa fa-edit"></i>
                            </a>
                        </div>

                        <h1 class="menu-title">The Holochain Guidebook</h1>

                        <div class="right-buttons">
                            <a href="print.html" title="Print this book" aria-label="Print this book">
                                <i id="print-button" class="fa fa-print"></i>
                            </a>
                        </div>
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <a class="header" href="#first-steps-writing-holochain-happs-with-rust" id="first-steps-writing-holochain-happs-with-rust"><h1>First steps writing Holochain hApps with Rust</h1></a>
<hr />
<p>This tutorial builds for the 0.0.9-alpha release but as the API and HDK are changing it will likely fail under newer releases.</p>
<hr />
<p>Holochain hApps are made of compiled WebAssembly that encodes the rules of the hApp, the data it can store and how users will interact with it. This means that <a href="https://github.com/appcypher/awesome-wasm-langs">any language that can compile to WebAssembly</a> can one day be used for Holochain.</p>
<p>Writing WebAssembly that complies with the Holochain runtime can be tricky. To make development as streamlined as possible the core team has been developing a Holochain-dev-kit (HDK) for the first supported language, Rust! In the near future the community is encouraged to develop an HDK for their language of choice.</p>
<p>In this article we will walk through the steps of creating a simple hApp using Rust.</p>
<a class="header" href="#requirements" id="requirements"><h2>Requirements</h2></a>
<p>First step is to download the appropriate <a href="https://github.com/holochain/holochain-rust/releases">dev preview release</a> for your OS. If you decide to build the latest version from source, be warned that the API is undergoing rapid change, so some of the steps in this article may not work. The release contains the binary for the holochain developer command line tool, <code>hc</code>, which is used to generate a skeleton app, run tests and build the app package. Follow the installations on <a href="https://developer.holochain.org/start.html">this page</a> to install the required dependencies.</p>
<p>Ensure that <code>hc</code> is available on your path. If you instead decide to <a href="https://developer.holochain.org/start.html">build from source</a> cargo will ensure the binaries are on your path automatically.</p>
<p>If you want to jump ahead to see what the completed project will look like, the <a href="https://github.com/willemolding/holochain-rust-todo">full source code is available on GitHub</a>.</p>
<a class="header" href="#first-steps" id="first-steps"><h2>First steps</h2></a>
<p>We will be making a classic to-do list hApp. A user can create new lists and add items to a list. They should also be able to retrieve a list by its address and all of the items on each list.</p>
<p>Let's begin by generating an empty hApp skeleton by running:</p>
<pre><code>hc init holochain-rust-todo
</code></pre>
<p>This will generate the following directory structure:</p>
<pre><code>holochain-rust-todo/
├── app.json
├── test
│ └── …
└── zomes
</code></pre>
<p>Notice the <code>zomes</code> directory. All Holochain hApps are comprised of one or more zomes. They can be thought of as similar to modules in JavaScript, each one should provide some self-contained functionality. Every zome has its own build system so it is possible to combine zomes written in different languages to produce a single hApp.</p>
<p>We will create a single zome called <code>lists</code> that uses a Rust build system:</p>
<pre><code>cd holochain-rust-todo
hc generate zomes/lists rust
</code></pre>
<p>The project structure should now be as follows:</p>
<pre><code>├── app.json
├── test
│ └── …
└── zomes
 └── lists
 ├── code
 │ ├── .hcbuild
 │ ├── Cargo.toml
 │ └── src
 │  └── lib.rs
 └── zome.json
</code></pre>
<a class="header" href="#writing-the-lists-zome" id="writing-the-lists-zome"><h2>Writing the lists zome</h2></a>
<p>The Rust HDK makes use of Rust macros to reduce the need for boilerplate code. The most important of which is the <a href="https://developer.holochain.org/api/0.0.9-alpha/hdk/macro.define_zome.html"><code>define_zome!</code></a> macro. Every zome must use this to define the structure of the zome, what entries it contains, which functions it exposes and what to do on first start-up (genesis).</p>
<p>Open up <code>lib.rs</code> and replace its contents with the following:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[macro_use]
extern crate hdk;
 
define_zome! {
    entries: [
    ]
 
    genesis: || {
        Ok(())
    }
 
    functions: [
    ]
 
    traits: {
    }
}
#}</code></pre></pre>
<p>This is the simplest possible zome with no entries and no exposed functions.</p>
<a class="header" href="#adding-some-entries" id="adding-some-entries"><h2>Adding some Entries</h2></a>
<p>Unlike in holochain-proto, where you needed to define a JSON schema to validate entries, holochain entries in Rust map to a native struct type. We can define our list and listItem structs as follows:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[derive(Serialize, Deserialize, Debug, Clone, DefaultJson)]
struct List {
    name: String
}

#[derive(Serialize, Deserialize, Debug, Clone, DefaultJson)]
struct ListItem {
    text: String,
    completed: bool
}

#[derive(Serialize, Deserialize, Debug, DefaultJson)]
struct GetListResponse {
    name: String,
    items: Vec&lt;ListItem&gt;
}
#}</code></pre></pre>
<p>You might notice that the <code>List</code> struct does not contain a field that holds a collection of <code>ListItem</code>s. This will be implemented using links, which we will discuss later.</p>
<p>Also be sure to add the following to the list of imports:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#![feature(try_from)]
#fn main() {
#[macro_use]
extern crate hdk;
#[macro_use]
extern crate serde_derive;
#[macro_use]
extern crate holochain_core_types_derive;
use hdk::{
    error::ZomeApiResult,
    holochain_core_types::{
        hash::HashString,
        error::HolochainError,
        dna::entry_types::Sharing,
        json::JsonString,
        cas::content::Address,
        entry::Entry,
    }
};
#}</code></pre></pre>
<p>The <code>Serialize</code> and <code>Deserialize</code> derived traits allow the structs to be converted to and from JSON, which is how entries are managed internally in Holochain. The DefaultJson derived trait comes from the holochain HDK itself and allows for seamless converting between data stored in the DHT and rust structs.</p>
<p>These structs on their own are not yet valid Holochain entries. To create these we must include them in the <code>define_zome!</code> macro by using the <code>entry!</code> macro:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// -- SNIP-- //

define_zome! {
    entries: [
        entry!(
            name: &quot;list&quot;,
            description: &quot;&quot;,
            sharing: Sharing::Public,
            validation_package: || hdk::ValidationPackageDefinition::Entry,
            validation: |validation_data: hdk::EntryValidationData&lt;List&gt;| {
                Ok(())
            },
            links: [
                to!(
                    &quot;listItem&quot;,
                    tag: &quot;items&quot;,
                    validation_package: || hdk::ValidationPackageDefinition::Entry,
                    validation: |_validation_data: hdk::LinkValidationData| {
                        Ok(())
                    }
                )
            ]
        ),
        entry!(
            name: &quot;listItem&quot;,
            description: &quot;&quot;,
            sharing: Sharing::Public,
            validation_package: || hdk::ValidationPackageDefinition::Entry,
            validation: |validation_data: hdk::EntryValidationData&lt;ListItem&gt;| {
                Ok(())
            }
        )
    ]

// -- SNIP-- //
#}</code></pre></pre>
<p>Take note of the <code>native_type</code> field of the macro which gives which Rust struct represents the entry type. The <code>validation_package</code> field is a function that defines what data should be passed to the validation function through the <code>ctx</code> argument. In this case we use a predefined function to only include the entry itself, but it is also possible to pass chain headers, chain entries or the full local chain. The validation field is a function that performs custom validation for the entry. In both our cases we are just returning <code>Ok(())</code>.</p>
<p>Take note also of the <code>links</code> field. As we will see later links are the main way to encode relational data in holochain. The <code>links</code> section of the entry macro defines what other types of entries are allowed to link to and from this type. This also includes a validation function for fine grain control over linking.</p>
<a class="header" href="#adding-functions" id="adding-functions"><h2>Adding Functions</h2></a>
<p>Finally we need a way to interact with the hApp. We will define the following functions: <code>create_list</code>, <code>add_item</code> and <code>get_list</code>. get_list will retrieve a list and all the items linked to each list.</p>
<p>For each of these functions we must define a handler, which is a Rust function that will be executed when the conductor calls the function. (For more on conductors, read Nico's recent post.) It is best practice for functions to always return a <code>ZomeApiResult&lt;T&gt;</code>, where <code>T</code> is the type the function should return if it runs without error. This is an extension of the Rust Result type and allows zome functions to abort early on errors using the <code>?</code> operator. At the moment the handler function names cannot be the same as the function itself so we will prefix them with <code>handle_</code>. This will be fixed in an upcoming release. The handler for <code>create_list</code> could be written as:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn handle_create_list(list: List) -&gt; ZomeApiResult&lt;Address&gt; {
    // define the entry
    let list_entry = Entry::App(
        &quot;list&quot;.into(),
        list.into()
    );

    // commit the entry and return the address
    hdk::commit_entry(&amp;list_entry)
}
#}</code></pre></pre>
<p>The <code>hdk::commit_entry</code> function is how a zome can interact with holochain core to add entries to the DHT or local chain. This will trigger the validation function for the entry and if successful will store the entry and return its hash/address.</p>
<p>The <code>add_item</code> function requires the use of holochain links to associate two entries. In holochain-proto this required the use of a commit with a special Links entry but it can now be done using the HDK function <code>link_entries(address1, address2, tag)</code>. The add item handler accepts a <code>ListItem</code> and an address of a list, commits the <code>ListItem</code>, then links it to the list address:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn handle_add_item(list_item: ListItem, list_addr: HashString) -&gt; ZomeApiResult&lt;Address&gt; {
    // define the entry
    let list_item_entry = Entry::App(
        &quot;listItem&quot;.into(),
        list_item.into()
    );

    let item_addr = hdk::commit_entry(&amp;list_item_entry)?; // commit the list item
    hdk::link_entries(&amp;list_addr, &amp;item_addr, &quot;items&quot;)?; // if successful, link to list address
    Ok(item_addr)
}
#}</code></pre></pre>
<p>At the moment there is no validation done on the link entries. This will be added soon with an additional validation callback.</p>
<p>Finally, <code>get_list</code> requires us to use the HDK function <code>get_links(base_address, tag)</code>. As you may have guessed, this will return the addresses of all the entries that are linked to the <code>base_address</code> with a given tag. As this only returns the addresses, we must then map over each of then and load the required entry.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn handle_get_list(list_addr: HashString) -&gt; ZomeApiResult&lt;GetListResponse&gt; {

    // load the list entry. Early return error if it cannot load or is wrong type
    let list = hdk::utils::get_as_type::&lt;List&gt;(list_addr.clone())?;

    // try and load the list items, filter out errors and collect in a vector
    let list_items = hdk::get_links(&amp;list_addr, &quot;items&quot;)?.addresses()
        .iter()
        .map(|item_address| {
            hdk::utils::get_as_type::&lt;ListItem&gt;(item_address.to_owned())
        })
        .filter_map(Result::ok)
        .collect::&lt;Vec&lt;ListItem&gt;&gt;();

    // if this was successful then return the list items
    Ok(GetListResponse{
        name: list.name,
        items: list_items
    })
}
#}</code></pre></pre>
<p>Phew! That is all the handlers set up. Finally the function definitions must be added to the <code>define_zome!</code> macro. Before doing that, it is worth briefly discussing a new concept in Holochain, <em>traits</em>. Traits allow functions to be grouped to control access and in the future will allow hApps to connect to other hApps that implement a particular trait. At this time the only trait we need to consider is the hc_public trait. This is a special named trait that exposes all of the contained functions to the outside world.</p>
<p>The function field of our zome definition should be updated to:</p>
<pre><code>define_zome! {

    // -- SNIP-- //
    functions: [
        create_list: {
            inputs: |list: List|,
            outputs: |result: ZomeApiResult&lt;Address&gt;|,
            handler: handle_create_list
        }
        add_item: {
            inputs: |list_item: ListItem, list_addr: HashString|,
            outputs: |result: ZomeApiResult&lt;Address&gt;|,
            handler: handle_add_item
        }
        get_list: {
            inputs: |list_addr: HashString|,
            outputs: |result: ZomeApiResult&lt;GetListResponse&gt;|,
            handler: handle_get_list
        }
        ]
        traits: {
        hc_public [create_list, add_item, get_list]
        }
}
</code></pre>
<p>and there we have it! If you are coding along the full lib.rs should now look like this:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#![feature(try_from)]
#fn main() {
#[macro_use]
extern crate hdk;
#[macro_use]
extern crate serde_derive;
#[macro_use]
extern crate holochain_core_types_derive;

use hdk::{
    error::ZomeApiResult,
    holochain_core_types::{
        hash::HashString,
        error::HolochainError,
        dna::entry_types::Sharing,
        json::JsonString,
        cas::content::Address,
        entry::Entry,
    }
};

 
define_zome! {
    entries: [
        entry!(
            name: &quot;list&quot;,
            description: &quot;&quot;,
            sharing: Sharing::Public,
            validation_package: || hdk::ValidationPackageDefinition::Entry,
            validation: |validation_data: hdk::EntryValidationData&lt;List&gt;| {
                Ok(())
            },
            links: [
                to!(
                    &quot;listItem&quot;,
                    tag: &quot;items&quot;,
                    validation_package: || hdk::ValidationPackageDefinition::Entry,
                    validation: |_validation_data: hdk::LinkValidationData| {
                        Ok(())
                    }
                )
            ]
        ),
        entry!(
            name: &quot;listItem&quot;,
            description: &quot;&quot;,
            sharing: Sharing::Public,
            validation_package: || hdk::ValidationPackageDefinition::Entry,
            validation: |validation_data: hdk::EntryValidationData&lt;ListItem&gt;| {
                Ok(())
            }
        )
    ]
 
    genesis: || {
        Ok(())
    }
 
    functions: [
        create_list: {
            inputs: |list: List|,
            outputs: |result: ZomeApiResult&lt;Address&gt;|,
            handler: handle_create_list
        }
        add_item: {
            inputs: |list_item: ListItem, list_addr: HashString|,
            outputs: |result: ZomeApiResult&lt;Address&gt;|,
            handler: handle_add_item
        }
        get_list: {
            inputs: |list_addr: HashString|,
            outputs: |result: ZomeApiResult&lt;GetListResponse&gt;|,
            handler: handle_get_list
        }
    ]
    traits: {
        hc_public [create_list, add_item, get_list]
    }
}


#[derive(Serialize, Deserialize, Debug, Clone, DefaultJson)]
struct List {
    name: String
}

#[derive(Serialize, Deserialize, Debug, Clone, DefaultJson)]
struct ListItem {
    text: String,
    completed: bool
}

#[derive(Serialize, Deserialize, Debug, DefaultJson)]
struct GetListResponse {
    name: String,
    items: Vec&lt;ListItem&gt;
}

fn handle_create_list(list: List) -&gt; ZomeApiResult&lt;Address&gt; {
    // define the entry
    let list_entry = Entry::App(
        &quot;list&quot;.into(),
        list.into()
    );

    // commit the entry and return the address
    hdk::commit_entry(&amp;list_entry)
}


fn handle_add_item(list_item: ListItem, list_addr: HashString) -&gt; ZomeApiResult&lt;Address&gt; {
    // define the entry
    let list_item_entry = Entry::App(
        &quot;listItem&quot;.into(),
        list_item.into()
    );

    let item_addr = hdk::commit_entry(&amp;list_item_entry)?; // commit the list item
    hdk::link_entries(&amp;list_addr, &amp;item_addr, &quot;items&quot;)?; // if successful, link to list address
    Ok(item_addr)
}


fn handle_get_list(list_addr: HashString) -&gt; ZomeApiResult&lt;GetListResponse&gt; {

    // load the list entry. Early return error if it cannot load or is wrong type
    let list = hdk::utils::get_as_type::&lt;List&gt;(list_addr.clone())?;

    // try and load the list items, filter out errors and collect in a vector
    let list_items = hdk::get_links(&amp;list_addr, &quot;items&quot;)?.addresses()
        .iter()
        .map(|item_address| {
            hdk::utils::get_as_type::&lt;ListItem&gt;(item_address.to_owned())
        })
        .filter_map(Result::ok)
        .collect::&lt;Vec&lt;ListItem&gt;&gt;();

    // if this was successful then return the list items
    Ok(GetListResponse{
        name: list.name,
        items: list_items
    })
}
#}</code></pre></pre>
<p>The Zome we created should now build if we run:</p>
<pre><code>hc package
</code></pre>
<p>from the root directory. This will compile the Rust to WebAssembly and produce a <code>holochain-rust-todo.dna.json</code> file in the <code>dist</code> folder which contains the compiled WASM code and the required metadata. This is the file that we can load and run using <code>hc</code>.</p>
<a class="header" href="#writing-tests" id="writing-tests"><h2>Writing tests</h2></a>
<p>The testing framework is built on JavaScript around Tape.js and allows for writing single agent and multi-agent tests using javascript async/await syntax.
Opening up the <code>test/index.js</code> file you will see a skeleton test file already created:</p>
<pre><code class="language-javascript">// This test file uses the tape testing framework.
// To learn more, go here: https://github.com/substack/tape
const { Config, Scenario } = require(&quot;@holochain/holochain-nodejs&quot;)
Scenario.setTape(require(&quot;tape&quot;))

const dnaPath = &quot;./dist/holochain-rust-todo.dna.json&quot;
const agentAlice = Config.agent(&quot;alice&quot;)
const dna = Config.dna(dnaPath)
const instanceAlice = Config.instance(agentAlice, dna)
const scenario = new Scenario([instanceAlice])

scenario.runTape(&quot;description of example test&quot;, async (t, { alice }) =&gt; {
  // Make a call to a Zome function
  // indicating the function, and passing it an input
  const addr = alice.call(&quot;my_zome&quot;, &quot;create_my_entry&quot;, {&quot;entry&quot; : {&quot;content&quot;:&quot;sample content&quot;}})
  const result = alice.call(&quot;my_zome&quot;, &quot;get_my_entry&quot;, {&quot;address&quot;: addr.Ok})

  // check for equality of the actual and expected results
  t.deepEqual(result, { Ok: { App: [ 'my_entry', '{&quot;content&quot;:&quot;sample content&quot;}' ] } })
})
</code></pre>
<p>This illustrates the <code>app.call</code> function that is exposed by the conductor for each app and that can be used to call our functions. Take note that the input-data should be a JSON object that matches the function signature. <code>call</code> will also return a JSON object.</p>
<p>Lets add some tests for our todo list:</p>
<pre><code class="language-javascript">const { Config, Scenario } = require('@holochain/holochain-nodejs')
Scenario.setTape(require('tape'))
const dnaPath = &quot;./dist/holochain-rust-todo.dna.json&quot;
const dna = Config.dna(dnaPath, 'happs')
const agentAlice = Config.agent('alice')
const instanceAlice = Config.instance(agentAlice, dna)
const scenario = new Scenario([instanceAlice])

scenario.runTape('Can create a list', async (t, { alice }) =&gt; {
  const createResult = await alice.callSync('lists', 'create_list', { list: { name: 'test list' } })
  console.log(createResult)
  t.notEqual(createResult.Ok, undefined)
})

scenario.runTape('Can add some items', async (t, { alice }) =&gt; {
  const createResult = await alice.callSync('lists', 'create_list', { list: { name: 'test list' } })
  const listAddr = createResult.Ok

  const result1 = await alice.callSync('lists', 'add_item', { list_item: { text: 'Learn Rust', completed: true }, list_addr: listAddr })
  const result2 = await alice.callSync('lists', 'add_item', { list_item: { text: 'Master Holochain', completed: false }, list_addr: listAddr })

  console.log(result1)
  console.log(result2)

  t.notEqual(result1.Ok, undefined)
  t.notEqual(result2.Ok, undefined)
})

scenario.runTape('Can get a list with items', async (t, { alice }) =&gt; {
  const createResult = await alice.callSync('lists', 'create_list', { list: { name: 'test list' } })
  const listAddr = createResult.Ok

  await alice.callSync('lists', 'add_item', { list_item: { text: 'Learn Rust', completed: true }, list_addr: listAddr })
  await alice.callSync('lists', 'add_item', { list_item: { text: 'Master Holochain', completed: false }, list_addr: listAddr })

  const getResult = await alice.callSync('lists', 'get_list', { list_addr: listAddr })
  console.log(getResult)

  t.equal(getResult.Ok.items.length, 2, 'there should be 2 items in the list')
})
</code></pre>
<p>Running <code>hc test</code> will build the test file and run it using <code>node</code> which is able to load and execute holochain hApps via the holochain node conductor. If everything has worked correctly you should see some test output with everything passing.</p>
<p>Pro tip: <a href="https://github.com/scottcorgan/tap-spec">Pipe the output to tap-spec</a> (which must be installed via npm first) to get beautifully formatted test output.</p>
<a class="header" href="#conclusion" id="conclusion"><h2>Conclusion</h2></a>
<p>And there we have it! A simple Zome created with Holochain using the Rust HDK.</p>
<p>The <a href="https://github.com/willemolding/holochain-rust-todo">complete working version of this project is available on github</a>. This builds under the 0.0.9-alpha release but as the API and HDK are changing it will likely fail under newer releases.</p>

                        <hr />
                        <a href="https://github.com/holochain/holochain-rust/edit/develop/doc/holochain_101/src/first_steps.md">suggest an edit</a>
                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        
                            <a rel="prev" href="zome/welcome.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        

                        
                            <a rel="next" href="zome/adding_a_zome.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                
                    <a href="zome/welcome.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                

                
                    <a href="zome/adding_a_zome.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
                
            </nav>

        </div>

        

        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        

    </body>
</html>
