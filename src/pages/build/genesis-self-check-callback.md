---
title: "Genesis Self-Check Callback"
---

::: intro
When an agent hasn't yet joined a network, but has written their [**membrane proof**](/concepts/3_source_chain/#source-chain-your-own-data-store) to their [**source chain**](/concepts/3_source_chain/), they may not be able to fully validate it, but still need a way to do basic pre-validation before joining the network. This helps prevent them from being rejected from the network.
:::

## Membrane proof: a per-agent joining code for a network

While Holochain requires an agent to have the correct [DNA hash](/build/dnas/#dnas-the-rules-of-the-game-for-a-network) to join a network, a DNA can impose extra access control via a **membrane proof**, a small piece of data that acts at the level of an individual agent. It should be generated by an authority and given to the user, then a runtime like the Holochain Launcher will ask them for it when a hApp is installed. It's written to the source chain as an [`AgentValidationPkg`](https://docs.rs/holochain_integrity_types/latest/holochain_integrity_types/action/enum.Action.html#variant.AgentValidationPkg) record.

A membrane proof can be basic, like a secret user-specific passcode that's stored on the DHT, or it can be something complex like a [JSON Web Token (JWT)](https://jwt.io/) signed by an agent in the DHT that has authority to admit members.

!!! info Access control isn't implemented yet
This feature is not fully implemented. Currently, validators merely record validation failure for a membrane proof and supply it on request. It's our plan to use validation to block communications with agents that supply an invalid membrane proof.
!!!

## The need for basic pre-validation

The use cases we just explored require access to network data in order to fully validate the membrane proof. But an agent can't self-validate their own membership proof at cell startup, because they haven't joined the network. This creates a problem; they may accidentally type their membrane proof wrong, but won't find out until they try to join the network and immediately get ejected.

To reduce the risk, you can define a `genesis_self_check` function that checks the membrane proof before network communications start. This function is limited --- it naturally doesn't have access to DHT data. But it can be a useful guard against basic data entry errors.

## Define a `genesis_self_check` callback

`genesis_self_check` must take a single argument of type [`GenesisSelfCheckData`](https://docs.rs/hdi/latest/hdi/prelude/type.GenesisSelfCheckData.html) and return a value of type [`ValidateCallbackResult`](https://docs.rs/hdi/latest/hdi/prelude/enum.ValidateCallbackResult.html) wrapped in an `ExternResult`.

Here's an example that checks that the membrane proof exists and is the right length:

```rust
use hdi::prelude::*;

#[hdk_extern]
pub fn genesis_self_check(data: GenesisSelfCheckData) -> ExternResult<ValidateCallbackResult> {
    if let Some(membrane_proof) = data.membrane_proof {
        if membrane_proof.bytes().len() == 32 {
            return Ok(ValidateCallbackResult::Valid);
        }
        return Ok(ValidateCallbackResult::Invalid("Membrane proof is not the right length. Please check it and enter it again.".into()));
    }
    Ok(ValidateCallbackResult::Invalid("This network needs a membrane proof to join.".into()))
}
```

This more complex example deserializes a JWT, checks that its [`sub` (subject) field](https://datatracker.ietf.org/doc/html/rfc7519#section-4.1.2) matches the agent's public key, and checks that its [`iss` (issuer) field](https://datatracker.ietf.org/doc/html/rfc7519#section-4.1.1) matches an authorized key hard-coded into the DNA's [`properties` block](/build/dnas/#properties).

```rust
use hdi::prelude::*;

// A type for deserializing a JWT payload from our membrane proof.
#[derive(Serialize, Deserialize)]
pub struct MembraneProofJwtPayload {
    pub iss: AgentPubKeyB64,
    pub sub: AgentPubKeyB64,
}

// A type for deserializing the DNA properties that this integrity zome needs.
#[dna_properties]
pub struct DnaProperties {
    membrane_proof_signing_authority: AgentPubKeyB64,
}

#[hdk_extern]
pub fn genesis_self_check(data: GenesisSelfCheckData) -> ExternResult<ValidateCallbackResult> {
    if let Some(membrane_proof) = data.membrane_proof {
        // A JWT is three JSON objects, Base64 urlencoded, and concatenated
        // with periods. Let's break it apart, decode, and deserialize it.
        let parts: Vec<&str> = std::str::from_utf8(membrane_proof.bytes())
            .map_err(|e| wasm_error!(e.to_string()))?
            .split(".")
            .collect();
        let payload_encoded = parts[1];
        let payload_decoded = base64_url::decode(payload_encoded)
            .map_err(|e| wasm_error!(e.to_string()))?;
        let payload_string = std::str::from_utf8(&payload_decoded)
            .map_err(|e| wasm_error!(e.to_string()))?;
        let payload: MembraneProofJwtPayload = serde_json::from_str(payload_string)
            .map_err(|e| wasm_error!(e.to_string()))?;

        // Now that we've got that, compare it against the public key of the
        // agent submitting the membrane proof.
        if payload.sub != data.agent_key.into() {
            return Ok(ValidateCallbackResult::Invalid("Author's public key doesn't match membrane proof".into()));
        }

        // And against the DNA's authorized membrane proof signer.
        if payload.iss != DnaProperties::try_from_dna_properties()?.membrane_proof_signing_authority {
            return Ok(ValidateCallbackResult::Invalid("Membrane proof issuer is unrecognized".into()));
        }
    }
    Ok(ValidateCallbackResult::Invalid("This network needs a membrane proof to join.".into()))
}
```

## Fully validating a membrane proof

Your `validate` callback also needs to validate a membrane proof in order to actually enforce network access. At the very least, it should apply the same rules as `genesis_self_check` does, and add on any checks that require DHT data. We'll explore this in full on the [`validate` callback](/build/validate-callback/#TODO) page.

## Reference

* [`holochain_integrity_types::genesis::GenesisSelfCheckData`](https://docs.rs/holochain_integrity_types/latest/holochain_integrity_types/genesis/type.GenesisSelfCheckData.html)
* [`holochain_integrity_types::validate::ValidateCallbackResult`](https://docs.rs/holochain_integrity_types/latest/holochain_integrity_types/genesis/type.GenesisSelfCheckData.html)
* [`holochain_derive::dna_properties`](https://docs.rs/hdk_derive/latest/hdk_derive/attr.dna_properties.html)

## Further reading

* [Core Concepts: Genesis self-check](/concepts/7_validation/#genesis-self-check)
* [Build Guide: Validation](/build/validation/)